-- FILE: 20250827_add_email_agente_to_candidatos.sql
-- Agrega columna email_agente a candidatos
-- Ejecutar una sola vez; si la columna ya existe ignorar manualmente.
ALTER TABLE candidatos ADD COLUMN email_agente text;
create index if not exists idx_candidatos_email_agente on candidatos(email_agente);


-- FILE: 20250827_fase2_prospectos_planificacion.sql
-- Fase 2: Tablas prospectos y planificaciones
-- idempotencia simple: crear si no existen

create table if not exists prospectos (
  id bigserial primary key,
  agente_id bigint not null references usuarios(id) on delete cascade,
  anio smallint not null,
  semana_iso smallint not null,
  nombre text not null,
  telefono text,
  notas text,
  estado text not null default 'pendiente' check (estado in ('pendiente','seguimiento','con_cita','descartado')),
  fecha_cita date,
  created_at timestamptz default now(),
  updated_at timestamptz
);

create index if not exists idx_prospectos_agente_semana on prospectos(agente_id, anio, semana_iso);
create index if not exists idx_prospectos_estado on prospectos(estado);

create table if not exists planificaciones (
  id bigserial primary key,
  agente_id bigint not null references usuarios(id) on delete cascade,
  anio smallint not null,
  semana_iso smallint not null,
  prima_anual_promedio numeric(12,2) not null default 30000,
  porcentaje_comision numeric(5,2) not null default 35,
  bloques jsonb not null default '[]',
  created_at timestamptz default now(),
  updated_at timestamptz,
  constraint planif_unica_agente_semana unique(agente_id, anio, semana_iso)
);

create index if not exists idx_planif_agente_semana on planificaciones(agente_id, anio, semana_iso);


-- FILE: 20250828_alter_prospectos_fecha_cita_timestamp.sql
-- MigraciÃ³n: ampliar fecha_cita (prospectos) a timestamp con hora
-- Permite agendar cita con fecha y hora (antes solo date)
ALTER TABLE prospectos
  ALTER COLUMN fecha_cita TYPE timestamptz USING fecha_cita::timestamptz;

-- Nota: el nombre de la columna se mantiene (fecha_cita) para no romper cÃ³digo existente.

-- FILE: 20250828_parametros_and_fix_fecha_cita.sql
-- CreaciÃ³n directa (create table if not exists no duplicarÃ¡)
create table if not exists "Parametros" (
  id bigserial primary key,
  tipo text not null,
  clave text,
  valor text,
  descripcion text,
  actualizado_por text,
  actualizado_en timestamptz default now()
);
create index if not exists idx_parametros_tipo on "Parametros"(tipo);
create unique index if not exists idx_parametros_tipo_clave on "Parametros"(tipo, clave);

-- Seed de parÃ¡metros fase2 (solo si no existen)
insert into "Parametros"(tipo, clave, valor, descripcion)
select 'fase2','meta_prospectos_semana','30','Meta semanal de prospectos'
where not exists (select 1 from "Parametros" where tipo='fase2' and clave='meta_prospectos_semana');

insert into "Parametros"(tipo, clave, valor, descripcion)
select 'fase2','meta_citas_semana','5','Meta semanal de citas'
where not exists (select 1 from "Parametros" where tipo='fase2' and clave='meta_citas_semana');

-- NOTA: Ejecutar manualmente en DB si la columna sigue siendo date:
-- ALTER TABLE prospectos ALTER COLUMN fecha_cita TYPE timestamptz USING (fecha_cita::timestamptz);


-- FILE: 20250829_set_roles_timezone_cdmx.sql
-- Migration: Set Postgres role session timezone to America/Mexico_City
-- Fecha: 2025-08-29
-- Objetivo: Asegurar que las sesiones (p.ej. RLS/funciones) utilicen la zona horaria CDMX
-- Nota: Los valores timestamptz seguirÃ¡n almacenados en UTC internamente; esto sÃ³lo afecta la representaciÃ³n por defecto.

-- Roles estÃ¡ndar de Supabase (usamos DO para evitar problemas de linters)
DO $$ BEGIN
	EXECUTE 'ALTER ROLE anon SET timezone = ''America/Mexico_City''';
	EXECUTE 'ALTER ROLE authenticated SET timezone = ''America/Mexico_City''';
	EXECUTE 'ALTER ROLE service_role SET timezone = ''America/Mexico_City''';
END $$;

-- Agrega aquÃ­ otros roles personalizados si existen
-- DO $$ BEGIN EXECUTE 'ALTER ROLE administrador SET timezone = ''America/Mexico_City'''; END $$;

-- VerificaciÃ³n (se puede ejecutar manualmente, no se almacena resultado):
-- SHOW TIMEZONE; -- deberÃ­a devolver 'America/Mexico_City'

-- Ejemplo de comparaciÃ³n de hora (ejecutar manualmente si se desea):
-- SELECT now()                                AS now_session,
--        now() AT TIME ZONE 'UTC'             AS now_utc,
--        now() AT TIME ZONE 'America/Mexico_City' AS now_cdmx;

-- Si en el futuro se requiere revertir:
-- ALTER ROLE anon RESET timezone;
-- ALTER ROLE authenticated RESET timezone;
-- ALTER ROLE service_role RESET timezone;


-- FILE: 20250831_add_email_candidato_unique.sql
-- Asegura unicidad por correo del candidato entre no eliminados usando la columna existente email_agente

-- Ãndice Ãºnico lÃ³gico: asegura unicidad de email_agente solo cuando eliminado=false
CREATE UNIQUE INDEX IF NOT EXISTS ux_candidatos_email_agente_not_deleted
  ON candidatos ((CASE WHEN eliminado = false THEN email_agente ELSE NULL END));

-- Comentario: el correo del candidato se almacena en candidatos.email_agente y debe ser Ãºnico entre no eliminados.


-- FILE: 20250831_add_etapas_completadas_to_candidatos.sql
-- Add JSONB column to track completion of MES/EFC related etapas
ALTER TABLE candidatos ADD COLUMN etapas_completadas jsonb;

-- Optional: comment for documentation
COMMENT ON COLUMN candidatos.etapas_completadas IS 'Estado de completado por etapa (MES/EFC) con metadatos: { "periodo_para_registro_y_envio_de_documentos": { completed, by:{email,nombre}, at }, ... }';


-- FILE: 20250903_prospectos_historial.sql
-- Create table to track prospecto estado changes and note additions
create table if not exists public.prospectos_historial (
  id bigserial primary key,
  created_at timestamptz not null default now(),
  prospecto_id bigint not null references public.prospectos(id) on delete cascade,
  agente_id bigint,
  usuario_email text,
  estado_anterior text,
  estado_nuevo text,
  nota_agregada boolean default false,
  notas_anteriores text,
  notas_nuevas text
);

create index if not exists idx_prospectos_historial_created_at on public.prospectos_historial (created_at desc);
create index if not exists idx_prospectos_historial_prospecto on public.prospectos_historial (prospecto_id);

-- FILE: 20250904_align_candidatos_develop.sql
-- Align candidatos table in main to match develop
-- Adds missing columns and index in an idempotent way

-- 1) Add missing columns
-- Ejecutar una sola vez; si la columna ya existe ignorar manualmente.
ALTER TABLE candidatos ADD COLUMN fecha_creacion_ct date;
ALTER TABLE candidatos ADD COLUMN proceso text;

-- 2) Add missing index for proceso
create index if not exists candidatos_proceso_idx on candidatos (proceso);

-- Notes:
-- - Foreign keys in main already exist (names differ vs develop, but references are equivalent).
-- - Other indexes/constraints are already present in both branches.


-- FILE: 20250904_align_usuarios_roles.sql
-- Align usuarios.rol CHECK constraint in main to match develop
-- Permit roles: admin, supervisor, viewer, agente

-- Drop existing CHECK (name assumed default)
ALTER TABLE public.usuarios DROP CONSTRAINT usuarios_rol_check;

-- Recreate CHECK with full allowed set
ALTER TABLE public.usuarios
  ADD CONSTRAINT usuarios_rol_check
  CHECK (rol IN ('admin','supervisor','viewer','agente'));


-- FILE: 20250908_fase3_sprint1_base.sql
-- Fase 3 â€“ Sprint 1: Migraciones base
-- Fecha: 2025-09-08
-- Objetivo: Estructura mÃ­nima (ENUMs, secuencia/cÃ³digo de cliente, tablas base y RLS inicial)

-- Extensiones necesarias (omitido: Supabase ya incluye pgcrypto)

-- Tipos ENUM (creaciÃ³n directa; se asume entorno nuevo)
CREATE TYPE estatus_poliza AS ENUM ('EN_VIGOR', 'ANULADA');
CREATE TYPE forma_pago AS ENUM ('MODO_DIRECTO', 'CARGO_AUTOMATICO');
CREATE TYPE tipo_producto AS ENUM ('VI', 'GMM');
CREATE TYPE tipo_clasificacion_puntos AS ENUM ('CERO','MEDIO','SIMPLE','DOBLE','TRIPLE');
CREATE TYPE moneda_poliza AS ENUM ('MXN','USD','UDI');
CREATE TYPE estado_solicitud_cambio AS ENUM ('PENDIENTE','APROBADA','RECHAZADA');
CREATE TYPE tipo_cambio_cliente AS ENUM ('CREACION','MODIFICACION','APROBACION','RECHAZO');

-- Secuencia y funciÃ³n para cÃ³digo de cliente
CREATE SEQUENCE IF NOT EXISTS seq_cliente_code START 1;

CREATE OR REPLACE FUNCTION generar_cliente_code() RETURNS text AS $$
  SELECT 'LEACL-' || lpad(nextval('seq_cliente_code')::text, 6, '0');
$$ LANGUAGE sql VOLATILE;

-- FunciÃ³n utilitaria: actualizar updated_at
CREATE OR REPLACE FUNCTION set_updated_at() RETURNS trigger AS $$
BEGIN
  NEW.updated_at := now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Tabla producto_parametros
CREATE TABLE IF NOT EXISTS producto_parametros (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  nombre_comercial text NOT NULL,
  tipo_producto tipo_producto NOT NULL,
  moneda moneda_poliza NULL,
  duracion_anios int NULL,
  condicion_sa_tipo text NULL,
  sa_min numeric(18,2) NULL,
  sa_max numeric(18,2) NULL,
  condicion_edad_tipo text NULL,
  edad_min int NULL,
  edad_max int NULL,
  anio_1_percent numeric(6,3) NULL,
  anio_2_percent numeric(6,3) NULL,
  anio_3_percent numeric(6,3) NULL,
  anio_4_percent numeric(6,3) NULL,
  anio_5_percent numeric(6,3) NULL,
  anio_6_percent numeric(6,3) NULL,
  anio_7_percent numeric(6,3) NULL,
  anio_8_percent numeric(6,3) NULL,
  anio_9_percent numeric(6,3) NULL,
  anio_10_percent numeric(6,3) NULL,
  anio_11_plus_percent numeric(6,3) NULL,
  puntos_multiplicador int NOT NULL DEFAULT 1,
  activo boolean NOT NULL DEFAULT true,
  creado_por uuid NULL,
  creado_at timestamptz NOT NULL DEFAULT now()
);

-- (retirado) columnas generadas: se usa trigger con columnas planas abajo

-- Sustituir columnas generadas por columnas normales + trigger (evita restricciÃ³n de IMMUTABLE)
ALTER TABLE producto_parametros
  DROP COLUMN IF EXISTS moneda_key,
  DROP COLUMN IF EXISTS duracion_anios_key,
  DROP COLUMN IF EXISTS condicion_sa_tipo_key,
  DROP COLUMN IF EXISTS sa_min_key,
  DROP COLUMN IF EXISTS sa_max_key,
  DROP COLUMN IF EXISTS condicion_edad_tipo_key,
  DROP COLUMN IF EXISTS edad_min_key,
  DROP COLUMN IF EXISTS edad_max_key;

ALTER TABLE producto_parametros
  ADD COLUMN IF NOT EXISTS moneda_key text,
  ADD COLUMN IF NOT EXISTS duracion_anios_key int,
  ADD COLUMN IF NOT EXISTS condicion_sa_tipo_key text,
  ADD COLUMN IF NOT EXISTS sa_min_key numeric(18,2),
  ADD COLUMN IF NOT EXISTS sa_max_key numeric(18,2),
  ADD COLUMN IF NOT EXISTS condicion_edad_tipo_key text,
  ADD COLUMN IF NOT EXISTS edad_min_key int,
  ADD COLUMN IF NOT EXISTS edad_max_key int;

CREATE OR REPLACE FUNCTION producto_parametros_set_keys() RETURNS trigger AS $$
BEGIN
  NEW.moneda_key := COALESCE(NEW.moneda::text, '');
  NEW.duracion_anios_key := COALESCE(NEW.duracion_anios, -1);
  NEW.condicion_sa_tipo_key := COALESCE(NEW.condicion_sa_tipo, '');
  NEW.sa_min_key := COALESCE(NEW.sa_min, (-1)::numeric);
  NEW.sa_max_key := COALESCE(NEW.sa_max, (-1)::numeric);
  NEW.condicion_edad_tipo_key := COALESCE(NEW.condicion_edad_tipo, '');
  NEW.edad_min_key := COALESCE(NEW.edad_min, -1);
  NEW.edad_max_key := COALESCE(NEW.edad_max, -1);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_producto_parametros_set_keys ON producto_parametros;
CREATE TRIGGER trg_producto_parametros_set_keys
BEFORE INSERT OR UPDATE ON producto_parametros
FOR EACH ROW EXECUTE FUNCTION producto_parametros_set_keys();

-- Normaliza datos existentes, si los hay
UPDATE producto_parametros SET
  moneda_key = COALESCE(moneda::text, ''),
  duracion_anios_key = COALESCE(duracion_anios, -1),
  condicion_sa_tipo_key = COALESCE(condicion_sa_tipo, ''),
  sa_min_key = COALESCE(sa_min, (-1)::numeric),
  sa_max_key = COALESCE(sa_max, (-1)::numeric),
  condicion_edad_tipo_key = COALESCE(condicion_edad_tipo, ''),
  edad_min_key = COALESCE(edad_min, -1),
  edad_max_key = COALESCE(edad_max, -1);

CREATE UNIQUE INDEX IF NOT EXISTS uq_producto_parametros_variant_idx ON producto_parametros (
  nombre_comercial,
  moneda_key,
  duracion_anios_key,
  condicion_sa_tipo_key,
  sa_min_key,
  sa_max_key,
  condicion_edad_tipo_key,
  edad_min_key,
  edad_max_key
);

-- Tablas de valores UDI y FX
CREATE TABLE IF NOT EXISTS udi_values (
  fecha date PRIMARY KEY,
  valor numeric(12,6) NOT NULL,
  source text NULL,
  fetched_at timestamptz NULL,
  stale boolean NOT NULL DEFAULT false
);

CREATE TABLE IF NOT EXISTS fx_values (
  fecha date PRIMARY KEY,
  valor numeric(12,6) NOT NULL,
  source text NULL,
  fetched_at timestamptz NULL,
  stale boolean NOT NULL DEFAULT false
);
COMMENT ON TABLE fx_values IS 'Tipo de cambio USD/MXN del dÃ­a (PK = fecha)';

-- Calendario de dÃ­as por mes (con reglas de unicidad para default y aÃ±o especÃ­fico)
CREATE TABLE IF NOT EXISTS dias_mes (
  id bigserial PRIMARY KEY,
  mes smallint NOT NULL CHECK (mes BETWEEN 1 AND 12),
  anio int NULL,
  max_dias smallint NOT NULL CHECK (max_dias BETWEEN 28 AND 31),
  es_bisiesto boolean NOT NULL DEFAULT false
);
-- Ãšnico para registros especÃ­ficos por aÃ±o
CREATE UNIQUE INDEX IF NOT EXISTS uq_dias_mes_mes_anio_notnull ON dias_mes(mes, anio) WHERE anio IS NOT NULL;
-- Ãšnico para registro default (anio IS NULL) por mes
CREATE UNIQUE INDEX IF NOT EXISTS uq_dias_mes_mes_anio_null ON dias_mes(mes) WHERE anio IS NULL;

-- Seed inicial dias_mes (solo si vacÃ­o)
INSERT INTO dias_mes(mes, anio, max_dias, es_bisiesto)
SELECT v.mes, v.anio, v.max_dias, v.es_bisiesto FROM (
  VALUES
    (1::smallint, NULL::int, 31::smallint, false),
    (2::smallint, NULL::int, 28::smallint, false),
    (3::smallint, NULL::int, 31::smallint, false),
    (4::smallint, NULL::int, 30::smallint, false),
    (5::smallint, NULL::int, 31::smallint, false),
    (6::smallint, NULL::int, 30::smallint, false),
    (7::smallint, NULL::int, 31::smallint, false),
    (8::smallint, NULL::int, 31::smallint, false),
    (9::smallint, NULL::int, 30::smallint, false),
    (10::smallint, NULL::int, 31::smallint, false),
    (11::smallint, NULL::int, 30::smallint, false),
    (12::smallint, NULL::int, 31::smallint, false)
) AS v(mes, anio, max_dias, es_bisiesto)
ON CONFLICT DO NOTHING;

-- Tabla clientes
CREATE TABLE IF NOT EXISTS clientes (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  cliente_code text NOT NULL UNIQUE DEFAULT generar_cliente_code(),
  primer_nombre text NOT NULL,
  segundo_nombre text NULL,
  primer_apellido text NOT NULL,
  segundo_apellido text NOT NULL,
  telefono_celular text NOT NULL,
  correo text NOT NULL,
  full_name_normalizado text NOT NULL DEFAULT '',
  asesor_id uuid NULL,
  creado_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

-- Ãndice de apoyo para detecciÃ³n de duplicados
CREATE INDEX IF NOT EXISTS idx_clientes_email_apellidos ON clientes (lower(correo), primer_apellido, segundo_apellido);

-- Trigger updated_at clientes
DROP TRIGGER IF EXISTS trg_clientes_set_updated_at ON clientes;
CREATE TRIGGER trg_clientes_set_updated_at
BEFORE UPDATE ON clientes
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- Tabla polizas (crear si no existe)
CREATE TABLE IF NOT EXISTS polizas (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  cliente_id uuid NOT NULL REFERENCES clientes(id) ON DELETE CASCADE,
  producto_parametro_id uuid NULL REFERENCES producto_parametros(id),
  numero_poliza text NOT NULL,
  estatus estatus_poliza NOT NULL DEFAULT 'EN_VIGOR',
  fecha_emision date NOT NULL,
  fecha_alta_sistema timestamptz NOT NULL DEFAULT now(),
  forma_pago forma_pago NOT NULL,
  prima_input numeric(14,2) NOT NULL,
  prima_moneda moneda_poliza NOT NULL,
  prima_mxn numeric(14,2) NOT NULL DEFAULT 0,
  sa_input numeric(18,2) NULL,
  sa_moneda moneda_poliza NULL,
  sa_mxn numeric(18,2) NULL,
  clasificacion_actual tipo_clasificacion_puntos NULL,
  puntos_actuales numeric(10,2) NULL,
  anulada_at timestamptz NULL,
  creado_por uuid NULL,
  creado_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT uq_polizas_numero UNIQUE (numero_poliza)
);

-- Ãndices de apoyo polizas
CREATE INDEX IF NOT EXISTS idx_polizas_cliente_estado ON polizas(cliente_id, estatus);
CREATE INDEX IF NOT EXISTS idx_polizas_producto ON polizas(producto_parametro_id);

-- Trigger updated_at polizas
DROP TRIGGER IF EXISTS trg_polizas_set_updated_at ON polizas;
CREATE TRIGGER trg_polizas_set_updated_at
BEFORE UPDATE ON polizas
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- Tabla poliza_puntos_cache
CREATE TABLE IF NOT EXISTS poliza_puntos_cache (
  poliza_id uuid PRIMARY KEY REFERENCES polizas(id) ON DELETE CASCADE,
  puntos_total numeric(10,2) NOT NULL,
  clasificacion tipo_clasificacion_puntos NOT NULL,
  base_factor numeric(10,4) NULL,
  producto_factor numeric(10,4) NULL,
  year_factor int NULL,
  prima_anual_snapshot numeric(14,2) NULL,
  producto_parametro_id uuid NULL REFERENCES producto_parametros(id),
  udi_valor numeric(12,6) NULL,
  usd_fx numeric(12,6) NULL,
  breakdown jsonb NULL,
  recalculo_reason text NULL,
  computed_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

-- Trigger updated_at poliza_puntos_cache
DROP TRIGGER IF EXISTS trg_poliza_puntos_cache_set_updated_at ON poliza_puntos_cache;
CREATE TRIGGER trg_poliza_puntos_cache_set_updated_at
BEFORE UPDATE ON poliza_puntos_cache
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- Tabla cliente_historial
CREATE TABLE IF NOT EXISTS cliente_historial (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  cliente_id uuid NOT NULL REFERENCES clientes(id) ON DELETE CASCADE,
  cambio_tipo tipo_cambio_cliente NOT NULL,
  payload_old jsonb NULL,
  payload_new jsonb NULL,
  actor_id uuid NULL,
  creado_at timestamptz NOT NULL DEFAULT now()
);

-- Tabla cliente_update_requests
CREATE TABLE IF NOT EXISTS cliente_update_requests (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  cliente_id uuid NOT NULL REFERENCES clientes(id) ON DELETE CASCADE,
  solicitante_id uuid NULL,
  payload_propuesto jsonb NOT NULL,
  estado estado_solicitud_cambio NOT NULL,
  motivo_rechazo text NULL,
  creado_at timestamptz NOT NULL DEFAULT now(),
  resuelto_at timestamptz NULL,
  resuelto_por uuid NULL
);

-- Tabla historial_costos_poliza
CREATE TABLE IF NOT EXISTS historial_costos_poliza (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  poliza_id uuid NOT NULL REFERENCES polizas(id) ON DELETE CASCADE,
  prima_anual_old numeric(14,2) NULL,
  prima_anual_new numeric(14,2) NULL,
  porcentaje_comision_old numeric(10,4) NULL,
  porcentaje_comision_new numeric(10,4) NULL,
  actor_id uuid NULL,
  creado_at timestamptz NOT NULL DEFAULT now()
);

-- RLS inicial (habilitar, polÃ­ticas se aÃ±aden en sprints siguientes)
ALTER TABLE producto_parametros ENABLE ROW LEVEL SECURITY;
ALTER TABLE udi_values ENABLE ROW LEVEL SECURITY;
ALTER TABLE fx_values ENABLE ROW LEVEL SECURITY;
ALTER TABLE dias_mes ENABLE ROW LEVEL SECURITY;
ALTER TABLE clientes ENABLE ROW LEVEL SECURITY;
ALTER TABLE polizas ENABLE ROW LEVEL SECURITY;
ALTER TABLE poliza_puntos_cache ENABLE ROW LEVEL SECURITY;
ALTER TABLE cliente_historial ENABLE ROW LEVEL SECURITY;
ALTER TABLE cliente_update_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE historial_costos_poliza ENABLE ROW LEVEL SECURITY;

-- Fin Sprint 1


-- FILE: 20250908_fase3_sprint2_fx_udi_normalize.sql
-- Fase 3 â€“ Sprint 2: Monedas y normalizaciÃ³n de primas/SA
-- Fecha: 2025-09-08
-- Objetivo: funciones de UDI/FX, normalizaciÃ³n a MXN y triggers en polizas

-- FunciÃ³n: obtener UDI vigente (<= fecha)
CREATE OR REPLACE FUNCTION get_current_udi(p_fecha date)
RETURNS numeric
AS $$
  SELECT valor
  FROM udi_values
  WHERE fecha <= COALESCE(p_fecha, CURRENT_DATE)
  ORDER BY fecha DESC
  LIMIT 1
$$ LANGUAGE sql STABLE;

-- FunciÃ³n: obtener FX USD/MXN vigente (<= fecha)
CREATE OR REPLACE FUNCTION get_fx_usd(p_fecha date)
RETURNS numeric
AS $$
  SELECT valor
  FROM fx_values
  WHERE fecha <= COALESCE(p_fecha, CURRENT_DATE)
  ORDER BY fecha DESC
  LIMIT 1
$$ LANGUAGE sql STABLE;

-- Normaliza un monto a MXN segÃºn moneda y fecha (usa fecha_emision por defecto)
CREATE OR REPLACE FUNCTION normalize_prima(p_monto numeric, p_moneda moneda_poliza, p_fecha date)
RETURNS numeric
AS $$
DECLARE
  v numeric;
BEGIN
  IF p_monto IS NULL OR p_moneda IS NULL THEN
    RETURN NULL;
  END IF;

  IF p_moneda = 'MXN'::moneda_poliza THEN
    RETURN round(p_monto, 2);
  ELSIF p_moneda = 'USD'::moneda_poliza THEN
    SELECT get_fx_usd(COALESCE(p_fecha, CURRENT_DATE)) INTO v;
    IF v IS NULL THEN
      RAISE EXCEPTION 'No FX (USD/MXN) found for % or earlier', p_fecha;
    END IF;
    RETURN round(p_monto * v, 2);
  ELSIF p_moneda = 'UDI'::moneda_poliza THEN
    SELECT get_current_udi(COALESCE(p_fecha, CURRENT_DATE)) INTO v;
    IF v IS NULL THEN
      RAISE EXCEPTION 'No UDI value found for % or earlier', p_fecha;
    END IF;
    RETURN round(p_monto * v, 2);
  ELSE
    -- Por si se agrega moneda futura; devolvemos monto sin cambio
    RETURN round(p_monto, 2);
  END IF;
END;
$$ LANGUAGE plpgsql STABLE;

-- Trigger function: normaliza importes en polizas
CREATE OR REPLACE FUNCTION polizas_normalize_amounts()
RETURNS trigger
AS $$
BEGIN
  NEW.prima_mxn := normalize_prima(NEW.prima_input, NEW.prima_moneda, NEW.fecha_emision);

  IF NEW.sa_input IS NOT NULL AND NEW.sa_moneda IS NOT NULL THEN
    NEW.sa_mxn := normalize_prima(NEW.sa_input, NEW.sa_moneda, NEW.fecha_emision);
  ELSE
    NEW.sa_mxn := NULL;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Crear/actualizar trigger en polizas
DROP TRIGGER IF EXISTS trg_polizas_normalize_amounts ON polizas;
CREATE TRIGGER trg_polizas_normalize_amounts
BEFORE INSERT OR UPDATE OF prima_input, prima_moneda, sa_input, sa_moneda, fecha_emision
ON polizas
FOR EACH ROW EXECUTE FUNCTION polizas_normalize_amounts();

-- Seeds mÃ­nimos (idempotentes) para permitir pruebas
INSERT INTO udi_values(fecha, valor, source, fetched_at, stale)
SELECT d, 7.500000::numeric, 'seed', now(), false
FROM (SELECT CURRENT_DATE::date AS d) s
ON CONFLICT (fecha) DO NOTHING;

INSERT INTO fx_values(fecha, valor, source, fetched_at, stale)
SELECT d, 17.000000::numeric, 'seed', now(), false
FROM (SELECT CURRENT_DATE::date AS d) s
ON CONFLICT (fecha) DO NOTHING;


-- FILE: 20250908_fase3_sprint3_puntos_cache.sql
-- Fase 3 â€“ Sprint 3: Puntos y cachÃ©
-- Fecha: 2025-09-08
-- Objetivo: cÃ¡lculo de puntos (VI/GMM) por rangos, snapshot en cache y denormalizaciÃ³n en polizas

-- FunciÃ³n auxiliar: obtener aÃ±o de vigencia (mÃ­n 1)
CREATE OR REPLACE FUNCTION poliza_year_vigencia(p_fecha_emision date)
RETURNS int
AS $$
BEGIN
  RETURN GREATEST(
    1,
    (EXTRACT(YEAR FROM age(CURRENT_DATE, p_fecha_emision))::int + 1)
  );
END;
$$ LANGUAGE plpgsql STABLE;

-- FunciÃ³n principal: recÃ¡lculo de puntos por poliza
CREATE OR REPLACE FUNCTION recalc_puntos_poliza(p_poliza_id uuid)
RETURNS void
AS $$
DECLARE
  v_prima_mxn numeric;
  v_tipo tipo_producto;
  v_estatus estatus_poliza;
  v_pp_id uuid;
  v_year int;
  v_base_factor numeric;
  v_puntos numeric;
  v_clas tipo_clasificacion_puntos;
  v_fx numeric;
  v_udi numeric;
BEGIN
  -- Datos base de la pÃ³liza
  SELECT p.prima_mxn, p.estatus, p.producto_parametro_id
    INTO v_prima_mxn, v_estatus, v_pp_id
  FROM polizas p
  WHERE p.id = p_poliza_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'poliza % no existe', p_poliza_id;
  END IF;

  -- Si anulada, deja en cero
  IF v_estatus = 'ANULADA'::estatus_poliza THEN
    v_puntos := 0;
    v_clas := 'CERO';
  ELSE
    -- Tipo de producto
    IF v_pp_id IS NOT NULL THEN
      SELECT tipo_producto INTO v_tipo FROM producto_parametros WHERE id = v_pp_id;
    ELSE
      -- Si no hay producto asignado, no podemos clasificar
      v_tipo := NULL;
    END IF;

    -- ClasificaciÃ³n por rangos en MXN
    IF v_tipo = 'GMM'::tipo_producto THEN
      IF v_prima_mxn IS NOT NULL AND v_prima_mxn >= 7500 THEN
        v_puntos := 0.5; v_clas := 'MEDIO';
      ELSE
        v_puntos := 0; v_clas := 'CERO';
      END IF;
    ELSIF v_tipo = 'VI'::tipo_producto THEN
      IF v_prima_mxn IS NULL OR v_prima_mxn < 15000 THEN
        v_puntos := 0; v_clas := 'CERO';
      ELSIF v_prima_mxn >= 150000 THEN
        v_puntos := 3; v_clas := 'TRIPLE';
      ELSIF v_prima_mxn >= 50000 THEN
        v_puntos := 2; v_clas := 'DOBLE';
      ELSE
        v_puntos := 1; v_clas := 'SIMPLE';
      END IF;
    ELSE
      -- Tipo desconocido o sin producto: no clasificar
      v_puntos := NULL; v_clas := NULL;
    END IF;
  END IF;

  -- AÃ±o de vigencia
  SELECT poliza_year_vigencia(p.fecha_emision) INTO v_year
  FROM polizas p WHERE p.id = p_poliza_id;

  -- Base factor (porcentaje anual) desde producto_parametros (si existe)
  IF v_pp_id IS NOT NULL THEN
    SELECT CASE
             WHEN v_year = 1 THEN anio_1_percent
             WHEN v_year = 2 THEN anio_2_percent
             WHEN v_year = 3 THEN anio_3_percent
             WHEN v_year = 4 THEN anio_4_percent
             WHEN v_year = 5 THEN anio_5_percent
             WHEN v_year = 6 THEN anio_6_percent
             WHEN v_year = 7 THEN anio_7_percent
             WHEN v_year = 8 THEN anio_8_percent
             WHEN v_year = 9 THEN anio_9_percent
             WHEN v_year = 10 THEN anio_10_percent
             ELSE anio_11_plus_percent
           END
      INTO v_base_factor
    FROM producto_parametros
    WHERE id = v_pp_id;
  ELSE
    v_base_factor := NULL;
  END IF;

  -- Tasas (para auditorÃ­a) si la prima no es MXN
  v_fx := NULL; v_udi := NULL;
  PERFORM 1;

  -- UPSERT en cache
  INSERT INTO poliza_puntos_cache (
    poliza_id, puntos_total, clasificacion, base_factor, producto_factor,
    year_factor, prima_anual_snapshot, producto_parametro_id, udi_valor, usd_fx,
    breakdown, recalculo_reason, computed_at, updated_at
  )
  SELECT p.id, v_puntos, v_clas, v_base_factor, NULL,
         v_year, v_prima_mxn, v_pp_id, v_udi, v_fx,
         jsonb_build_object(
           'year', v_year,
           'factor_base', v_base_factor,
           'producto', v_tipo,
           'prima_mxn', v_prima_mxn
         ),
         'recalc', now(), now()
  FROM polizas p WHERE p.id = p_poliza_id
  ON CONFLICT (poliza_id) DO UPDATE SET
    puntos_total = EXCLUDED.puntos_total,
    clasificacion = EXCLUDED.clasificacion,
    base_factor = EXCLUDED.base_factor,
    producto_factor = EXCLUDED.producto_factor,
    year_factor = EXCLUDED.year_factor,
    prima_anual_snapshot = EXCLUDED.prima_anual_snapshot,
    producto_parametro_id = EXCLUDED.producto_parametro_id,
    udi_valor = EXCLUDED.udi_valor,
    usd_fx = EXCLUDED.usd_fx,
    breakdown = EXCLUDED.breakdown,
    recalculo_reason = EXCLUDED.recalculo_reason,
    updated_at = now();

  -- Denormaliza en polizas
  UPDATE polizas
  SET clasificacion_actual = v_clas,
      puntos_actuales = v_puntos,
      updated_at = now()
  WHERE id = p_poliza_id;
END;
$$ LANGUAGE plpgsql;

-- Triggers AFTER para recalcular al cambiar datos relevantes
CREATE OR REPLACE FUNCTION polizas_after_change_recalc()
RETURNS trigger
AS $$
BEGIN
  PERFORM recalc_puntos_poliza(NEW.id);
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_polizas_after_insert_recalc ON polizas;
CREATE TRIGGER trg_polizas_after_insert_recalc
AFTER INSERT ON polizas
FOR EACH ROW EXECUTE FUNCTION polizas_after_change_recalc();

DROP TRIGGER IF EXISTS trg_polizas_after_update_recalc ON polizas;
CREATE TRIGGER trg_polizas_after_update_recalc
AFTER UPDATE OF prima_input, prima_moneda, estatus, producto_parametro_id ON polizas
FOR EACH ROW EXECUTE FUNCTION polizas_after_change_recalc();


-- FILE: 20250908_fase3_sprint4_aprobacion_clientes.sql
-- Fase 3 â€“ Sprint 4: Flujo de aprobaciÃ³n de cambios a cliente
-- Fecha: 2025-09-08
-- Objetivo: funciones submit/apply/reject y polÃ­ticas RLS mÃ­nimas

-- Helpers para roles desde JWT
CREATE OR REPLACE FUNCTION jwt_role()
RETURNS text
AS $$
BEGIN
  RETURN COALESCE((current_setting('request.jwt.claims', true)::jsonb)->>'role', '');
END;
$$ LANGUAGE plpgsql STABLE;

CREATE OR REPLACE FUNCTION is_super_role()
RETURNS boolean
AS $$
BEGIN
  RETURN jwt_role() IN ('supervisor','admin');
END;
$$ LANGUAGE plpgsql STABLE;

-- Submit de solicitud de cambio (asesor)
CREATE OR REPLACE FUNCTION submit_cliente_update(p_cliente_id uuid, p_payload jsonb)
RETURNS uuid
AS $$
DECLARE
  v_id uuid;
BEGIN
  IF p_payload IS NULL OR jsonb_typeof(p_payload) <> 'object' THEN
    RAISE EXCEPTION 'payload invÃ¡lido';
  END IF;

  INSERT INTO cliente_update_requests (
    id, cliente_id, solicitante_id, payload_propuesto, estado, creado_at
  ) VALUES (
    gen_random_uuid(), p_cliente_id, auth.uid(), p_payload, 'PENDIENTE', now()
  ) RETURNING id INTO v_id;

  RETURN v_id;
END;
$$ LANGUAGE plpgsql;

-- Aplicar aprobaciÃ³n (supervisor)
CREATE OR REPLACE FUNCTION apply_cliente_update(p_request_id uuid)
RETURNS void
AS $$
DECLARE
  v_cliente_id uuid;
  v_payload jsonb;
  r_old clientes%ROWTYPE;
  r_new clientes%ROWTYPE;
BEGIN
  IF NOT is_super_role() THEN
    RAISE EXCEPTION 'permiso denegado (se requiere supervisor)';
  END IF;

  SELECT cliente_id, payload_propuesto
    INTO v_cliente_id, v_payload
  FROM cliente_update_requests
  WHERE id = p_request_id AND estado = 'PENDIENTE'
  FOR UPDATE;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'solicitud no encontrada o no pendiente';
  END IF;

  SELECT * INTO r_old FROM clientes WHERE id = v_cliente_id FOR UPDATE;

  -- Actualiza campos permitidos (usa COALESCE para mantener si no viene en payload)
  UPDATE clientes SET
    primer_nombre      = COALESCE(UPPER(TRIM(v_payload->>'primer_nombre')), primer_nombre),
    segundo_nombre     = COALESCE(UPPER(TRIM(v_payload->>'segundo_nombre')), segundo_nombre),
    primer_apellido    = COALESCE(UPPER(TRIM(v_payload->>'primer_apellido')), primer_apellido),
    segundo_apellido   = COALESCE(UPPER(TRIM(v_payload->>'segundo_apellido')), segundo_apellido),
    telefono_celular   = COALESCE(TRIM(v_payload->>'telefono_celular'), telefono_celular),
    correo             = COALESCE(LOWER(TRIM(v_payload->>'correo')), correo),
    full_name_normalizado = UPPER(TRIM(
      COALESCE(v_payload->>'primer_nombre', primer_nombre) || ' ' ||
      COALESCE(v_payload->>'segundo_nombre', COALESCE(segundo_nombre,'')) || ' ' ||
      COALESCE(v_payload->>'primer_apellido', primer_apellido) || ' ' ||
      COALESCE(v_payload->>'segundo_apellido', segundo_apellido)
    )),
    updated_at = now()
  WHERE id = v_cliente_id;

  SELECT * INTO r_new FROM clientes WHERE id = v_cliente_id;

  INSERT INTO cliente_historial (
    id, cliente_id, cambio_tipo, payload_old, payload_new, actor_id, creado_at
  ) VALUES (
    gen_random_uuid(), v_cliente_id, 'APROBACION', to_jsonb(r_old), to_jsonb(r_new), auth.uid(), now()
  );

  UPDATE cliente_update_requests
  SET estado = 'APROBADA', resuelto_at = now(), resuelto_por = auth.uid()
  WHERE id = p_request_id;
END;
$$ LANGUAGE plpgsql;

-- Rechazar solicitud (supervisor)
CREATE OR REPLACE FUNCTION reject_cliente_update(p_request_id uuid, p_motivo text)
RETURNS void
AS $$
BEGIN
  IF NOT is_super_role() THEN
    RAISE EXCEPTION 'permiso denegado (se requiere supervisor)';
  END IF;

  UPDATE cliente_update_requests
  SET estado = 'RECHAZADA', motivo_rechazo = COALESCE(p_motivo,'') , resuelto_at = now(), resuelto_por = auth.uid()
  WHERE id = p_request_id AND estado = 'PENDIENTE';

  IF NOT FOUND THEN
    RAISE EXCEPTION 'solicitud no encontrada o no pendiente';
  END IF;
END;
$$ LANGUAGE plpgsql;

-- PolÃ­ticas RLS mÃ­nimas
-- clientes: SELECT por asesor o super; UPDATE sÃ³lo super
DROP POLICY IF EXISTS sel_clientes ON clientes;
CREATE POLICY sel_clientes ON clientes
  FOR SELECT TO authenticated
  USING (asesor_id = auth.uid() OR is_super_role());

DROP POLICY IF EXISTS upd_clientes_super ON clientes;
CREATE POLICY upd_clientes_super ON clientes
  FOR UPDATE TO authenticated
  USING (is_super_role())
  WITH CHECK (is_super_role());

-- cliente_update_requests: INSERT por solicitante; SELECT por solicitante o super
DROP POLICY IF EXISTS ins_cliente_update_requests ON cliente_update_requests;
CREATE POLICY ins_cliente_update_requests ON cliente_update_requests
  FOR INSERT TO authenticated
  WITH CHECK (solicitante_id = auth.uid());

DROP POLICY IF EXISTS sel_cliente_update_requests ON cliente_update_requests;
CREATE POLICY sel_cliente_update_requests ON cliente_update_requests
  FOR SELECT TO authenticated
  USING (solicitante_id = auth.uid() OR is_super_role());

-- cliente_historial: SELECT sÃ³lo super
DROP POLICY IF EXISTS sel_cliente_historial ON cliente_historial;
CREATE POLICY sel_cliente_historial ON cliente_historial
  FOR SELECT TO authenticated
  USING (is_super_role());


-- FILE: 20250909_fase3_sprint2_rls_policies.sql
-- Fecha: 2025-09-09
-- Objetivo: Permitir lectura a usuarios autenticados y escritura sÃ³lo a roles superiores

-- PolÃ­ticas udi_values
DROP POLICY IF EXISTS sel_udi_values ON udi_values;
CREATE POLICY sel_udi_values ON udi_values
  FOR SELECT TO authenticated
  USING (true);

DROP POLICY IF EXISTS ins_udi_values_super ON udi_values;
CREATE POLICY ins_udi_values_super ON udi_values
  FOR INSERT TO authenticated
  WITH CHECK (is_super_role());

DROP POLICY IF EXISTS upd_udi_values_super ON udi_values;
CREATE POLICY upd_udi_values_super ON udi_values
  FOR UPDATE TO authenticated
  USING (is_super_role())
  WITH CHECK (is_super_role());

DROP POLICY IF EXISTS del_udi_values_super ON udi_values;
CREATE POLICY del_udi_values_super ON udi_values
  FOR DELETE TO authenticated
  USING (is_super_role());

-- PolÃ­ticas fx_values
DROP POLICY IF EXISTS sel_fx_values ON fx_values;
CREATE POLICY sel_fx_values ON fx_values
  FOR SELECT TO authenticated
  USING (true);

DROP POLICY IF EXISTS ins_fx_values_super ON fx_values;
CREATE POLICY ins_fx_values_super ON fx_values
  FOR INSERT TO authenticated
  WITH CHECK (is_super_role());

DROP POLICY IF EXISTS upd_fx_values_super ON fx_values;
CREATE POLICY upd_fx_values_super ON fx_values
  FOR UPDATE TO authenticated
  USING (is_super_role())
  WITH CHECK (is_super_role());

DROP POLICY IF EXISTS del_fx_values_super ON fx_values;
CREATE POLICY del_fx_values_super ON fx_values
  FOR DELETE TO authenticated
  USING (is_super_role());


-- FILE: 20250910_cliente_updates_apply_rls.sql
-- Fecha: 2025-09-10
-- Objetivo: Permitir que la funciÃ³n apply_cliente_update pueda actualizar cliente_update_requests e insertar en cliente_historial bajo RLS

-- UPDATE en cliente_update_requests solo para roles superiores
DROP POLICY IF EXISTS upd_cliente_update_requests_super ON cliente_update_requests;
CREATE POLICY upd_cliente_update_requests_super ON cliente_update_requests
  FOR UPDATE TO authenticated
  USING (is_super_role())
  WITH CHECK (is_super_role());

-- INSERT en cliente_historial solo para roles superiores
DROP POLICY IF EXISTS ins_cliente_historial_super ON cliente_historial;
CREATE POLICY ins_cliente_historial_super ON cliente_historial
  FOR INSERT TO authenticated
  WITH CHECK (is_super_role());


-- FILE: 20250910_clientes_insert_policy.sql
-- Fecha: 2025-09-10
-- Objetivo: Permitir INSERT en clientes para usuarios autenticados, limitado a su propio asesor_id, o libre para super roles

-- PolÃ­tica de INSERT para clientes
DROP POLICY IF EXISTS ins_clientes_asesor ON clientes;
CREATE POLICY ins_clientes_asesor ON clientes
  FOR INSERT TO authenticated
  WITH CHECK (asesor_id = auth.uid() OR is_super_role());


-- FILE: 20250910_fase3_sprint3_puntos_cache_v2.sql
-- Fase 3 â€“ Sprint 3: Puntos y cachÃ© (complemento)
-- Fecha: 2025-09-10
-- Objetivo: completar piezas faltantes
--  - Guardar tasas aplicadas (UDI/FX) en cache
--  - Disparar recÃ¡lculo tambiÃ©n al cambiar SA
--  - SelecciÃ³n automÃ¡tica de variante de producto si producto_parametro_id es NULL
--  - FunciÃ³n de recÃ¡lculo masivo

-- 1) ActualizaciÃ³n de la funciÃ³n recalc_puntos_poliza: llenar udi_valor/usd_fx y auto-selecciÃ³n de producto
CREATE OR REPLACE FUNCTION recalc_puntos_poliza(p_poliza_id uuid)
RETURNS void
AS $$
DECLARE
  v_prima_mxn numeric;
  v_prima_moneda moneda_poliza;
  v_sa_mxn numeric;
  v_sa_input numeric;
  v_sa_moneda moneda_poliza;
  v_tipo tipo_producto;
  v_estatus estatus_poliza;
  v_pp_id uuid;
  v_year int;
  v_base_factor numeric;
  v_puntos numeric;
  v_clas tipo_clasificacion_puntos;
  v_fx numeric;
  v_udi numeric;
  v_fecha date;
  v_pp_auto uuid;
BEGIN
  -- Datos base de la pÃ³liza
  SELECT p.prima_mxn, p.prima_moneda, p.sa_mxn, p.sa_input, p.sa_moneda,
         p.estatus, p.producto_parametro_id, p.fecha_emision
    INTO v_prima_mxn, v_prima_moneda, v_sa_mxn, v_sa_input, v_sa_moneda,
         v_estatus, v_pp_id, v_fecha
  FROM polizas p
  WHERE p.id = p_poliza_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'poliza % no existe', p_poliza_id;
  END IF;

  -- Tasas aplicadas para auditorÃ­a
  v_fx := NULL; v_udi := NULL;
  IF v_prima_moneda = 'USD'::moneda_poliza THEN
    SELECT get_fx_usd(v_fecha) INTO v_fx;
  ELSIF v_prima_moneda = 'UDI'::moneda_poliza THEN
    SELECT get_current_udi(v_fecha) INTO v_udi;
  END IF;

  -- Auto-selecciÃ³n de variante si no viene asignada
  -- Estrategia: buscar variante activa cuyo pp.moneda sea NULL o igual a la prima_moneda,
  -- y cuyo rango SA (si existe) incluya la SA en MXN. Orden: preferir coincidencia exacta de moneda,
  -- luego mayor sa_min (mÃ¡s especÃ­fica). Si hay empate o no se encuentra, se deja NULL.
  IF v_pp_id IS NULL THEN
    SELECT pp.id
      INTO v_pp_auto
    FROM producto_parametros pp
    WHERE pp.activo = true
      AND (pp.moneda IS NULL OR pp.moneda = v_prima_moneda)
      AND (
        v_sa_mxn IS NULL
        OR (
          (pp.sa_min IS NULL OR v_sa_mxn >= pp.sa_min)
          AND (pp.sa_max IS NULL OR v_sa_mxn <= pp.sa_max)
        )
      )
    ORDER BY 
      CASE WHEN pp.moneda = v_prima_moneda THEN 0 ELSE 1 END,
      COALESCE(pp.sa_min, (-1)::numeric) DESC
    LIMIT 1;

    IF v_pp_auto IS NOT NULL THEN
      v_pp_id := v_pp_auto;
      -- Persistir selecciÃ³n para futuras evaluaciones
      UPDATE polizas SET producto_parametro_id = v_pp_auto, updated_at = now()
      WHERE id = p_poliza_id;
    END IF;
  END IF;

  -- Si anulada, deja en cero
  IF v_estatus = 'ANULADA'::estatus_poliza THEN
    v_puntos := 0;
    v_clas := 'CERO';
  ELSE
    -- Tipo de producto
    IF v_pp_id IS NOT NULL THEN
      SELECT tipo_producto INTO v_tipo FROM producto_parametros WHERE id = v_pp_id;
    ELSE
      v_tipo := NULL;
    END IF;

    -- ClasificaciÃ³n por rangos en MXN
    IF v_tipo = 'GMM'::tipo_producto THEN
      IF v_prima_mxn IS NOT NULL AND v_prima_mxn >= 7500 THEN
        v_puntos := 0.5; v_clas := 'MEDIO';
      ELSE
        v_puntos := 0; v_clas := 'CERO';
      END IF;
    ELSIF v_tipo = 'VI'::tipo_producto THEN
      IF v_prima_mxn IS NULL OR v_prima_mxn < 15000 THEN
        v_puntos := 0; v_clas := 'CERO';
      ELSIF v_prima_mxn >= 150000 THEN
        v_puntos := 3; v_clas := 'TRIPLE';
      ELSIF v_prima_mxn >= 50000 THEN
        v_puntos := 2; v_clas := 'DOBLE';
      ELSE
        v_puntos := 1; v_clas := 'SIMPLE';
      END IF;
    ELSE
      -- Tipo desconocido o sin producto: no clasificar
      v_puntos := NULL; v_clas := NULL;
    END IF;
  END IF;

  -- AÃ±o de vigencia
  SELECT poliza_year_vigencia(p.fecha_emision) INTO v_year
  FROM polizas p WHERE p.id = p_poliza_id;

  -- Base factor (porcentaje anual) desde producto_parametros (si existe)
  IF v_pp_id IS NOT NULL THEN
    SELECT CASE
             WHEN v_year = 1 THEN anio_1_percent
             WHEN v_year = 2 THEN anio_2_percent
             WHEN v_year = 3 THEN anio_3_percent
             WHEN v_year = 4 THEN anio_4_percent
             WHEN v_year = 5 THEN anio_5_percent
             WHEN v_year = 6 THEN anio_6_percent
             WHEN v_year = 7 THEN anio_7_percent
             WHEN v_year = 8 THEN anio_8_percent
             WHEN v_year = 9 THEN anio_9_percent
             WHEN v_year = 10 THEN anio_10_percent
             ELSE anio_11_plus_percent
           END
      INTO v_base_factor
    FROM producto_parametros
    WHERE id = v_pp_id;
  ELSE
    v_base_factor := NULL;
  END IF;

  -- UPSERT en cache con tasas aplicadas
  INSERT INTO poliza_puntos_cache (
    poliza_id, puntos_total, clasificacion, base_factor, producto_factor,
    year_factor, prima_anual_snapshot, producto_parametro_id, udi_valor, usd_fx,
    breakdown, recalculo_reason, computed_at, updated_at
  )
  SELECT p.id, v_puntos, v_clas, v_base_factor, NULL,
         v_year, v_prima_mxn, v_pp_id, v_udi, v_fx,
         jsonb_build_object(
           'year', v_year,
           'factor_base', v_base_factor,
           'producto', v_tipo,
           'prima_mxn', v_prima_mxn,
           'sa_mxn', v_sa_mxn,
           'prima_moneda', v_prima_moneda,
           'fx_aplicado', v_fx,
           'udi_aplicada', v_udi
         ),
         'recalc', now(), now()
  FROM polizas p WHERE p.id = p_poliza_id
  ON CONFLICT (poliza_id) DO UPDATE SET
    puntos_total = EXCLUDED.puntos_total,
    clasificacion = EXCLUDED.clasificacion,
    base_factor = EXCLUDED.base_factor,
    producto_factor = EXCLUDED.producto_factor,
    year_factor = EXCLUDED.year_factor,
    prima_anual_snapshot = EXCLUDED.prima_anual_snapshot,
    producto_parametro_id = EXCLUDED.producto_parametro_id,
    udi_valor = EXCLUDED.udi_valor,
    usd_fx = EXCLUDED.usd_fx,
    breakdown = EXCLUDED.breakdown,
    recalculo_reason = EXCLUDED.recalculo_reason,
    updated_at = now();

  -- Denormaliza en polizas
  UPDATE polizas
  SET clasificacion_actual = v_clas,
      puntos_actuales = v_puntos,
      updated_at = now()
  WHERE id = p_poliza_id;
END;
$$ LANGUAGE plpgsql;

-- 2) Disparar recÃ¡lculo tambiÃ©n al cambiar SA y fecha_emision (impacta year y normalizaciÃ³n)
DROP TRIGGER IF EXISTS trg_polizas_after_update_recalc ON polizas;
CREATE TRIGGER trg_polizas_after_update_recalc
AFTER UPDATE OF prima_input, prima_moneda, sa_input, sa_moneda, fecha_emision, estatus, producto_parametro_id ON polizas
FOR EACH ROW EXECUTE FUNCTION polizas_after_change_recalc();

-- 3) FunciÃ³n de recÃ¡lculo masivo
CREATE OR REPLACE FUNCTION recalc_puntos_poliza_all(p_limit int DEFAULT NULL)
RETURNS int
AS $$
DECLARE
  v_count int := 0;
  r RECORD;
BEGIN
  FOR r IN 
    SELECT id FROM polizas
    ORDER BY updated_at DESC
    LIMIT COALESCE(p_limit, 2147483647)
  LOOP
    PERFORM recalc_puntos_poliza(r.id);
    v_count := v_count + 1;
  END LOOP;
  RETURN v_count;
END;
$$ LANGUAGE plpgsql;


-- FILE: 20250910_fase3_sprint4_aprobacion_polizas.sql
-- Fase 3 â€“ Sprint 4: Flujo de aprobaciÃ³n de cambios de pÃ³liza
-- Fecha: 2025-09-10

-- Tabla de solicitudes de cambio de pÃ³liza
CREATE TABLE IF NOT EXISTS poliza_update_requests (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  poliza_id uuid NOT NULL REFERENCES polizas(id) ON DELETE CASCADE,
  solicitante_id uuid NOT NULL,
  payload_propuesto jsonb NOT NULL,
  estado text NOT NULL DEFAULT 'PENDIENTE',
  motivo_rechazo text NULL,
  creado_at timestamptz NOT NULL DEFAULT now(),
  resuelto_at timestamptz NULL,
  resuelto_por uuid NULL
);

-- sql-lint-disable-next-line
ALTER TABLE poliza_update_requests ENABLE ROW LEVEL SECURITY;

-- Helpers de rol (idempotentes)
CREATE OR REPLACE FUNCTION jwt_role()
RETURNS text
AS $$
BEGIN
  RETURN COALESCE((current_setting('request.jwt.claims', true)::jsonb)->>'role', '');
END;
$$ LANGUAGE plpgsql STABLE;

CREATE OR REPLACE FUNCTION is_super_role()
RETURNS boolean
AS $$
BEGIN
  RETURN jwt_role() IN ('supervisor','admin');
END;
$$ LANGUAGE plpgsql STABLE;

-- Submit/update/reject funciones
CREATE OR REPLACE FUNCTION submit_poliza_update(p_poliza_id uuid, p_payload jsonb)
RETURNS uuid
AS $$
DECLARE
  v_id uuid;
BEGIN
  IF p_payload IS NULL OR jsonb_typeof(p_payload) <> 'object' THEN
    RAISE EXCEPTION 'payload invÃ¡lido';
  END IF;

  INSERT INTO poliza_update_requests (
    id, poliza_id, solicitante_id, payload_propuesto, estado, creado_at
  ) VALUES (
    gen_random_uuid(), p_poliza_id, auth.uid(), p_payload, 'PENDIENTE', now()
  ) RETURNING id INTO v_id;

  RETURN v_id;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION apply_poliza_update(p_request_id uuid)
RETURNS void
AS $$
DECLARE
  v_poliza_id uuid;
  v_payload jsonb;
  r_old polizas%ROWTYPE;
  r_new polizas%ROWTYPE;
  v_old_prima numeric(14,2);
  v_new_prima numeric(14,2);
BEGIN
  IF NOT is_super_role() THEN
    RAISE EXCEPTION 'permiso denegado (se requiere supervisor)';
  END IF;

  SELECT poliza_id, payload_propuesto
    INTO v_poliza_id, v_payload
  FROM poliza_update_requests
  WHERE id = p_request_id AND estado = 'PENDIENTE'
  FOR UPDATE;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'solicitud no encontrada o no pendiente';
  END IF;

  SELECT * INTO r_old FROM polizas WHERE id = v_poliza_id FOR UPDATE;

  -- Actualiza sÃ³lo campos permitidos
  UPDATE polizas SET
    numero_poliza        = COALESCE(NULLIF(TRIM(v_payload->>'numero_poliza'),''), numero_poliza),
    estatus              = COALESCE((v_payload->>'estatus')::estatus_poliza, estatus),
    fecha_emision        = COALESCE((v_payload->>'fecha_emision')::date, fecha_emision),
    forma_pago           = COALESCE((v_payload->>'forma_pago')::forma_pago, forma_pago),
    prima_input          = COALESCE((v_payload->>'prima_input')::numeric, prima_input),
    prima_moneda         = COALESCE((v_payload->>'prima_moneda')::moneda_poliza, prima_moneda),
    sa_input             = COALESCE((v_payload->>'sa_input')::numeric, sa_input),
    sa_moneda            = COALESCE((v_payload->>'sa_moneda')::moneda_poliza, sa_moneda),
    producto_parametro_id= COALESCE((v_payload->>'producto_parametro_id')::uuid, producto_parametro_id),
    updated_at           = now()
  WHERE id = v_poliza_id;

  SELECT * INTO r_new FROM polizas WHERE id = v_poliza_id;

  -- Historial de costos si cambiÃ³ prima_input
  v_old_prima := r_old.prima_input;
  v_new_prima := r_new.prima_input;
  IF v_old_prima IS DISTINCT FROM v_new_prima THEN
    INSERT INTO historial_costos_poliza (
      id, poliza_id, prima_anual_old, prima_anual_new, porcentaje_comision_old, porcentaje_comision_new, actor_id, creado_at
    ) VALUES (
      gen_random_uuid(), v_poliza_id, v_old_prima, v_new_prima, NULL, NULL, auth.uid(), now()
    );
  END IF;

  -- Marcar solicitud como aprobada
  UPDATE poliza_update_requests
  SET estado = 'APROBADA', resuelto_at = now(), resuelto_por = auth.uid()
  WHERE id = p_request_id;

  -- Recalcular puntos (en caso de que trigger no dispare por algÃºn motivo)
  PERFORM recalc_puntos_poliza(v_poliza_id);
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION reject_poliza_update(p_request_id uuid, p_motivo text)
RETURNS void
AS $$
BEGIN
  IF NOT is_super_role() THEN
    RAISE EXCEPTION 'permiso denegado (se requiere supervisor)';
  END IF;

  UPDATE poliza_update_requests
  SET estado = 'RECHAZADA', motivo_rechazo = COALESCE(p_motivo,''), resuelto_at = now(), resuelto_por = auth.uid()
  WHERE id = p_request_id AND estado = 'PENDIENTE';

  IF NOT FOUND THEN
    RAISE EXCEPTION 'solicitud no encontrada o no pendiente';
  END IF;
END;
$$ LANGUAGE plpgsql;

-- PolÃ­ticas RLS
-- polizas SELECT por asesor del cliente dueÃ±o o super; UPDATE sÃ³lo super
DROP POLICY IF EXISTS sel_polizas ON polizas;
CREATE POLICY sel_polizas ON polizas
  FOR SELECT TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM clientes c
      WHERE c.id = polizas.cliente_id
        AND (c.asesor_id = auth.uid() OR is_super_role())
    )
  );

DROP POLICY IF EXISTS upd_polizas_super ON polizas;
CREATE POLICY upd_polizas_super ON polizas
  FOR UPDATE TO authenticated
  USING (is_super_role())
  WITH CHECK (is_super_role());

-- poliza_update_requests: INSERT por solicitante; SELECT por solicitante o super
DROP POLICY IF EXISTS ins_poliza_update_requests ON poliza_update_requests;
CREATE POLICY ins_poliza_update_requests ON poliza_update_requests
  FOR INSERT TO authenticated
  WITH CHECK (solicitante_id = auth.uid());

DROP POLICY IF EXISTS sel_poliza_update_requests ON poliza_update_requests;
CREATE POLICY sel_poliza_update_requests ON poliza_update_requests
  FOR SELECT TO authenticated
  USING (solicitante_id = auth.uid() OR is_super_role());

-- historial_costos_poliza: SELECT sÃ³lo super
DROP POLICY IF EXISTS sel_historial_costos_poliza ON historial_costos_poliza;
CREATE POLICY sel_historial_costos_poliza ON historial_costos_poliza
  FOR SELECT TO authenticated
  USING (is_super_role());


-- FILE: 20250910_fix_is_super_role.sql
-- Fecha: 2025-09-10
-- Objetivo: Alinear is_super_role() con el frontend y permitir 'supervisor' y 'admin'.
-- AdemÃ¡s, resolver casos donde el JWT no incluya 'role' usando lookup en tabla usuarios por auth.uid().

CREATE OR REPLACE FUNCTION is_super_role()
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_is_super boolean := false;
BEGIN
  -- 1) Verificar en tabla usuarios por id_auth (requiere que usuarios.id_auth estÃ© poblado)
  SELECT TRUE
    INTO v_is_super
  FROM usuarios
  WHERE id_auth = auth.uid()
    AND activo IS TRUE
    AND lower(rol) IN ('supervisor','admin')
  LIMIT 1;

  IF v_is_super THEN
    RETURN TRUE;
  END IF;

  -- 2) Fallback a claim del JWT si existe
  RETURN jwt_role() IN ('supervisor','admin');
END;
$$;


-- FILE: 20250911_add_fecha_nacimiento_to_clientes.sql
-- Add optional date of birth to clientes for Vista Asesor
ALTER TABLE clientes ADD COLUMN fecha_nacimiento date;


-- FILE: 20250911_add_last_login_to_usuarios.sql
-- NOTE: Some linters in this environment flag DO $$ blocks; apply this manually if needed:
-- alter table public.usuarios add column if not exists last_login timestamptz null;
-- comment on column public.usuarios.last_login is 'Ãšltima vez que el usuario iniciÃ³ sesiÃ³n (UTC).';


-- FILE: 20250911B_update_normalize_prima_lenient.sql
-- Migration: make normalize_prima lenient (no exception on missing FX/UDI) and fallback to earliest UDI
-- Date: 2025-09-11B
-- Safe approach: only replace normalize_prima; keep get_current_udi logic but wrap usage.

CREATE OR REPLACE FUNCTION normalize_prima(p_monto numeric, p_moneda moneda_poliza, p_fecha date)
RETURNS numeric
AS $$
DECLARE
  v numeric;
BEGIN
  IF p_monto IS NULL OR p_moneda IS NULL THEN
    RETURN NULL;
  END IF;

  IF p_moneda = 'MXN'::moneda_poliza THEN
    RETURN round(p_monto, 2);
  ELSIF p_moneda = 'USD'::moneda_poliza THEN
    BEGIN
      SELECT get_fx_usd(COALESCE(p_fecha, CURRENT_DATE)) INTO v;
    EXCEPTION WHEN OTHERS THEN
      v := NULL;
    END;
    IF v IS NULL THEN RETURN NULL; END IF;
    RETURN round(p_monto * v, 2);
  ELSIF p_moneda = 'UDI'::moneda_poliza THEN
    BEGIN
      SELECT get_current_udi(COALESCE(p_fecha, CURRENT_DATE)) INTO v;
    EXCEPTION WHEN OTHERS THEN
      v := NULL;
    END;
    IF v IS NULL THEN
      -- fallback: earliest available UDI
      SELECT valor INTO v FROM udi_values ORDER BY fecha ASC LIMIT 1;
    END IF;
    IF v IS NULL THEN RETURN NULL; END IF;
    RETURN round(p_monto * v, 2);
  ELSE
    RETURN round(p_monto, 2);
  END IF;
END;
$$ LANGUAGE plpgsql STABLE;


-- FILE: 20250911C_seed_udi_fx_fallback.sql
-- Replanteo: se requiere usar SIEMPRE el valor ACTUAL (mÃ¡s reciente) de UDI y FX y no fallar por fecha_emision histÃ³rica.
-- Implementamos una VIEW que expone las pÃ³lizas con primas/SA revaluadas al valor UDI/USD mÃ¡s reciente.

DROP VIEW IF EXISTS polizas_valores_actuales;
CREATE VIEW polizas_valores_actuales AS
WITH latest_udi AS (
  SELECT valor AS udi_valor FROM udi_values ORDER BY fecha DESC LIMIT 1
), latest_fx AS (
  SELECT valor AS usd_fx FROM fx_values ORDER BY fecha DESC LIMIT 1
)
SELECT p.*,
  CASE 
    WHEN p.prima_moneda = 'MXN' THEN p.prima_input
    WHEN p.prima_moneda = 'USD' THEN p.prima_input * (SELECT usd_fx FROM latest_fx)
    WHEN p.prima_moneda = 'UDI' THEN p.prima_input * (SELECT udi_valor FROM latest_udi)
    ELSE p.prima_input
  END AS prima_mxn_actual,
  CASE 
    WHEN p.sa_moneda = 'MXN' THEN p.sa_input
    WHEN p.sa_moneda = 'USD' THEN p.sa_input * (SELECT usd_fx FROM latest_fx)
    WHEN p.sa_moneda = 'UDI' THEN p.sa_input * (SELECT udi_valor FROM latest_udi)
    ELSE p.sa_input
  END AS sa_mxn_actual,
  (SELECT udi_valor FROM latest_udi) AS udi_valor_usado,
  (SELECT usd_fx FROM latest_fx) AS usd_fx_usado
FROM polizas p;

-- Nota: si no existen filas en udi_values o fx_values la vista devolverÃ¡ NULL en los campos *_actual.


-- FILE: 20250911D_update_fx_udi_fallback.sql
-- Migration: make FX / UDI lookup always fallback to valor ACTUAL (Ãºltimo disponible)
-- Fecha: 2025-09-11
-- Objetivo: eliminar error "No UDI value found for <fecha> or earlier" cuando no hay dato histÃ³rico
-- Estrategia: redefinir get_current_udi y get_fx_usd para usar primero valor <= fecha y si no existe, usar el mÃ¡s reciente.

CREATE OR REPLACE FUNCTION get_current_udi(p_fecha date)
RETURNS numeric
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
  v numeric;
BEGIN
  -- Intentar valor histÃ³rico (<= fecha)
  SELECT valor INTO v
  FROM udi_values
  WHERE fecha <= COALESCE(p_fecha, CURRENT_DATE)
  ORDER BY fecha DESC
  LIMIT 1;

  -- Fallback: valor mÃ¡s reciente disponible (actual)
  IF v IS NULL THEN
    SELECT valor INTO v FROM udi_values ORDER BY fecha DESC LIMIT 1;
  END IF;

  RETURN v; -- puede ser NULL si la tabla estÃ¡ vacÃ­a
END;
$$;

CREATE OR REPLACE FUNCTION get_fx_usd(p_fecha date)
RETURNS numeric
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
  v numeric;
BEGIN
  SELECT valor INTO v
  FROM fx_values
  WHERE fecha <= COALESCE(p_fecha, CURRENT_DATE)
  ORDER BY fecha DESC
  LIMIT 1;

  IF v IS NULL THEN
    SELECT valor INTO v FROM fx_values ORDER BY fecha DESC LIMIT 1;
  END IF;

  RETURN v;
END;
$$;

-- Nota: normalize_prima existente ahora heredarÃ¡ el fallback implÃ­cito y dejarÃ¡ de lanzar excepciÃ³n.
-- No recalculamos valores persistidos para conservar historial; la vista polizas_valores_actuales ya ofrece valores actuales.

-- FILE: 20250911E_polizas_extensiones.sql
-- Migration: Extend polizas with user-entered renewal, payment type/day and monthly check flags
-- Date: 2025-09-11
-- Adds:
--   fecha_renovacion (date)
--   tipo_pago (text)
--   dia_pago (smallint)
--   meses_check (jsonb) -> map YYYY-MM:boolean for months 2025-01 .. 2027-12

ALTER TABLE public.polizas ADD COLUMN IF NOT EXISTS fecha_renovacion date;
ALTER TABLE public.polizas ADD COLUMN IF NOT EXISTS tipo_pago text;
ALTER TABLE public.polizas ADD COLUMN IF NOT EXISTS dia_pago smallint CHECK (dia_pago >= 1 AND dia_pago <= 31);
ALTER TABLE public.polizas ADD COLUMN IF NOT EXISTS meses_check jsonb NOT NULL DEFAULT '{}'::jsonb;

-- Optional index to query by renewal date
CREATE INDEX IF NOT EXISTS polizas_fecha_renovacion_idx ON public.polizas(fecha_renovacion);


-- FILE: 20250911F_polizas_periodicidad_view.sql



SELECT 
	p.id,
	p.cliente_id,
	p.numero_poliza,
	p.estatus,
	p.forma_pago, -- mÃ©todo de cobro
	p.periodicidad_pago, -- frecuencia A/S/T/M
	p.prima_input,
	p.prima_moneda,
	p.sa_input,
	p.sa_moneda,
	p.fecha_emision,
	p.fecha_renovacion,
	p.tipo_pago,
	p.dia_pago,
	p.meses_check,
	p.producto_parametro_id,
	p.fecha_alta_sistema
FROM polizas p;


-- DROP TRIGGER IF EXISTS polizas_ui_trigger ON polizas_ui;
-- CREATE TRIGGER polizas_ui_trigger
--   INSTEAD OF INSERT OR UPDATE ON polizas_ui
--   FOR EACH ROW EXECUTE FUNCTION polizas_ui_upsert();


-- FILE: 20250911G_update_apply_poliza_update_extra_campos.sql
CREATE OR REPLACE FUNCTION apply_poliza_update(p_request_id uuid)
RETURNS void
AS $$
DECLARE
  v_poliza_id uuid;
  v_payload jsonb;
  r_old polizas%ROWTYPE;
  r_new polizas%ROWTYPE;
  v_old_prima numeric(14,2);
  v_new_prima numeric(14,2);
BEGIN
  IF NOT is_super_role() THEN
    RAISE EXCEPTION 'permiso denegado (se requiere supervisor)';
  END IF;

  SELECT poliza_id, payload_propuesto
    INTO v_poliza_id, v_payload
  FROM poliza_update_requests
  WHERE id = p_request_id AND estado = 'PENDIENTE'
  FOR UPDATE;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'solicitud no encontrada o no pendiente';
  END IF;

  SELECT * INTO r_old FROM polizas WHERE id = v_poliza_id FOR UPDATE;

  -- Actualiza sÃ³lo campos permitidos (extendido)
  UPDATE polizas SET
    numero_poliza         = COALESCE(NULLIF(TRIM(v_payload->>'numero_poliza'),''), numero_poliza),
    estatus               = COALESCE((v_payload->>'estatus')::estatus_poliza, estatus),
    fecha_emision         = COALESCE((v_payload->>'fecha_emision')::date, fecha_emision),
    fecha_renovacion      = COALESCE((v_payload->>'fecha_renovacion')::date, fecha_renovacion),
    forma_pago            = COALESCE((v_payload->>'forma_pago')::forma_pago, forma_pago),
    periodicidad_pago     = COALESCE((v_payload->>'periodicidad_pago')::periodicidad_pago, periodicidad_pago),
    dia_pago              = COALESCE((v_payload->>'dia_pago')::int, dia_pago),
    prima_input           = COALESCE((v_payload->>'prima_input')::numeric, prima_input),
    prima_moneda          = COALESCE((v_payload->>'prima_moneda')::moneda_poliza, prima_moneda),
    sa_input              = COALESCE((v_payload->>'sa_input')::numeric, sa_input),
    sa_moneda             = COALESCE((v_payload->>'sa_moneda')::moneda_poliza, sa_moneda),
    producto_parametro_id = COALESCE((v_payload->>'producto_parametro_id')::uuid, producto_parametro_id),
    meses_check           = COALESCE((CASE WHEN jsonb_typeof(v_payload->'meses_check')='object' THEN v_payload->'meses_check' END), meses_check),
    updated_at            = now()
  WHERE id = v_poliza_id;

  SELECT * INTO r_new FROM polizas WHERE id = v_poliza_id;

  -- Historial de costos si cambiÃ³ prima_input
  v_old_prima := r_old.prima_input;
  v_new_prima := r_new.prima_input;
  IF v_old_prima IS DISTINCT FROM v_new_prima THEN
    INSERT INTO historial_costos_poliza (
      id, poliza_id, prima_anual_old, prima_anual_new, porcentaje_comision_old, porcentaje_comision_new, actor_id, creado_at
    ) VALUES (
      gen_random_uuid(), v_poliza_id, v_old_prima, v_new_prima, NULL, NULL, auth.uid(), now()
    );
  END IF;

  UPDATE poliza_update_requests
  SET estado = 'APROBADA', resuelto_at = now(), resuelto_por = auth.uid()
  WHERE id = p_request_id;

  PERFORM recalc_puntos_poliza(v_poliza_id);
END;
$$ LANGUAGE plpgsql;

-- Fin actualizaciÃ³n

-- FILE: 20250911H_fix_apply_poliza_update_null_casts.sql
-- Fix: apply_poliza_update robust casting (evitar 400 por ''::int / ''::numeric / ''::enum)
-- Fecha: 2025-09-11
-- Nota: reemplaza funciÃ³n para ignorar strings vacÃ­os en el payload_propuesto

CREATE OR REPLACE FUNCTION apply_poliza_update(p_request_id uuid)
RETURNS void
AS $$
DECLARE
  v_poliza_id uuid;
  v_payload jsonb;
  r_old polizas%ROWTYPE;
  r_new polizas%ROWTYPE;
  v_old_prima numeric(14,2);
  v_new_prima numeric(14,2);
BEGIN
  IF NOT is_super_role() THEN
    RAISE EXCEPTION 'permiso denegado (se requiere supervisor)';
  END IF;

  SELECT poliza_id, payload_propuesto
    INTO v_poliza_id, v_payload
  FROM poliza_update_requests
  WHERE id = p_request_id AND estado = 'PENDIENTE'
  FOR UPDATE;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'solicitud no encontrada o no pendiente';
  END IF;

  SELECT * INTO r_old FROM polizas WHERE id = v_poliza_id FOR UPDATE;

  -- Actualiza sÃ³lo campos permitidos, usando NULLIF para evitar casts de ''
  UPDATE polizas SET
    numero_poliza         = COALESCE(NULLIF(TRIM(v_payload->>'numero_poliza'),''), numero_poliza),
    estatus               = COALESCE((NULLIF(v_payload->>'estatus',''))::estatus_poliza, estatus),
    fecha_emision         = COALESCE((NULLIF(v_payload->>'fecha_emision',''))::date, fecha_emision),
    fecha_renovacion      = COALESCE((NULLIF(v_payload->>'fecha_renovacion',''))::date, fecha_renovacion),
    forma_pago            = COALESCE((NULLIF(v_payload->>'forma_pago',''))::forma_pago, forma_pago),
    periodicidad_pago     = COALESCE((NULLIF(v_payload->>'periodicidad_pago',''))::periodicidad_pago, periodicidad_pago),
    dia_pago              = COALESCE((NULLIF(v_payload->>'dia_pago',''))::int, dia_pago),
    prima_input           = COALESCE((NULLIF(v_payload->>'prima_input',''))::numeric, prima_input),
    prima_moneda          = COALESCE((NULLIF(v_payload->>'prima_moneda',''))::moneda_poliza, prima_moneda),
    sa_input              = COALESCE((NULLIF(v_payload->>'sa_input',''))::numeric, sa_input),
    sa_moneda             = COALESCE((NULLIF(v_payload->>'sa_moneda',''))::moneda_poliza, sa_moneda),
    producto_parametro_id = COALESCE((NULLIF(v_payload->>'producto_parametro_id',''))::uuid, producto_parametro_id),
    meses_check           = COALESCE((CASE WHEN jsonb_typeof(v_payload->'meses_check')='object' THEN v_payload->'meses_check' END), meses_check),
    updated_at            = now()
  WHERE id = v_poliza_id;

  SELECT * INTO r_new FROM polizas WHERE id = v_poliza_id;

  v_old_prima := r_old.prima_input;
  v_new_prima := r_new.prima_input;
  IF v_old_prima IS DISTINCT FROM v_new_prima THEN
    INSERT INTO historial_costos_poliza (
      id, poliza_id, prima_anual_old, prima_anual_new, porcentaje_comision_old, porcentaje_comision_new, actor_id, creado_at
    ) VALUES (
      gen_random_uuid(), v_poliza_id, v_old_prima, v_new_prima, NULL, NULL, auth.uid(), now()
    );
  END IF;

  UPDATE poliza_update_requests
  SET estado = 'APROBADA', resuelto_at = now(), resuelto_por = auth.uid()
  WHERE id = p_request_id;

  PERFORM recalc_puntos_poliza(v_poliza_id);
END;
$$ LANGUAGE plpgsql;


-- FILE: 20250911I_periodicidad_pago_enum.sql
-- Crea enum periodicidad_pago y columna en polizas si no existen
-- Fecha: 2025-09-11
-- NOTA: El linter estÃ¡ fallando con CREATE TYPE; ejecutar manualmente en SQL:
--   CREATE TYPE periodicidad_pago AS ENUM ('A','S','T','M');
-- Si ya existe, ignorar el error de duplicado.

ALTER TABLE polizas ADD COLUMN periodicidad_pago periodicidad_pago NULL;

-- Opcional: Ã­ndice para filtros frecuentes
CREATE INDEX IF NOT EXISTS idx_polizas_periodicidad_pago ON polizas(periodicidad_pago);


-- FILE: 20250911J_apply_poliza_update_periodicidad_mapping.sql
-- Mejora: mapeo de valores legacy de periodicidad (ANUAL, SEMESTRAL, TRIMESTRAL, MENSUAL) a enum A/S/T/M
-- Fecha: 2025-09-11

CREATE OR REPLACE FUNCTION apply_poliza_update(p_request_id uuid)
RETURNS void
AS $$
DECLARE
  v_poliza_id uuid;
  v_payload jsonb;
  r_old polizas%ROWTYPE;
  r_new polizas%ROWTYPE;
  v_old_prima numeric(14,2);
  v_new_prima numeric(14,2);
  v_periodicidad_raw text;
  v_periodicidad_enum periodicidad_pago;
BEGIN
  IF NOT is_super_role() THEN
    RAISE EXCEPTION 'permiso denegado (se requiere supervisor)';
  END IF;

  SELECT poliza_id, payload_propuesto
    INTO v_poliza_id, v_payload
  FROM poliza_update_requests
  WHERE id = p_request_id AND estado = 'PENDIENTE'
  FOR UPDATE;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'solicitud no encontrada o no pendiente';
  END IF;

  SELECT * INTO r_old FROM polizas WHERE id = v_poliza_id FOR UPDATE;

  -- Normalizar periodicidad
  v_periodicidad_raw := NULLIF(v_payload->>'periodicidad_pago','');
  IF v_periodicidad_raw IS NOT NULL THEN
    v_periodicidad_raw := upper(trim(v_periodicidad_raw));
    IF v_periodicidad_raw IN ('A','ANUAL','ANUALIDAD') THEN
      v_periodicidad_enum := 'A';
    ELSIF v_periodicidad_raw IN ('S','SEMESTRAL','SEMESTRA') THEN
      v_periodicidad_enum := 'S';
    ELSIF v_periodicidad_raw IN ('T','TRIMESTRAL','TRIMESTRE') THEN
      v_periodicidad_enum := 'T';
    ELSIF v_periodicidad_raw IN ('M','MENSUAL','MES') THEN
      v_periodicidad_enum := 'M';
    ELSIF v_periodicidad_raw IN ('A','S','T','M') THEN
      v_periodicidad_enum := v_periodicidad_raw::periodicidad_pago; -- redundante
    ELSE
      -- Valor invÃ¡lido: ignorar (no aplica cambio)
      v_periodicidad_enum := NULL;
    END IF;
  END IF;

  -- Actualiza campos (robusto contra strings vacÃ­os)
  UPDATE polizas SET
    numero_poliza         = COALESCE(NULLIF(TRIM(v_payload->>'numero_poliza'),''), numero_poliza),
    estatus               = COALESCE((NULLIF(v_payload->>'estatus',''))::estatus_poliza, estatus),
    fecha_emision         = COALESCE((NULLIF(v_payload->>'fecha_emision',''))::date, fecha_emision),
    fecha_renovacion      = COALESCE((NULLIF(v_payload->>'fecha_renovacion',''))::date, fecha_renovacion),
    forma_pago            = COALESCE((NULLIF(v_payload->>'forma_pago',''))::forma_pago, forma_pago),
    periodicidad_pago     = COALESCE(v_periodicidad_enum, periodicidad_pago),
    dia_pago              = COALESCE((NULLIF(v_payload->>'dia_pago',''))::int, dia_pago),
    prima_input           = COALESCE((NULLIF(v_payload->>'prima_input',''))::numeric, prima_input),
    prima_moneda          = COALESCE((NULLIF(v_payload->>'prima_moneda',''))::moneda_poliza, prima_moneda),
    sa_input              = COALESCE((NULLIF(v_payload->>'sa_input',''))::numeric, sa_input),
    sa_moneda             = COALESCE((NULLIF(v_payload->>'sa_moneda',''))::moneda_poliza, sa_moneda),
    producto_parametro_id = COALESCE((NULLIF(v_payload->>'producto_parametro_id',''))::uuid, producto_parametro_id),
    meses_check           = COALESCE((CASE WHEN jsonb_typeof(v_payload->'meses_check')='object' THEN v_payload->'meses_check' END), meses_check),
    updated_at            = now()
  WHERE id = v_poliza_id;

  SELECT * INTO r_new FROM polizas WHERE id = v_poliza_id;

  v_old_prima := r_old.prima_input;
  v_new_prima := r_new.prima_input;
  IF v_old_prima IS DISTINCT FROM v_new_prima THEN
    INSERT INTO historial_costos_poliza (
      id, poliza_id, prima_anual_old, prima_anual_new, porcentaje_comision_old, porcentaje_comision_new, actor_id, creado_at
    ) VALUES (
      gen_random_uuid(), v_poliza_id, v_old_prima, v_new_prima, NULL, NULL, auth.uid(), now()
    );
  END IF;

  UPDATE poliza_update_requests
  SET estado = 'APROBADA', resuelto_at = now(), resuelto_por = auth.uid()
  WHERE id = p_request_id;

  PERFORM recalc_puntos_poliza(v_poliza_id);
END;
$$ LANGUAGE plpgsql;


-- FILE: 20250911K_fix_is_super_role_dual_id.sql
-- Fix: is_super_role acepta coincidencia por usuarios.id o usuarios.id_auth
-- Fecha: 2025-09-11
CREATE OR REPLACE FUNCTION is_super_role()
RETURNS boolean
LANGUAGE plpgsql
SET search_path = public
AS $$
DECLARE
  v_is_super boolean := false;
BEGIN
  SELECT TRUE INTO v_is_super
  FROM usuarios
  WHERE (id_auth = auth.uid() OR id = auth.uid())
    AND activo IS TRUE
    AND lower(rol) IN ('supervisor','admin')
  LIMIT 1;

  IF v_is_super THEN
    RETURN TRUE;
  END IF;

  RETURN jwt_role() IN ('supervisor','admin');
END;
$$;


-- FILE: 20250911L_fix_is_super_role_type_mismatch.sql
-- Fix: is_super_role elimina comparaciÃ³n invÃ¡lida bigint(uuid)
-- Fecha: 2025-09-11
CREATE OR REPLACE FUNCTION is_super_role()
RETURNS boolean
LANGUAGE plpgsql
SET search_path = public
AS $$
DECLARE
  v_is_super boolean := false;
BEGIN
  SELECT TRUE INTO v_is_super
  FROM usuarios
  WHERE id_auth = auth.uid()
    AND activo IS TRUE
    AND lower(rol) IN ('supervisor','admin')
  LIMIT 1;

  IF v_is_super THEN
    RETURN TRUE;
  END IF;

  RETURN jwt_role() IN ('supervisor','admin');
END;
$$;

-- NOTA: Si existen usuarios sin id_auth, ejecutar (como admin):
--   UPDATE usuarios SET id_auth = '<UUID_SUPABASE_AUTH>' WHERE id = <id_numÃ©rico> AND id_auth IS NULL;
-- Verificar:
--   SELECT id, id_auth, rol, activo FROM usuarios WHERE id_auth = '<UUID_SUPABASE_AUTH>';


-- FILE: 20250911M_fix_is_super_role_simple.sql
-- Fix: is_super_role sin comparaciÃ³n bigint=uuid (solo id_auth)
-- Fecha: 2025-09-11
CREATE OR REPLACE FUNCTION is_super_role()
RETURNS boolean
AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM usuarios
    WHERE id_auth = auth.uid()
      AND activo IS TRUE
      AND lower(rol) IN ('supervisor','admin')
  ) OR jwt_role() IN ('supervisor','admin');
END;
$$ LANGUAGE plpgsql;


-- FILE: 20250911N_fix_apply_poliza_update_periodicidad_type.sql
-- Fix: conflicto de tipos periodicidad_pago_enum -> periodicidad_pago (error 42846)
-- Fecha: 2025-09-11
-- Estrategia: usar variable texto y castear explÃ­citamente a periodicidad_pago.

CREATE OR REPLACE FUNCTION apply_poliza_update(p_request_id uuid)
RETURNS void
AS $$
DECLARE
  v_poliza_id uuid;
  v_payload jsonb;
  r_old polizas%ROWTYPE;
  r_new polizas%ROWTYPE;
  v_old_prima numeric(14,2);
  v_new_prima numeric(14,2);
  v_periodicidad_raw text;
  v_periodicidad_txt text; -- almacenamos A/S/T/M como texto
BEGIN
  IF NOT is_super_role() THEN
    RAISE EXCEPTION 'permiso denegado (se requiere supervisor)';
  END IF;

  SELECT poliza_id, payload_propuesto
    INTO v_poliza_id, v_payload
  FROM poliza_update_requests
  WHERE id = p_request_id AND estado = 'PENDIENTE'
  FOR UPDATE;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'solicitud no encontrada o no pendiente';
  END IF;

  SELECT * INTO r_old FROM polizas WHERE id = v_poliza_id FOR UPDATE;

  -- Normalizar periodicidad (legacy)
  v_periodicidad_raw := NULLIF(v_payload->>'periodicidad_pago','');
  IF v_periodicidad_raw IS NOT NULL THEN
    v_periodicidad_raw := upper(trim(v_periodicidad_raw));
    IF v_periodicidad_raw IN ('A','ANUAL','ANUALIDAD') THEN
      v_periodicidad_txt := 'A';
    ELSIF v_periodicidad_raw IN ('S','SEMESTRAL','SEMESTRA') THEN
      v_periodicidad_txt := 'S';
    ELSIF v_periodicidad_raw IN ('T','TRIMESTRAL','TRIMESTRE') THEN
      v_periodicidad_txt := 'T';
    ELSIF v_periodicidad_raw IN ('M','MENSUAL','MES') THEN
      v_periodicidad_txt := 'M';
    ELSIF v_periodicidad_raw IN ('A','S','T','M') THEN
      v_periodicidad_txt := v_periodicidad_raw; -- redundante
    ELSE
      v_periodicidad_txt := NULL; -- ignorar valor invÃ¡lido
    END IF;
  END IF;

  UPDATE polizas SET
    numero_poliza         = COALESCE(NULLIF(TRIM(v_payload->>'numero_poliza'),''), numero_poliza),
    estatus               = COALESCE((NULLIF(v_payload->>'estatus',''))::estatus_poliza, estatus),
    fecha_emision         = COALESCE((NULLIF(v_payload->>'fecha_emision',''))::date, fecha_emision),
    fecha_renovacion      = COALESCE((NULLIF(v_payload->>'fecha_renovacion',''))::date, fecha_renovacion),
    forma_pago            = COALESCE((NULLIF(v_payload->>'forma_pago',''))::forma_pago, forma_pago),
  -- Nota: la columna aÃºn usa enum antiguo periodicidad_pago_enum, por eso casteamos a ese tipo
  periodicidad_pago     = COALESCE((CASE WHEN v_periodicidad_txt IS NOT NULL THEN v_periodicidad_txt::text::periodicidad_pago_enum END), periodicidad_pago),
    dia_pago              = COALESCE((NULLIF(v_payload->>'dia_pago',''))::int, dia_pago),
    prima_input           = COALESCE((NULLIF(v_payload->>'prima_input',''))::numeric, prima_input),
    prima_moneda          = COALESCE((NULLIF(v_payload->>'prima_moneda',''))::moneda_poliza, prima_moneda),
    sa_input              = COALESCE((NULLIF(v_payload->>'sa_input',''))::numeric, sa_input),
    sa_moneda             = COALESCE((NULLIF(v_payload->>'sa_moneda',''))::moneda_poliza, sa_moneda),
    producto_parametro_id = COALESCE((NULLIF(v_payload->>'producto_parametro_id',''))::uuid, producto_parametro_id),
    meses_check           = COALESCE((CASE WHEN jsonb_typeof(v_payload->'meses_check')='object' THEN v_payload->'meses_check' END), meses_check),
    updated_at            = now()
  WHERE id = v_poliza_id;

  SELECT * INTO r_new FROM polizas WHERE id = v_poliza_id;

  v_old_prima := r_old.prima_input;
  v_new_prima := r_new.prima_input;
  IF v_old_prima IS DISTINCT FROM v_new_prima THEN
    INSERT INTO historial_costos_poliza (
      id, poliza_id, prima_anual_old, prima_anual_new, porcentaje_comision_old, porcentaje_comision_new, actor_id, creado_at
    ) VALUES (
      gen_random_uuid(), v_poliza_id, v_old_prima, v_new_prima, NULL, NULL, auth.uid(), now()
    );
  END IF;

  UPDATE poliza_update_requests
  SET estado = 'APROBADA', resuelto_at = now(), resuelto_por = auth.uid()
  WHERE id = p_request_id;

  PERFORM recalc_puntos_poliza(v_poliza_id);
END;
$$ LANGUAGE plpgsql;


-- FILE: 20250911O_saneo_periodicidad_pago_enum.sql
-- Saneo definitivo de periodicidad_pago: migrar de enum inconsistente a un enum Ãºnico
-- Fecha: 2025-09-11
-- Pasos:
-- 1. Detectar tipo actual de la columna polizas.periodicidad_pago.
-- 2. Renombrar enum viejo si su nombre no es 'periodicidad_pago'. (Si ya se llama periodicidad_pago, saltar.)
-- 3. Crear enum destino (periodicidad_pago) con valores ('A','S','T','M') si no existe.
-- 4. Alterar columna convirtiendo valores.
-- 5. Reemplazar funciÃ³n apply_poliza_update para usar el nuevo enum.
-- 6. (Opcional) Dropear enum viejo si queda sin dependencias.

DO $$
DECLARE
  v_col_typ text;
  v_exists boolean;
BEGIN
  -- Tipo actual de la columna
  SELECT at.typname
  INTO v_col_typ
  FROM pg_attribute a
  JOIN pg_class c ON c.oid = a.attrelid AND c.relname='polizas'
  JOIN pg_namespace n ON n.oid = c.relnamespace AND n.nspname='public'
  JOIN pg_type at ON at.oid = a.atttypid
  WHERE a.attname='periodicidad_pago';

  -- Crear enum destino si no existe
  SELECT EXISTS (SELECT 1 FROM pg_type t JOIN pg_namespace n ON n.oid=t.typnamespace
                 WHERE t.typname='periodicidad_pago' AND n.nspname='public') INTO v_exists;
  IF NOT v_exists THEN
    EXECUTE 'CREATE TYPE public.periodicidad_pago AS ENUM (''A'',''S'',''T'',''M'')';
  END IF;

  -- Si el tipo actual no es periodicidad_pago, migrar
  IF v_col_typ <> 'periodicidad_pago' THEN
    -- Asegurar que todos los valores existentes estÃ©n en el set permitido
    -- (Si hubiera otros, se podrÃ­an mapear aquÃ­ usando UPDATE previo.)
    EXECUTE $$ALTER TABLE public.polizas
              ALTER COLUMN periodicidad_pago TYPE public.periodicidad_pago
              USING (CASE
                        WHEN periodicidad_pago::text IN ('A','S','T','M') THEN periodicidad_pago::text::public.periodicidad_pago
                        ELSE NULL
                     END)$$;
  END IF;
END $$;

-- Reemplazar funciÃ³n con cast al enum final
CREATE OR REPLACE FUNCTION apply_poliza_update(p_request_id uuid)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_poliza_id uuid;
  v_payload jsonb;
  r_old polizas%ROWTYPE;
  r_new polizas%ROWTYPE;
  v_old_prima numeric(14,2);
  v_new_prima numeric(14,2);
  v_periodicidad_raw text;
  v_periodicidad_txt text;
BEGIN
  IF NOT is_super_role() THEN
    RAISE EXCEPTION 'permiso denegado (se requiere supervisor)';
  END IF;

  SELECT poliza_id, payload_propuesto
    INTO v_poliza_id, v_payload
  FROM poliza_update_requests
  WHERE id = p_request_id AND estado = 'PENDIENTE'
  FOR UPDATE;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'solicitud no encontrada o no pendiente';
  END IF;

  SELECT * INTO r_old FROM polizas WHERE id = v_poliza_id FOR UPDATE;

  v_periodicidad_raw := NULLIF(v_payload->>'periodicidad_pago','');
  IF v_periodicidad_raw IS NOT NULL THEN
    v_periodicidad_raw := upper(trim(v_periodicidad_raw));
    IF v_periodicidad_raw IN ('A','ANUAL','ANUALIDAD') THEN v_periodicidad_txt := 'A';
    ELSIF v_periodicidad_raw IN ('S','SEMESTRAL','SEMESTRA') THEN v_periodicidad_txt := 'S';
    ELSIF v_periodicidad_raw IN ('T','TRIMESTRAL','TRIMESTRE') THEN v_periodicidad_txt := 'T';
    ELSIF v_periodicidad_raw IN ('M','MENSUAL','MES') THEN v_periodicidad_txt := 'M';
    ELSIF v_periodicidad_raw IN ('A','S','T','M') THEN v_periodicidad_txt := v_periodicidad_raw;
    ELSE v_periodicidad_txt := NULL; END IF;
  END IF;

  UPDATE polizas SET
    numero_poliza         = COALESCE(NULLIF(TRIM(v_payload->>'numero_poliza'),''), numero_poliza),
    estatus               = COALESCE(NULLIF(v_payload->>'estatus','')::estatus_poliza, estatus),
    fecha_emision         = COALESCE(NULLIF(v_payload->>'fecha_emision','')::date, fecha_emision),
    fecha_renovacion      = COALESCE(NULLIF(v_payload->>'fecha_renovacion','')::date, fecha_renovacion),
    forma_pago            = COALESCE(NULLIF(v_payload->>'forma_pago','')::forma_pago, forma_pago),
    periodicidad_pago     = COALESCE((CASE WHEN v_periodicidad_txt IS NOT NULL THEN v_periodicidad_txt::public.periodicidad_pago END), periodicidad_pago),
    dia_pago              = COALESCE(NULLIF(v_payload->>'dia_pago','')::int, dia_pago),
    prima_input           = COALESCE(NULLIF(v_payload->>'prima_input','')::numeric, prima_input),
    prima_moneda          = COALESCE(NULLIF(v_payload->>'prima_moneda','')::moneda_poliza, prima_moneda),
    sa_input              = COALESCE(NULLIF(v_payload->>'sa_input','')::numeric, sa_input),
    sa_moneda             = COALESCE(NULLIF(v_payload->>'sa_moneda','')::moneda_poliza, sa_moneda),
    producto_parametro_id = COALESCE(NULLIF(v_payload->>'producto_parametro_id','')::uuid, producto_parametro_id),
    meses_check           = COALESCE((CASE WHEN jsonb_typeof(v_payload->'meses_check')='object' THEN v_payload->'meses_check' END), meses_check),
    updated_at            = now()
  WHERE id = v_poliza_id;

  SELECT * INTO r_new FROM polizas WHERE id = v_poliza_id;

  v_old_prima := r_old.prima_input;
  v_new_prima := r_new.prima_input;
  IF v_old_prima IS DISTINCT FROM v_new_prima THEN
    INSERT INTO historial_costos_poliza(
      id, poliza_id, prima_anual_old, prima_anual_new, porcentaje_comision_old, porcentaje_comision_new, actor_id, creado_at
    ) VALUES (
      gen_random_uuid(), v_poliza_id, v_old_prima, v_new_prima, NULL, NULL, auth.uid(), now()
    );
  END IF;

  UPDATE poliza_update_requests
  SET estado='APROBADA', resuelto_at=now(), resuelto_por=auth.uid()
  WHERE id = p_request_id;

  PERFORM recalc_puntos_poliza(v_poliza_id);
END;
$$;

-- (Opcional) Intentar dropear el enum viejo si existe y no estÃ¡ en uso.
DO $$
DECLARE
  v_old_name text := 'periodicidad_pago_enum';
  v_dep_count int;
BEGIN
  IF EXISTS (SELECT 1 FROM pg_type t JOIN pg_namespace n ON n.oid=t.typnamespace
             WHERE t.typname=v_old_name AND n.nspname='public') THEN
    SELECT count(*) INTO v_dep_count
    FROM pg_depend d JOIN pg_type t ON d.refobjid=t.oid
    WHERE t.typname=v_old_name;
    IF v_dep_count = 0 THEN
      EXECUTE 'DROP TYPE public.'||v_old_name;
    END IF;
  END IF;
END $$;


-- FILE: 20250911P_alter_polizas_periodicidad_pago_enum_cleanup.sql
-- Migration: Alter polizas.periodicidad_pago from legacy enum to unified public.periodicidad_pago with view dependency handling
-- Date: 2025-09-11
-- This migration is idempotent-ish: it checks current column type and only alters if still the old enum.
-- Steps:
-- 1. Drop dependent view public.polizas_ui (if it exists) because it references the old enum type.
-- 2. Alter the column to the new enum type.
-- 3. Recreate the view public.polizas_ui.
-- 4. (Optional) Re-grant typical Supabase roles (adjust if your project uses different ones).
-- NOTE: Ensure previous migration that creates type public.periodicidad_pago has run.

CREATE OR REPLACE FUNCTION _tmp_alter_polizas_periodicidad_pago() RETURNS void AS $$
DECLARE
  v_col_type text;
  v_has_view boolean;
BEGIN
  SELECT at.typname
    INTO v_col_type
  FROM pg_attribute a
  JOIN pg_class c ON c.oid = a.attrelid AND c.relname='polizas'
  JOIN pg_namespace n ON n.oid = c.relnamespace AND n.nspname='public'
  JOIN pg_type at ON at.oid = a.atttypid
  WHERE a.attname='periodicidad_pago';

  SELECT EXISTS (SELECT 1 FROM pg_views WHERE schemaname='public' AND viewname='polizas_ui') INTO v_has_view;

  IF v_has_view THEN
    EXECUTE 'DROP VIEW public.polizas_ui';
  END IF;

  IF v_col_type <> 'periodicidad_pago' THEN
    EXECUTE 'ALTER TABLE public.polizas ALTER COLUMN periodicidad_pago TYPE public.periodicidad_pago USING periodicidad_pago::text::public.periodicidad_pago';
  END IF;
END; $$ LANGUAGE plpgsql;

SELECT _tmp_alter_polizas_periodicidad_pago();
DROP FUNCTION _tmp_alter_polizas_periodicidad_pago();

-- Recreate the view (simple projection of polizas). Adjust if original definition had filters/joins.
CREATE OR REPLACE VIEW public.polizas_ui AS
SELECT 
  p.id,
  p.cliente_id,
  p.numero_poliza,
  p.estatus,
  p.forma_pago,
  p.periodicidad_pago,
  p.prima_input,
  p.prima_moneda,
  p.sa_input,
  p.sa_moneda,
  p.fecha_emision,
  p.fecha_renovacion,
  p.tipo_pago,
  p.dia_pago,
  p.meses_check,
  p.producto_parametro_id,
  p.fecha_alta_sistema
FROM public.polizas p;

-- Typical Supabase grants (adjust if needed)
DO $$
BEGIN
  BEGIN EXECUTE 'GRANT SELECT ON public.polizas_ui TO anon'; EXCEPTION WHEN OTHERS THEN NULL; END;
  BEGIN EXECUTE 'GRANT SELECT ON public.polizas_ui TO authenticated'; EXCEPTION WHEN OTHERS THEN NULL; END;
  BEGIN EXECUTE 'GRANT SELECT ON public.polizas_ui TO service_role'; EXCEPTION WHEN OTHERS THEN NULL; END;
END $$;

-- (Optional) Old enum drop should happen in a later migration once no objects depend on it.


-- FILE: 20250911Q_apply_poliza_update_debug.sql
-- Debug helper for apply_poliza_update  (remove after issue resolved)
-- Date: 2025-09-11
-- Provides detailed JSON about execution or error when approving a poliza update.
-- Usage (RPC): supabase.rpc('apply_poliza_update_dbg', { p_request_id: 'uuid' })

CREATE OR REPLACE FUNCTION public.apply_poliza_update_dbg(p_request_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
AS $$
DECLARE
  v_poliza_id uuid;
  v_payload jsonb;
  v_before polizas%ROWTYPE;
  v_after polizas%ROWTYPE;
  v_err text;
  v_state text;
BEGIN
  -- Capture pending request data first
  SELECT poliza_id, payload_propuesto
    INTO v_poliza_id, v_payload
  FROM poliza_update_requests
  WHERE id = p_request_id AND estado='PENDIENTE';

  IF v_poliza_id IS NOT NULL THEN
    SELECT * INTO v_before FROM polizas WHERE id = v_poliza_id;
  END IF;

  BEGIN
    PERFORM apply_poliza_update(p_request_id);
    IF v_poliza_id IS NOT NULL THEN
      SELECT * INTO v_after FROM polizas WHERE id = v_poliza_id;
    END IF;
    RETURN jsonb_build_object(
      'status','ok',
      'poliza_id', v_poliza_id,
      'payload', v_payload,
      'before', to_jsonb(v_before),
      'after', to_jsonb(v_after)
    );
  EXCEPTION WHEN OTHERS THEN
    v_err := SQLERRM;
    v_state := SQLSTATE;
    RETURN jsonb_build_object(
      'status','error',
      'sqlstate', v_state,
      'error', v_err,
      'poliza_id', v_poliza_id,
      'payload', v_payload,
      'is_super_role_eval', (SELECT is_super_role()),
      'request_row', (SELECT to_jsonb(r) FROM poliza_update_requests r WHERE r.id = p_request_id)
    );
  END;
END;
$$;

-- Grants (optional)
GRANT EXECUTE ON FUNCTION public.apply_poliza_update_dbg(uuid) TO authenticated, service_role;


-- FILE: 20250911R_is_super_role_wrapper.sql
-- Simple RPC-exponible wrapper para is_super_role() para debugging desde el front
CREATE OR REPLACE FUNCTION public.is_super_role_wrapper()
RETURNS boolean
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT is_super_role();
$$;

GRANT EXECUTE ON FUNCTION public.is_super_role_wrapper() TO authenticated, service_role;


-- FILE: 20250911S_fix_apply_poliza_update_missing_row.sql
-- Fix: SELECT ... FOR UPDATE en poliza_update_requests parecÃ­a no encontrar fila pese a estado=PENDIENTE
-- AcciÃ³n: quitar FOR UPDATE en la lectura inicial de la solicitud y agregar diagnÃ³stico detallado
-- AdemÃ¡s: re-crear helper apply_poliza_update_dbg (faltaba en entorno remoto)
-- Fecha: 2025-09-11

CREATE OR REPLACE FUNCTION apply_poliza_update(p_request_id uuid)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_poliza_id uuid;
  v_payload jsonb;
  v_estado text;
  r_old polizas%ROWTYPE;
  r_new polizas%ROWTYPE;
  v_old_prima numeric(14,2);
  v_new_prima numeric(14,2);
  v_periodicidad_raw text;
  v_periodicidad_txt text;
BEGIN
  IF NOT is_super_role() THEN
    RAISE EXCEPTION 'permiso denegado (se requiere supervisor)';
  END IF;

  -- Leer la solicitud SIN FOR UPDATE (parece causar que no se devuelva fila en RLS)
  SELECT poliza_id, payload_propuesto, estado
    INTO v_poliza_id, v_payload, v_estado
  FROM poliza_update_requests
  WHERE id = p_request_id;

  IF v_poliza_id IS NULL THEN
    RAISE EXCEPTION 'solicitud no encontrada';
  END IF;
  IF v_estado <> 'PENDIENTE' THEN
    RAISE EXCEPTION 'solicitud no pendiente (estado=%)', v_estado;
  END IF;

  -- Bloquear la pÃ³liza (evita condiciones de carrera)
  SELECT * INTO r_old FROM polizas WHERE id = v_poliza_id FOR UPDATE;

  v_periodicidad_raw := NULLIF(v_payload->>'periodicidad_pago','');
  IF v_periodicidad_raw IS NOT NULL THEN
    v_periodicidad_raw := upper(trim(v_periodicidad_raw));
    IF v_periodicidad_raw IN ('A','ANUAL','ANUALIDAD') THEN v_periodicidad_txt := 'A';
    ELSIF v_periodicidad_raw IN ('S','SEMESTRAL','SEMESTRA') THEN v_periodicidad_txt := 'S';
    ELSIF v_periodicidad_raw IN ('T','TRIMESTRAL','TRIMESTRE') THEN v_periodicidad_txt := 'T';
    ELSIF v_periodicidad_raw IN ('M','MENSUAL','MES') THEN v_periodicidad_txt := 'M';
    ELSIF v_periodicidad_raw IN ('A','S','T','M') THEN v_periodicidad_txt := v_periodicidad_raw; ELSE v_periodicidad_txt := NULL; END IF;
  END IF;

  UPDATE polizas SET
    numero_poliza         = COALESCE(NULLIF(TRIM(v_payload->>'numero_poliza'),''), numero_poliza),
    estatus               = COALESCE(NULLIF(v_payload->>'estatus','')::estatus_poliza, estatus),
    fecha_emision         = COALESCE(NULLIF(v_payload->>'fecha_emision','')::date, fecha_emision),
    fecha_renovacion      = COALESCE(NULLIF(v_payload->>'fecha_renovacion','')::date, fecha_renovacion),
    forma_pago            = COALESCE(NULLIF(v_payload->>'forma_pago','')::forma_pago, forma_pago),
    periodicidad_pago     = COALESCE((CASE WHEN v_periodicidad_txt IS NOT NULL THEN v_periodicidad_txt::public.periodicidad_pago END), periodicidad_pago),
    dia_pago              = COALESCE(NULLIF(v_payload->>'dia_pago','')::int, dia_pago),
    prima_input           = COALESCE(NULLIF(v_payload->>'prima_input','')::numeric, prima_input),
    prima_moneda          = COALESCE(NULLIF(v_payload->>'prima_moneda','')::moneda_poliza, prima_moneda),
    sa_input              = COALESCE(NULLIF(v_payload->>'sa_input','')::numeric, sa_input),
    sa_moneda             = COALESCE(NULLIF(v_payload->>'sa_moneda','')::moneda_poliza, sa_moneda),
    producto_parametro_id = COALESCE(NULLIF(v_payload->>'producto_parametro_id','')::uuid, producto_parametro_id),
    meses_check           = COALESCE((CASE WHEN jsonb_typeof(v_payload->'meses_check')='object' THEN v_payload->'meses_check' END), meses_check),
    updated_at            = now()
  WHERE id = v_poliza_id;

  SELECT * INTO r_new FROM polizas WHERE id = v_poliza_id;

  v_old_prima := r_old.prima_input;
  v_new_prima := r_new.prima_input;
  IF v_old_prima IS DISTINCT FROM v_new_prima THEN
    INSERT INTO historial_costos_poliza(
      id, poliza_id, prima_anual_old, prima_anual_new, porcentaje_comision_old, porcentaje_comision_new, actor_id, creado_at
    ) VALUES (
      gen_random_uuid(), v_poliza_id, v_old_prima, v_new_prima, NULL, NULL, auth.uid(), now()
    );
  END IF;

  UPDATE poliza_update_requests
  SET estado='APROBADA', resuelto_at=now(), resuelto_por=auth.uid()
  WHERE id = p_request_id AND estado='PENDIENTE';

  PERFORM recalc_puntos_poliza(v_poliza_id);
END;
$$;

-- Helper debug (jsonb) para inspeccionar por quÃ© falla
CREATE OR REPLACE FUNCTION public.apply_poliza_update_dbg(p_request_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
AS $$
DECLARE
  v_row poliza_update_requests%ROWTYPE;
  v_is_super boolean;
  v_poliza_before polizas%ROWTYPE;
  v_poliza_after polizas%ROWTYPE;
  v_err text;
  v_state text;
BEGIN
  v_is_super := is_super_role();
  SELECT * INTO v_row FROM poliza_update_requests WHERE id = p_request_id;
  IF v_row.poliza_id IS NOT NULL THEN
    SELECT * INTO v_poliza_before FROM polizas WHERE id = v_row.poliza_id;
  END IF;
  BEGIN
    PERFORM apply_poliza_update(p_request_id);
    IF v_row.poliza_id IS NOT NULL THEN
      SELECT * INTO v_poliza_after FROM polizas WHERE id = v_row.poliza_id;
    END IF;
    RETURN jsonb_build_object(
      'status','ok',
      'is_super', v_is_super,
      'request_row', to_jsonb(v_row),
      'poliza_before', to_jsonb(v_poliza_before),
      'poliza_after', to_jsonb(v_poliza_after)
    );
  EXCEPTION WHEN OTHERS THEN
    v_err := SQLERRM; v_state := SQLSTATE;
    RETURN jsonb_build_object(
      'status','error',
      'is_super', v_is_super,
      'sqlstate', v_state,
      'error', v_err,
      'request_row', to_jsonb(v_row)
    );
  END;
END;
$$;

GRANT EXECUTE ON FUNCTION public.apply_poliza_update_dbg(uuid) TO authenticated, service_role;


-- FILE: 20250911T_fix_normalize_prima_fallback.sql
-- Fix: eliminar excepciones por falta de UDI/FX y usar fallback a Ãºltimo valor disponible
-- Fecha: 2025-09-11
-- Reemplaza normalize_prima para que si no hay datos en tablas udi_values / fx_values devuelva NULL (o el monto sin conversiÃ³n)

CREATE OR REPLACE FUNCTION normalize_prima(p_monto numeric, p_moneda moneda_poliza, p_fecha date)
RETURNS numeric
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
  v numeric;
BEGIN
  IF p_monto IS NULL OR p_moneda IS NULL THEN
    RETURN NULL;
  END IF;

  IF p_moneda = 'MXN'::moneda_poliza THEN
    RETURN round(p_monto, 2);
  ELSIF p_moneda = 'USD'::moneda_poliza THEN
    SELECT get_fx_usd(COALESCE(p_fecha, CURRENT_DATE)) INTO v; -- ya con fallback
    IF v IS NULL THEN
      -- Sin datos FX: devolvemos NULL para indicar que no se pudo normalizar
      RETURN NULL;
    END IF;
    RETURN round(p_monto * v, 2);
  ELSIF p_moneda = 'UDI'::moneda_poliza THEN
    SELECT get_current_udi(COALESCE(p_fecha, CURRENT_DATE)) INTO v; -- ya con fallback
    IF v IS NULL THEN
      RETURN NULL;
    END IF;
    RETURN round(p_monto * v, 2);
  ELSE
    RETURN round(p_monto, 2);
  END IF;
END;
$$;

-- Nota: No tocamos triggers; sÃ³lo se beneficiarÃ¡n de la nueva lÃ³gica sin excepciones.


-- FILE: 20250911U_fix_polizas_normalize_coalesce.sql
-- Fix: evitar violaciÃ³n NOT NULL en polizas.prima_mxn cuando normalize_prima devuelve NULL
-- Estrategia: en el trigger polizas_normalize_amounts coalesce a valor previo o 0
-- Fecha: 2025-09-11

CREATE OR REPLACE FUNCTION polizas_normalize_amounts()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
  v_prima_mxn numeric;
  v_sa_mxn numeric;
BEGIN
  -- Calcular prima_mxn con fallback
  v_prima_mxn := normalize_prima(NEW.prima_input, NEW.prima_moneda, NEW.fecha_emision);

  IF TG_OP = 'UPDATE' THEN
    NEW.prima_mxn := COALESCE(v_prima_mxn,
                               OLD.prima_mxn,
                               CASE WHEN NEW.prima_moneda = 'MXN'::moneda_poliza THEN round(NEW.prima_input, 2) END,
                               0);
  ELSE
    -- INSERT
    NEW.prima_mxn := COALESCE(v_prima_mxn,
                               CASE WHEN NEW.prima_moneda = 'MXN'::moneda_poliza THEN round(NEW.prima_input, 2) END,
                               0);
  END IF;

  -- Calcular sa_mxn (columna permite NULL)
  IF NEW.sa_input IS NOT NULL AND NEW.sa_moneda IS NOT NULL THEN
    v_sa_mxn := normalize_prima(NEW.sa_input, NEW.sa_moneda, NEW.fecha_emision);
    NEW.sa_mxn := v_sa_mxn; -- puede ser NULL y es permitido
  ELSE
    NEW.sa_mxn := NULL;
  END IF;

  RETURN NEW;
END;
$$;

-- El trigger existente ya apunta a polizas_normalize_amounts, por lo que el CREATE OR REPLACE es suficiente.


-- FILE: 20250911V_rls_poliza_puntos_cache.sql
-- RLS policies for poliza_puntos_cache: permitir escritura sÃ³lo a supervisores y lectura contextual
-- Fecha: 2025-09-11

-- Limpieza previa
DROP POLICY IF EXISTS sel_poliza_puntos_cache ON poliza_puntos_cache;
DROP POLICY IF EXISTS ins_poliza_puntos_cache_super ON poliza_puntos_cache;
DROP POLICY IF EXISTS upd_poliza_puntos_cache_super ON poliza_puntos_cache;
DROP POLICY IF EXISTS del_poliza_puntos_cache_super ON poliza_puntos_cache;

-- SELECT: el asesor del cliente dueÃ±o de la pÃ³liza o super
CREATE POLICY sel_poliza_puntos_cache ON poliza_puntos_cache
  FOR SELECT TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM polizas p
      JOIN clientes c ON c.id = p.cliente_id
      WHERE p.id = poliza_puntos_cache.poliza_id
        AND (c.asesor_id = auth.uid() OR is_super_role())
    )
  );

-- INSERT: sÃ³lo super roles
CREATE POLICY ins_poliza_puntos_cache_super ON poliza_puntos_cache
  FOR INSERT TO authenticated
  WITH CHECK (is_super_role());

-- UPDATE: sÃ³lo super roles
CREATE POLICY upd_poliza_puntos_cache_super ON poliza_puntos_cache
  FOR UPDATE TO authenticated
  USING (is_super_role())
  WITH CHECK (is_super_role());

-- DELETE: sÃ³lo super roles
CREATE POLICY del_poliza_puntos_cache_super ON poliza_puntos_cache
  FOR DELETE TO authenticated
  USING (is_super_role());


-- FILE: 20250911W_fix_puntos_cache_nulls.sql
-- Fix: evitar NULL en puntos_total de poliza_puntos_cache
-- Asegura que recalc_puntos_poliza nunca inserte/actualice puntos_total NULL

CREATE OR REPLACE FUNCTION recalc_puntos_poliza(p_poliza_id uuid)
RETURNS void
AS $$
DECLARE
  v_prima_mxn numeric;
  v_prima_moneda moneda_poliza;
  v_sa_mxn numeric;
  v_sa_input numeric;
  v_sa_moneda moneda_poliza;
  v_tipo tipo_producto;
  v_estatus estatus_poliza;
  v_pp_id uuid;
  v_year int;
  v_base_factor numeric;
  v_puntos numeric;
  v_clas tipo_clasificacion_puntos;
  v_fx numeric;
  v_udi numeric;
  v_fecha date;
  v_pp_auto uuid;
BEGIN
  -- Datos base de la pÃ³liza
  SELECT p.prima_mxn, p.prima_moneda, p.sa_mxn, p.sa_input, p.sa_moneda,
         p.estatus, p.producto_parametro_id, p.fecha_emision
    INTO v_prima_mxn, v_prima_moneda, v_sa_mxn, v_sa_input, v_sa_moneda,
         v_estatus, v_pp_id, v_fecha
  FROM polizas p
  WHERE p.id = p_poliza_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'poliza % no existe', p_poliza_id;
  END IF;

  -- Tasas aplicadas para auditorÃ­a
  v_fx := NULL; v_udi := NULL;
  IF v_prima_moneda = 'USD'::moneda_poliza THEN
    SELECT get_fx_usd(v_fecha) INTO v_fx;
  ELSIF v_prima_moneda = 'UDI'::moneda_poliza THEN
    SELECT get_current_udi(v_fecha) INTO v_udi;
  END IF;

  -- Auto-selecciÃ³n de variante si no viene asignada
  IF v_pp_id IS NULL THEN
    SELECT pp.id
      INTO v_pp_auto
    FROM producto_parametros pp
    WHERE pp.activo = true
      AND (pp.moneda IS NULL OR pp.moneda = v_prima_moneda)
      AND (
        v_sa_mxn IS NULL
        OR (
          (pp.sa_min IS NULL OR v_sa_mxn >= pp.sa_min)
          AND (pp.sa_max IS NULL OR v_sa_mxn <= pp.sa_max)
        )
      )
    ORDER BY 
      CASE WHEN pp.moneda = v_prima_moneda THEN 0 ELSE 1 END,
      COALESCE(pp.sa_min, (-1)::numeric) DESC
    LIMIT 1;

    IF v_pp_auto IS NOT NULL THEN
      v_pp_id := v_pp_auto;
      UPDATE polizas SET producto_parametro_id = v_pp_auto, updated_at = now()
      WHERE id = p_poliza_id;
    END IF;
  END IF;

  -- Si anulada, deja en cero
  IF v_estatus = 'ANULADA'::estatus_poliza THEN
    v_puntos := 0;
    v_clas := 'CERO';
  ELSE
    -- Tipo de producto
    IF v_pp_id IS NOT NULL THEN
      SELECT tipo_producto INTO v_tipo FROM producto_parametros WHERE id = v_pp_id;
    ELSE
      v_tipo := NULL;
    END IF;

    -- ClasificaciÃ³n por rangos en MXN
    IF v_tipo = 'GMM'::tipo_producto THEN
      IF v_prima_mxn IS NOT NULL AND v_prima_mxn >= 7500 THEN
        v_puntos := 0.5; v_clas := 'MEDIO';
      ELSE
        v_puntos := 0; v_clas := 'CERO';
      END IF;
    ELSIF v_tipo = 'VI'::tipo_producto THEN
      IF v_prima_mxn IS NULL OR v_prima_mxn < 15000 THEN
        v_puntos := 0; v_clas := 'CERO';
      ELSIF v_prima_mxn >= 150000 THEN
        v_puntos := 3; v_clas := 'TRIPLE';
      ELSIF v_prima_mxn >= 50000 THEN
        v_puntos := 2; v_clas := 'DOBLE';
      ELSE
        v_puntos := 1; v_clas := 'SIMPLE';
      END IF;
    ELSE
      -- Tipo desconocido o sin producto: coalesce a cero para cumplir NOT NULL
      v_puntos := 0; v_clas := 'CERO';
    END IF;
  END IF;

  -- AÃ±o de vigencia
  SELECT poliza_year_vigencia(p.fecha_emision) INTO v_year
  FROM polizas p WHERE p.id = p_poliza_id;

  -- Base factor (porcentaje anual)
  IF v_pp_id IS NOT NULL THEN
    SELECT CASE
             WHEN v_year = 1 THEN anio_1_percent
             WHEN v_year = 2 THEN anio_2_percent
             WHEN v_year = 3 THEN anio_3_percent
             WHEN v_year = 4 THEN anio_4_percent
             WHEN v_year = 5 THEN anio_5_percent
             WHEN v_year = 6 THEN anio_6_percent
             WHEN v_year = 7 THEN anio_7_percent
             WHEN v_year = 8 THEN anio_8_percent
             WHEN v_year = 9 THEN anio_9_percent
             WHEN v_year = 10 THEN anio_10_percent
             ELSE anio_11_plus_percent
           END
      INTO v_base_factor
    FROM producto_parametros
    WHERE id = v_pp_id;
  ELSE
    v_base_factor := NULL;
  END IF;

  -- Garantiza no-nulos antes de escribir
  v_puntos := COALESCE(v_puntos, 0);
  v_clas := COALESCE(v_clas, 'CERO');

  INSERT INTO poliza_puntos_cache (
    poliza_id, puntos_total, clasificacion, base_factor, producto_factor,
    year_factor, prima_anual_snapshot, producto_parametro_id, udi_valor, usd_fx,
    breakdown, recalculo_reason, computed_at, updated_at
  )
  SELECT p.id, v_puntos, v_clas, v_base_factor, NULL,
         v_year, v_prima_mxn, v_pp_id, v_udi, v_fx,
         jsonb_build_object(
           'year', v_year,
           'factor_base', v_base_factor,
           'producto', v_tipo,
           'prima_mxn', v_prima_mxn,
           'sa_mxn', v_sa_mxn,
           'prima_moneda', v_prima_moneda,
           'fx_aplicado', v_fx,
           'udi_aplicada', v_udi
         ),
         'recalc', now(), now()
  FROM polizas p WHERE p.id = p_poliza_id
  ON CONFLICT (poliza_id) DO UPDATE SET
    puntos_total = EXCLUDED.puntos_total,
    clasificacion = EXCLUDED.clasificacion,
    base_factor = EXCLUDED.base_factor,
    producto_factor = EXCLUDED.producto_factor,
    year_factor = EXCLUDED.year_factor,
    prima_anual_snapshot = EXCLUDED.prima_anual_snapshot,
    producto_parametro_id = EXCLUDED.producto_parametro_id,
    udi_valor = EXCLUDED.udi_valor,
    usd_fx = EXCLUDED.usd_fx,
    breakdown = EXCLUDED.breakdown,
    recalculo_reason = EXCLUDED.recalculo_reason,
    updated_at = now();

  UPDATE polizas
  SET clasificacion_actual = v_clas,
      puntos_actuales = v_puntos,
      updated_at = now()
  WHERE id = p_poliza_id;
END;
$$ LANGUAGE plpgsql;


-- FILE: 20250911W_poliza_update_requests_update_policy.sql
-- Permitir UPDATE en poliza_update_requests a roles superiores bajo RLS
-- Motivo: reject_poliza_update() hacÃ­a UPDATE ... WHERE estado='PENDIENTE' pero no habÃ­a polÃ­tica UPDATE,
-- lo que resultaba en 0 filas afectadas y el mensaje 'solicitud no encontrada o no pendiente'.

-- PolÃ­tica de UPDATE para super roles
DROP POLICY IF EXISTS upd_poliza_update_requests_super ON poliza_update_requests;
CREATE POLICY upd_poliza_update_requests_super ON poliza_update_requests
  FOR UPDATE TO authenticated
  USING (is_super_role())
  WITH CHECK (is_super_role());


-- FILE: 20250912_commission_duration_logic.sql
-- Sprint: Commission duration-aware logic and EN_VIGOR gating
-- Date: 2025-09-12
-- Updates recalc_puntos_poliza to:
--  - Compute base_factor (commission percent) considering producto_parametros.duracion_anios
--  - If duracion_anios <= 10 and v_year > duracion, clamp to last defined anio_{dur}_percent
--  - If duracion_anios >= 11 (or NULL), use anio_11_plus_percent for years >= 11
--  - Set base_factor = NULL when estatus != 'EN_VIGOR'

CREATE OR REPLACE FUNCTION recalc_puntos_poliza(p_poliza_id uuid)
RETURNS void
AS $$
DECLARE
  v_prima_mxn numeric;
  v_prima_moneda moneda_poliza;
  v_sa_mxn numeric;
  v_sa_input numeric;
  v_sa_moneda moneda_poliza;
  v_tipo tipo_producto;
  v_estatus estatus_poliza;
  v_pp_id uuid;
  v_year int;
  v_base_factor numeric;
  v_puntos numeric;
  v_clas tipo_clasificacion_puntos;
  v_fx numeric;
  v_udi numeric;
  v_fecha date;
  v_pp_auto uuid;
BEGIN
  -- Datos base de la pÃ³liza
  SELECT p.prima_mxn, p.prima_moneda, p.sa_mxn, p.sa_input, p.sa_moneda,
         p.estatus, p.producto_parametro_id, p.fecha_emision
    INTO v_prima_mxn, v_prima_moneda, v_sa_mxn, v_sa_input, v_sa_moneda,
         v_estatus, v_pp_id, v_fecha
  FROM polizas p
  WHERE p.id = p_poliza_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'poliza % no existe', p_poliza_id;
  END IF;

  -- Tasas aplicadas para auditorÃ­a
  v_fx := NULL; v_udi := NULL;
  IF v_prima_moneda = 'USD'::moneda_poliza THEN
    SELECT get_fx_usd(v_fecha) INTO v_fx;
  ELSIF v_prima_moneda = 'UDI'::moneda_poliza THEN
    SELECT get_current_udi(v_fecha) INTO v_udi;
  END IF;

  -- Auto-selecciÃ³n de variante si no viene asignada
  IF v_pp_id IS NULL THEN
    SELECT pp.id
      INTO v_pp_auto
    FROM producto_parametros pp
    WHERE pp.activo = true
      AND (pp.moneda IS NULL OR pp.moneda = v_prima_moneda)
      AND (
        v_sa_mxn IS NULL
        OR (
          (pp.sa_min IS NULL OR v_sa_mxn >= pp.sa_min)
          AND (pp.sa_max IS NULL OR v_sa_mxn <= pp.sa_max)
        )
      )
    ORDER BY 
      CASE WHEN pp.moneda = v_prima_moneda THEN 0 ELSE 1 END,
      COALESCE(pp.sa_min, (-1)::numeric) DESC
    LIMIT 1;

    IF v_pp_auto IS NOT NULL THEN
      v_pp_id := v_pp_auto;
      UPDATE polizas SET producto_parametro_id = v_pp_auto, updated_at = now()
      WHERE id = p_poliza_id;
    END IF;
  END IF;

  -- Si anulada, deja en cero para puntos
  IF v_estatus = 'ANULADA'::estatus_poliza THEN
    v_puntos := 0;
    v_clas := 'CERO';
  ELSE
    -- Tipo de producto
    IF v_pp_id IS NOT NULL THEN
      SELECT tipo_producto INTO v_tipo FROM producto_parametros WHERE id = v_pp_id;
    ELSE
      v_tipo := NULL;
    END IF;

    -- ClasificaciÃ³n por rangos en MXN (independiente del factor de comisiÃ³n)
    IF v_tipo = 'GMM'::tipo_producto THEN
      IF v_prima_mxn IS NOT NULL AND v_prima_mxn >= 7500 THEN
        v_puntos := 0.5; v_clas := 'MEDIO';
      ELSE
        v_puntos := 0; v_clas := 'CERO';
      END IF;
    ELSIF v_tipo = 'VI'::tipo_producto THEN
      IF v_prima_mxn IS NULL OR v_prima_mxn < 15000 THEN
        v_puntos := 0; v_clas := 'CERO';
      ELSIF v_prima_mxn >= 150000 THEN
        v_puntos := 3; v_clas := 'TRIPLE';
      ELSIF v_prima_mxn >= 50000 THEN
        v_puntos := 2; v_clas := 'DOBLE';
      ELSE
        v_puntos := 1; v_clas := 'SIMPLE';
      END IF;
    ELSE
      -- Tipo desconocido o sin producto: coalesce a cero para cumplir NOT NULL
      v_puntos := 0; v_clas := 'CERO';
    END IF;
  END IF;

  -- AÃ±o de vigencia
  SELECT poliza_year_vigencia(p.fecha_emision) INTO v_year
  FROM polizas p WHERE p.id = p_poliza_id;

  -- Base factor (porcentaje anual) con lÃ³gica de duraciÃ³n y solo EN_VIGOR
  IF v_pp_id IS NOT NULL AND v_estatus = 'EN_VIGOR'::estatus_poliza THEN
    SELECT CASE
             WHEN COALESCE(duracion_anios, 9999) <= 10 THEN
               CASE LEAST(v_year, COALESCE(duracion_anios, 10))
                 WHEN 1 THEN anio_1_percent
                 WHEN 2 THEN anio_2_percent
                 WHEN 3 THEN anio_3_percent
                 WHEN 4 THEN anio_4_percent
                 WHEN 5 THEN anio_5_percent
                 WHEN 6 THEN anio_6_percent
                 WHEN 7 THEN anio_7_percent
                 WHEN 8 THEN anio_8_percent
                 WHEN 9 THEN anio_9_percent
                 WHEN 10 THEN anio_10_percent
                 ELSE NULL
               END
             ELSE
               CASE
                 WHEN v_year = 1 THEN anio_1_percent
                 WHEN v_year = 2 THEN anio_2_percent
                 WHEN v_year = 3 THEN anio_3_percent
                 WHEN v_year = 4 THEN anio_4_percent
                 WHEN v_year = 5 THEN anio_5_percent
                 WHEN v_year = 6 THEN anio_6_percent
                 WHEN v_year = 7 THEN anio_7_percent
                 WHEN v_year = 8 THEN anio_8_percent
                 WHEN v_year = 9 THEN anio_9_percent
                 WHEN v_year = 10 THEN anio_10_percent
                 ELSE anio_11_plus_percent
               END
           END
      INTO v_base_factor
    FROM producto_parametros
    WHERE id = v_pp_id;
  ELSE
    v_base_factor := NULL;
  END IF;

  -- Garantiza no-nulos antes de escribir
  v_puntos := COALESCE(v_puntos, 0);
  v_clas := COALESCE(v_clas, 'CERO');

  INSERT INTO poliza_puntos_cache (
    poliza_id, puntos_total, clasificacion, base_factor, producto_factor,
    year_factor, prima_anual_snapshot, producto_parametro_id, udi_valor, usd_fx,
    breakdown, recalculo_reason, computed_at, updated_at
  )
  SELECT p.id, v_puntos, v_clas, v_base_factor, NULL,
         v_year, v_prima_mxn, v_pp_id, v_udi, v_fx,
         jsonb_build_object(
           'year', v_year,
           'factor_base', v_base_factor,
           'producto', v_tipo,
           'prima_mxn', v_prima_mxn,
           'sa_mxn', v_sa_mxn,
           'prima_moneda', v_prima_moneda,
           'fx_aplicado', v_fx,
           'udi_aplicada', v_udi
         ),
         'recalc', now(), now()
  FROM polizas p WHERE p.id = p_poliza_id
  ON CONFLICT (poliza_id) DO UPDATE SET
    puntos_total = EXCLUDED.puntos_total,
    clasificacion = EXCLUDED.clasificacion,
    base_factor = EXCLUDED.base_factor,
    producto_factor = EXCLUDED.producto_factor,
    year_factor = EXCLUDED.year_factor,
    prima_anual_snapshot = EXCLUDED.prima_anual_snapshot,
    producto_parametro_id = EXCLUDED.producto_parametro_id,
    udi_valor = EXCLUDED.udi_valor,
    usd_fx = EXCLUDED.usd_fx,
    breakdown = EXCLUDED.breakdown,
    recalculo_reason = EXCLUDED.recalculo_reason,
    updated_at = now();

  UPDATE polizas
  SET clasificacion_actual = v_clas,
      puntos_actuales = v_puntos,
      updated_at = now()
  WHERE id = p_poliza_id;
END;
$$ LANGUAGE plpgsql;


-- FILE: 20250913_agente_meta.sql
-- Tabla para metas/indicadores de agente
create table if not exists public.agente_meta (
  usuario_id integer primary key references public.usuarios(id) on delete cascade,
  fecha_conexion_text text, -- almacenado como D/M/YYYY (ej. 17/3/2025)
  objetivo integer,
  updated_at timestamptz not null default now()
);

-- Ãndices Ãºtiles
create index if not exists idx_agente_meta_objetivo on public.agente_meta(objetivo);

-- RLS/policies pueden configurarse posteriormente; las APIs usan service role para upsert controlado


-- FILE: 20250913_purge_polizas.sql
-- Migration: Purge all records from public.polizas (and dependent caches)
-- Date: 2025-09-13
-- Note: This is destructive. It truncates the table and cascades to dependents.

BEGIN;

-- Remove all policies and any dependent rows (e.g., poliza_puntos_cache)
TRUNCATE TABLE public.polizas CASCADE;

COMMIT;


-- FILE: 20250913_recalc_on_producto_parametros_change.sql
-- Migration: Recalculate poliza cache when producto_parametros change
-- Date: 2025-09-13
-- Purpose: When product commission percentages or duration change, update base_factor and commission snapshots for related polizas.

-- 1) Helper function: recalc all polizas referencing a given producto_parametro_id
CREATE OR REPLACE FUNCTION recalc_polizas_by_producto_parametro(p_pp_id uuid)
RETURNS int
LANGUAGE plpgsql
AS $$
DECLARE
  v_count int := 0;
  r RECORD;
BEGIN
  FOR r IN SELECT id FROM polizas WHERE producto_parametro_id = p_pp_id LOOP
    PERFORM recalc_puntos_poliza(r.id);
    v_count := v_count + 1;
  END LOOP;
  RETURN v_count;
END;
$$;

-- 2) Trigger function: after updates to producto_parametros that affect commission
CREATE OR REPLACE FUNCTION producto_parametros_after_update_recalc()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
  v_changed boolean := false;
BEGIN
  -- Detect fields that impact commission or year logic
  IF (NEW.anio_1_percent IS DISTINCT FROM OLD.anio_1_percent) OR
     (NEW.anio_2_percent IS DISTINCT FROM OLD.anio_2_percent) OR
     (NEW.anio_3_percent IS DISTINCT FROM OLD.anio_3_percent) OR
     (NEW.anio_4_percent IS DISTINCT FROM OLD.anio_4_percent) OR
     (NEW.anio_5_percent IS DISTINCT FROM OLD.anio_5_percent) OR
     (NEW.anio_6_percent IS DISTINCT FROM OLD.anio_6_percent) OR
     (NEW.anio_7_percent IS DISTINCT FROM OLD.anio_7_percent) OR
     (NEW.anio_8_percent IS DISTINCT FROM OLD.anio_8_percent) OR
     (NEW.anio_9_percent IS DISTINCT FROM OLD.anio_9_percent) OR
     (NEW.anio_10_percent IS DISTINCT FROM OLD.anio_10_percent) OR
     (NEW.anio_11_plus_percent IS DISTINCT FROM OLD.anio_11_plus_percent) OR
     (NEW.duracion_anios IS DISTINCT FROM OLD.duracion_anios) OR
     (NEW.tipo_producto IS DISTINCT FROM OLD.tipo_producto) OR
     (NEW.activo IS DISTINCT FROM OLD.activo) THEN
    v_changed := true;
  END IF;

  IF v_changed THEN
    PERFORM recalc_polizas_by_producto_parametro(NEW.id);
  END IF;
  RETURN NEW;
END;
$$;

-- 3) Create/update the trigger
DROP TRIGGER IF EXISTS trg_producto_parametros_after_update_recalc ON producto_parametros;
CREATE TRIGGER trg_producto_parametros_after_update_recalc
AFTER UPDATE ON producto_parametros
FOR EACH ROW EXECUTE FUNCTION producto_parametros_after_update_recalc();


-- FILE: 20250913_reset_polizas_minimal_seed.sql
-- Reset polizas and seed exactly 3 per asesor with prima 1000 MXN each
-- Preserves grouping: uses existing clientes grouped by asesor_id and
-- prefers each asesor's most frequent producto_parametro_id; falls back to any available
-- producto_parametros entry if none found.

-- Safety: run inside a single transaction
BEGIN;

-- 1) Clear existing policies (and dependent caches) to start fresh
TRUNCATE TABLE public.polizas CASCADE;

-- 2) Collect asesores and candidate clients per asesor
WITH asesores AS (
  SELECT DISTINCT c.asesor_id
  FROM public.clientes c
  WHERE c.asesor_id IS NOT NULL
), clientes_por_asesor AS (
  SELECT c.asesor_id, c.id AS cliente_id,
         ROW_NUMBER() OVER (PARTITION BY c.asesor_id ORDER BY c.creado_at NULLS LAST, c.id) AS rn
  FROM public.clientes c
  WHERE c.asesor_id IS NOT NULL
), pp_prefer AS (
  -- Prefer the most common producto_parametro_id used previously under each asesor; fallback to any producto_parametros
  SELECT a.asesor_id,
         COALESCE(
           (
             SELECT CAST(MIN(CAST(p.producto_parametro_id AS text)) AS uuid)
             FROM public.polizas p
             JOIN public.clientes cx ON cx.id = p.cliente_id
             WHERE cx.asesor_id = a.asesor_id AND p.producto_parametro_id IS NOT NULL
           ),
           (
             SELECT CAST(MIN(CAST(id AS text)) AS uuid) FROM public.producto_parametros
           )
         ) AS producto_parametro_id
  FROM asesores a
), targets AS (
  -- Choose up to 3 clients per asesor; if fewer exist, reuse the first
  SELECT a.asesor_id,
         COALESCE(c1.cliente_id, c_any.id) AS cli1,
         COALESCE(c2.cliente_id, COALESCE(c1.cliente_id, c_any.id)) AS cli2,
         COALESCE(c3.cliente_id, COALESCE(c1.cliente_id, c_any.id)) AS cli3,
         pp.producto_parametro_id
  FROM asesores a
  LEFT JOIN clientes_por_asesor c1 ON c1.asesor_id = a.asesor_id AND c1.rn = 1
  LEFT JOIN clientes_por_asesor c2 ON c2.asesor_id = a.asesor_id AND c2.rn = 2
  LEFT JOIN clientes_por_asesor c3 ON c3.asesor_id = a.asesor_id AND c3.rn = 3
  LEFT JOIN LATERAL (
    SELECT CAST(MIN(CAST(c.id AS text)) AS uuid) AS id FROM public.clientes c WHERE c.asesor_id = a.asesor_id
  ) c_any ON TRUE
  LEFT JOIN pp_prefer pp ON pp.asesor_id = a.asesor_id
)
INSERT INTO public.polizas (
  id, cliente_id, numero_poliza, estatus, fecha_emision, fecha_alta_sistema, forma_pago,
  prima_input, prima_moneda, prima_mxn, sa_input, sa_moneda, sa_mxn, clasificacion_actual,
  puntos_actuales, anulada_at, creado_por, creado_at, updated_at, fecha_renovacion, tipo_pago,
  dia_pago, meses_check, periodicidad_pago, producto_parametro_id
)
SELECT gen_random_uuid(), t.cli1,
       'DEMO-' || SUBSTR(t.asesor_id::text, 1, 8) || '-1',
       'EN_VIGOR', CURRENT_DATE, NOW(), 'MODO_DIRECTO',
       1000, 'MXN', 1000, NULL, NULL, NULL, 'CERO',
       0, NULL, NULL, NOW(), NOW(), NULL, NULL,
       NULL, '{}'::jsonb, NULL, t.producto_parametro_id
FROM targets t
UNION ALL
SELECT gen_random_uuid(), t.cli2,
       'DEMO-' || SUBSTR(t.asesor_id::text, 1, 8) || '-2',
       'EN_VIGOR', CURRENT_DATE, NOW(), 'MODO_DIRECTO',
       1000, 'MXN', 1000, NULL, NULL, NULL, 'CERO',
       0, NULL, NULL, NOW(), NOW(), NULL, NULL,
       NULL, '{}'::jsonb, NULL, t.producto_parametro_id
FROM targets t
UNION ALL
SELECT gen_random_uuid(), t.cli3,
       'DEMO-' || SUBSTR(t.asesor_id::text, 1, 8) || '-3',
       'EN_VIGOR', CURRENT_DATE, NOW(), 'MODO_DIRECTO',
       1000, 'MXN', 1000, NULL, NULL, NULL, 'CERO',
       0, NULL, NULL, NOW(), NOW(), NULL, NULL,
       NULL, '{}'::jsonb, NULL, t.producto_parametro_id
FROM targets t;

-- Recalculate puntos/commission cache for all new policies (triggers will also do this)
-- Optional: uncomment if bulk recalculation is desired
-- SELECT recalc_puntos_poliza_all(NULL);

COMMIT;


-- FILE: 20250914_rls_historial_costos_poliza.sql
-- RLS policies for historial_costos_poliza: permitir INSERT a roles superiores
-- Fecha: 2025-09-14

-- Habilitado en sprint 1: ALTER TABLE historial_costos_poliza ENABLE ROW LEVEL SECURITY;
-- Faltaba una policy de inserciÃ³n para supervisores/admin

DO $$ BEGIN
  PERFORM 1 FROM pg_proc WHERE proname = 'is_super_role';
  -- Si no existe la funciÃ³n, sÃ³lo creamos una policy abierta a authenticated (fallback)
END $$;

-- Limpiamos polÃ­ticas previas si hubiera
DROP POLICY IF EXISTS sel_historial_costos_poliza_super ON historial_costos_poliza;
DROP POLICY IF EXISTS ins_historial_costos_poliza_super ON historial_costos_poliza;

-- Lectura para roles superiores
CREATE POLICY sel_historial_costos_poliza_super ON historial_costos_poliza
  FOR SELECT
  TO authenticated
  USING (
    -- permitir si usuario tiene rol superior
    EXISTS (
      SELECT 1 FROM usuarios u WHERE u.id_auth = auth.uid() AND lower(u.rol) IN ('supervisor','admin')
    )
  );

-- InserciÃ³n para roles superiores (RPC aplica cambios con auth.uid())
CREATE POLICY ins_historial_costos_poliza_super ON historial_costos_poliza
  FOR INSERT
  TO authenticated
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM usuarios u WHERE u.id_auth = auth.uid() AND lower(u.rol) IN ('supervisor','admin')
    )
  );


-- FILE: 20250914_sync_poliza_moneda_with_producto.sql
-- Sync polizas.prima_moneda and sa_moneda with producto_parametros.moneda automatically
-- Fecha: 2025-09-14

-- 1) Trigger function: when producto_parametros.moneda changes, update related polizas.prima_moneda
CREATE OR REPLACE FUNCTION producto_parametros_after_update_sync_moneda()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
  v_changed boolean := false;
  v_updated int := 0;
BEGIN
  IF NEW.moneda IS DISTINCT FROM OLD.moneda THEN
    v_changed := true;
  END IF;

  IF v_changed THEN
    -- Si la nueva moneda es NULL, no forzamos sincronizaciÃ³n (sin especificaciÃ³n de moneda)
    IF NEW.moneda IS NOT NULL THEN
      -- Actualizar moneda de primas y suma asegurada de pÃ³lizas que apuntan a este producto
      UPDATE polizas
        SET prima_moneda = NEW.moneda,
            sa_moneda = NEW.moneda,
            updated_at = now()
        WHERE producto_parametro_id = NEW.id
          AND (
            prima_moneda IS DISTINCT FROM NEW.moneda
            OR sa_moneda IS DISTINCT FROM NEW.moneda
            OR sa_moneda IS NULL
          );
    END IF;

    -- Recalcular cache/puntos de las pÃ³lizas afectadas
    PERFORM recalc_polizas_by_producto_parametro(NEW.id);
  END IF;
  RETURN NEW;
END;
$$;

-- 2) Adjuntar a un trigger AFTER UPDATE en producto_parametros (reutilizamos el trigger existente agregando una segunda funciÃ³n o creamos otro)
DROP TRIGGER IF EXISTS trg_producto_parametros_after_update_sync_moneda ON producto_parametros;
CREATE TRIGGER trg_producto_parametros_after_update_sync_moneda
AFTER UPDATE ON producto_parametros
FOR EACH ROW EXECUTE FUNCTION producto_parametros_after_update_sync_moneda();

-- 3) Enforce at write-time: BEFORE INSERT/UPDATE on polizas to align moneda with producto_parametros.moneda
CREATE OR REPLACE FUNCTION polizas_before_insupd_enforce_moneda()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
  v_moneda moneda_poliza;
BEGIN
  IF NEW.producto_parametro_id IS NOT NULL THEN
    SELECT moneda INTO v_moneda FROM producto_parametros WHERE id = NEW.producto_parametro_id;
    IF v_moneda IS NOT NULL THEN
      NEW.prima_moneda := v_moneda;
      NEW.sa_moneda := v_moneda;
    END IF;
  END IF;
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_polizas_before_insupd_enforce_moneda ON polizas;
CREATE TRIGGER trg_polizas_before_insupd_enforce_moneda
BEFORE INSERT OR UPDATE ON polizas
FOR EACH ROW EXECUTE FUNCTION polizas_before_insupd_enforce_moneda();

-- 4) One-time backfill: align existing polizas with producto_parametros.moneda and recalc affected
WITH updated_rows AS (
  UPDATE polizas p
  SET prima_moneda = pp.moneda,
      sa_moneda = pp.moneda,
      updated_at = now()
  FROM producto_parametros pp
  WHERE p.producto_parametro_id = pp.id
    AND pp.moneda IS NOT NULL
    AND (
      p.prima_moneda IS DISTINCT FROM pp.moneda
      OR p.sa_moneda IS DISTINCT FROM pp.moneda
      OR p.sa_moneda IS NULL
    )
  RETURNING p.producto_parametro_id
)
SELECT recalc_polizas_by_producto_parametro(u.producto_parametro_id)
FROM (SELECT DISTINCT producto_parametro_id FROM updated_rows WHERE producto_parametro_id IS NOT NULL) u;


-- FILE: 20250914_use_latest_fx_udi_for_points.sql
-- Migration: Use latest FX/UDI for points and commissions (ignore fecha_emision for conversion)
-- Date: 2025-09-14
-- Rationale:
--   Business rule change: Points and commissions must always be computed with the most current
--   FX (USD/MXN) and UDI values. We therefore update recalc_puntos_poliza to:
--     - Compute prima_mxn on the fly from prima_input/prima_moneda using CURRENT_DATE
--     - Compute any applied FX/UDI values using CURRENT_DATE for audit in cache.breakdown
--     - Keep year factor based on fecha_emision (vigencia) and EN_VIGOR gating as before

CREATE OR REPLACE FUNCTION public.recalc_puntos_poliza(p_poliza_id uuid)
RETURNS void
AS $$
DECLARE
  v_prima_input numeric;
  v_prima_mxn numeric;
  v_prima_moneda moneda_poliza;
  v_sa_mxn numeric;
  v_sa_input numeric;
  v_sa_moneda moneda_poliza;
  v_tipo tipo_producto;
  v_estatus estatus_poliza;
  v_pp_id uuid;
  v_year int;
  v_base_factor numeric;
  v_puntos numeric;
  v_clas tipo_clasificacion_puntos;
  v_fx numeric;
  v_udi numeric;
  v_fecha date;
  v_pp_auto uuid;
  v_sa_mxn_live numeric;
BEGIN
  -- Datos base de la pÃ³liza
  SELECT p.prima_input, p.prima_mxn, p.prima_moneda, p.sa_mxn, p.sa_input, p.sa_moneda,
         p.estatus, p.producto_parametro_id, p.fecha_emision
    INTO v_prima_input, v_prima_mxn, v_prima_moneda, v_sa_mxn, v_sa_input, v_sa_moneda,
         v_estatus, v_pp_id, v_fecha
  FROM polizas p
  WHERE p.id = p_poliza_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'poliza % no existe', p_poliza_id;
  END IF;

  -- Recalcular prima_mxn con valor ACTUAL (hoy) para puntos/comisiones
  v_prima_mxn := normalize_prima(v_prima_input, v_prima_moneda, CURRENT_DATE);

  -- Tasas aplicadas para auditorÃ­a (usando valores actuales)
  v_fx := NULL; v_udi := NULL;
  IF v_prima_moneda = 'USD'::moneda_poliza THEN
    SELECT get_fx_usd(CURRENT_DATE) INTO v_fx;
  ELSIF v_prima_moneda = 'UDI'::moneda_poliza THEN
    SELECT get_current_udi(CURRENT_DATE) INTO v_udi;
  END IF;

  -- Auto-selecciÃ³n de variante si no viene asignada (usar SA MXN con valor actual cuando aplique)
  IF v_sa_input IS NOT NULL AND v_sa_moneda IS NOT NULL THEN
    v_sa_mxn_live := normalize_prima(v_sa_input, v_sa_moneda, CURRENT_DATE);
  ELSE
    v_sa_mxn_live := NULL;
  END IF;

  IF v_pp_id IS NULL THEN
    SELECT pp.id
      INTO v_pp_auto
    FROM producto_parametros pp
    WHERE pp.activo = true
      AND (pp.moneda IS NULL OR pp.moneda = v_prima_moneda)
      AND (
        v_sa_mxn_live IS NULL
        OR (
          (pp.sa_min IS NULL OR v_sa_mxn_live >= pp.sa_min)
          AND (pp.sa_max IS NULL OR v_sa_mxn_live <= pp.sa_max)
        )
      )
    ORDER BY 
      CASE WHEN pp.moneda = v_prima_moneda THEN 0 ELSE 1 END,
      COALESCE(pp.sa_min, (-1)::numeric) DESC
    LIMIT 1;

    IF v_pp_auto IS NOT NULL THEN
      v_pp_id := v_pp_auto;
      UPDATE polizas SET producto_parametro_id = v_pp_auto, updated_at = now()
      WHERE id = p_poliza_id;
    END IF;
  END IF;

  -- Si anulada, deja en cero para puntos
  IF v_estatus = 'ANULADA'::estatus_poliza THEN
    v_puntos := 0;
    v_clas := 'CERO';
  ELSE
    -- Tipo de producto
    IF v_pp_id IS NOT NULL THEN
      SELECT tipo_producto INTO v_tipo FROM producto_parametros WHERE id = v_pp_id;
    ELSE
      v_tipo := NULL;
    END IF;

    -- ClasificaciÃ³n por rangos en MXN (con prima_mxn actualizada)
    IF v_tipo = 'GMM'::tipo_producto THEN
      IF v_prima_mxn IS NOT NULL AND v_prima_mxn >= 7500 THEN
        v_puntos := 0.5; v_clas := 'MEDIO';
      ELSE
        v_puntos := 0; v_clas := 'CERO';
      END IF;
    ELSIF v_tipo = 'VI'::tipo_producto THEN
      IF v_prima_mxn IS NULL OR v_prima_mxn < 15000 THEN
        v_puntos := 0; v_clas := 'CERO';
      ELSIF v_prima_mxn >= 150000 THEN
        v_puntos := 3; v_clas := 'TRIPLE';
      ELSIF v_prima_mxn >= 50000 THEN
        v_puntos := 2; v_clas := 'DOBLE';
      ELSE
        v_puntos := 1; v_clas := 'SIMPLE';
      END IF;
    ELSE
      -- Tipo desconocido o sin producto: coalesce a cero para cumplir NOT NULL
      v_puntos := 0; v_clas := 'CERO';
    END IF;
  END IF;

  -- AÃ±o de vigencia (sigue basado en fecha_emision)
  SELECT poliza_year_vigencia(p.fecha_emision) INTO v_year
  FROM polizas p WHERE p.id = p_poliza_id;

  -- Base factor (porcentaje anual) con lÃ³gica de duraciÃ³n y solo EN_VIGOR
  IF v_pp_id IS NOT NULL AND v_estatus = 'EN_VIGOR'::estatus_poliza THEN
    SELECT CASE
             WHEN COALESCE(duracion_anios, 9999) <= 10 THEN
               CASE LEAST(v_year, COALESCE(duracion_anios, 10))
                 WHEN 1 THEN anio_1_percent
                 WHEN 2 THEN anio_2_percent
                 WHEN 3 THEN anio_3_percent
                 WHEN 4 THEN anio_4_percent
                 WHEN 5 THEN anio_5_percent
                 WHEN 6 THEN anio_6_percent
                 WHEN 7 THEN anio_7_percent
                 WHEN 8 THEN anio_8_percent
                 WHEN 9 THEN anio_9_percent
                 WHEN 10 THEN anio_10_percent
                 ELSE NULL
               END
             ELSE
               CASE
                 WHEN v_year = 1 THEN anio_1_percent
                 WHEN v_year = 2 THEN anio_2_percent
                 WHEN v_year = 3 THEN anio_3_percent
                 WHEN v_year = 4 THEN anio_4_percent
                 WHEN v_year = 5 THEN anio_5_percent
                 WHEN v_year = 6 THEN anio_6_percent
                 WHEN v_year = 7 THEN anio_7_percent
                 WHEN v_year = 8 THEN anio_8_percent
                 WHEN v_year = 9 THEN anio_9_percent
                 WHEN v_year = 10 THEN anio_10_percent
                 ELSE anio_11_plus_percent
               END
           END
      INTO v_base_factor
    FROM producto_parametros
    WHERE id = v_pp_id;
  ELSE
    v_base_factor := NULL;
  END IF;

  -- Garantiza no-nulos antes de escribir
  v_puntos := COALESCE(v_puntos, 0);
  v_clas := COALESCE(v_clas, 'CERO');

  INSERT INTO poliza_puntos_cache (
    poliza_id, puntos_total, clasificacion, base_factor, producto_factor,
    year_factor, prima_anual_snapshot, producto_parametro_id, udi_valor, usd_fx,
    breakdown, recalculo_reason, computed_at, updated_at
  )
  SELECT p.id, v_puntos, v_clas, v_base_factor, NULL,
         v_year, v_prima_mxn, v_pp_id, v_udi, v_fx,
         jsonb_build_object(
           'year', v_year,
           'factor_base', v_base_factor,
           'producto', v_tipo,
           'prima_mxn', v_prima_mxn,
           'sa_mxn', v_sa_mxn_live,
           'prima_moneda', v_prima_moneda,
           'fx_aplicado', v_fx,
           'udi_aplicada', v_udi,
           'tasas_fecha', to_char(CURRENT_DATE, 'YYYY-MM-DD')
         ),
         'recalc', now(), now()
  FROM polizas p WHERE p.id = p_poliza_id
  ON CONFLICT (poliza_id) DO UPDATE SET
    puntos_total = EXCLUDED.puntos_total,
    clasificacion = EXCLUDED.clasificacion,
    base_factor = EXCLUDED.base_factor,
    producto_factor = EXCLUDED.producto_factor,
    year_factor = EXCLUDED.year_factor,
    prima_anual_snapshot = EXCLUDED.prima_anual_snapshot,
    producto_parametro_id = EXCLUDED.producto_parametro_id,
    udi_valor = EXCLUDED.udi_valor,
    usd_fx = EXCLUDED.usd_fx,
    breakdown = EXCLUDED.breakdown,
    recalculo_reason = EXCLUDED.recalculo_reason,
    updated_at = now();

  UPDATE polizas
  SET clasificacion_actual = v_clas,
      puntos_actuales = v_puntos,
      updated_at = now()
  WHERE id = p_poliza_id;
END;
$$ LANGUAGE plpgsql;

-- Backfill: recomputa todas las pÃ³lizas para reflejar FX/UDI actual en cache
DO $$
DECLARE
  v int;
BEGIN
  SELECT recalc_puntos_poliza_all(NULL) INTO v;
END$$;


-- FILE: 20250923_seed_producto_parametros.sql
-- Fecha: 2025-09-23
-- Ejecutable en Supabase/Postgres. Idempotente mediante ON CONFLICT.

BEGIN;

INSERT INTO producto_parametros (
  nombre_comercial, tipo_producto, moneda, duracion_anios,
  condicion_sa_tipo, sa_min, sa_max, condicion_edad_tipo, edad_min, edad_max,
  anio_1_percent, anio_2_percent, anio_3_percent, anio_4_percent, anio_5_percent,
  anio_6_percent, anio_7_percent, anio_8_percent, anio_9_percent, anio_10_percent,
  anio_11_plus_percent, puntos_multiplicador, activo, creado_por, creado_at
)
SELECT
  nombre_comercial,
  CAST(NULLIF(tipo_producto,'') AS public.tipo_producto) AS tipo_producto,
  CAST(NULLIF(moneda,'') AS public.moneda_poliza) AS moneda,
  CAST(NULLIF(duracion_anios_t,'') AS integer) AS duracion_anios,
  NULLIF(condicion_sa_tipo,'') AS condicion_sa_tipo,
  CAST(NULLIF(REPLACE(sa_min_t, ',', ''),'') AS numeric(18,2)) AS sa_min,
  CAST(NULLIF(REPLACE(sa_max_t, ',', ''),'') AS numeric(18,2)) AS sa_max,
  NULLIF(condicion_edad_tipo,'') AS condicion_edad_tipo,
  CAST(NULLIF(edad_min_t,'') AS integer) AS edad_min,
  CAST(NULLIF(edad_max_t,'') AS integer) AS edad_max,
  CAST(NULLIF(anio_1_percent_t,'') AS numeric(6,3)) AS anio_1_percent,
  CAST(NULLIF(anio_2_percent_t,'') AS numeric(6,3)) AS anio_2_percent,
  CAST(NULLIF(anio_3_percent_t,'') AS numeric(6,3)) AS anio_3_percent,
  CAST(NULLIF(anio_4_percent_t,'') AS numeric(6,3)) AS anio_4_percent,
  CAST(NULLIF(anio_5_percent_t,'') AS numeric(6,3)) AS anio_5_percent,
  CAST(NULLIF(anio_6_percent_t,'') AS numeric(6,3)) AS anio_6_percent,
  CAST(NULLIF(anio_7_percent_t,'') AS numeric(6,3)) AS anio_7_percent,
  CAST(NULLIF(anio_8_percent_t,'') AS numeric(6,3)) AS anio_8_percent,
  CAST(NULLIF(anio_9_percent_t,'') AS numeric(6,3)) AS anio_9_percent,
  CAST(NULLIF(anio_10_percent_t,'') AS numeric(6,3)) AS anio_10_percent,
  CAST(NULLIF(anio_11_plus_percent_t,'') AS numeric(6,3)) AS anio_11_plus_percent,
  1 AS puntos_multiplicador,
  COALESCE(
    CASE
      WHEN lower(NULLIF(activo_t,'')) = 'true' THEN true
      WHEN lower(NULLIF(activo_t,'')) = 'false' THEN false
      ELSE NULL
    END,
    true
  ) AS activo,
  CAST(NULLIF(creado_por,'') AS uuid) AS creado_por,
  COALESCE(CAST(NULLIF(creado_at,'') AS timestamp with time zone), now()) AS creado_at
FROM (
  VALUES
    ('STAR Temporal 1P - USD','VI','USD','1','','','','','', '65','22','0','0','0','0','0','0','0','0','0','0','1','true','',''),
    ('STAR Temporal 5P - USD','VI','USD','5','','','','','', '65','35','10','10','9','9','0','0','0','0','0','0','1','true','',''),
    ('STAR Temporal 10P <0.5 - USD','VI','USD','10','<','','500,000','','', '65','35','15','10','5','5','5','5','5','5','5','0','1','true','',''),
    ('STAR Temporal 10P >0.5 - USD','VI','USD','10','>=','','500,000','','', '65','30','15','10','5','5','5','5','5','5','5','0','1','true','',''),
    ('STAR Temporal 20P <0.5 - USD','VI','USD','20','<','','500,000','','', '65','44','15','10','5','5','5','5','5','5','5','0','1','true','',''),
    ('STAR Temporal 20P >0.5 - USD','VI','USD','20','>=','','500,000','','', '65','33','15','10','5','5','5','5','5','5','5','0','1','true','',''),
    ('STAR Temporal USD','VI','USD','65','','','','<=','18','45','44','10','10','9','9','9','9','9','9','9','2','1','true','',''),
    ('STAR Temporal USD','VI','USD','65','','','', '>','18','65','35','10','10','9','9','9','9','9','9','9','2','1','true','',''),
    ('STAR Temporal 10 <1.5 - UDI','VI','UDI','10','<','','1,500,000','','', '65','35','10','10','9','9','9','9','9','9','9','2','1','true','',''),
    ('STAR Temporal 10 >1.5 - UDI','VI','UDI','10','>=','','1,500,000','','', '65','30','15','10','5','5','5','5','5','5','5','0','1','true','',''),
    ('STAR Temporal 20<1.5 - UDI','VI','UDI','20','<','','1,500,000','','', '65','44','15','10','5','5','5','5','5','5','5','0','1','true','',''),
    ('STAR Temporal 20 >1.5 - UDI','VI','UDI','20','>=','','1,500,000','','', '65','35','15','10','5','5','5','5','5','5','5','0','1','true','',''),
    ('Se Adapta USD','VI','USD','','','','','','', '65','40','15','5','5','5','0','0','0','0','0','0','1','true','',''),
    ('Se Adapta UDI','VI','UDI','','','','','','', '65','44','15','5','5','5','0','0','0','0','0','0','1','true','',''),
    ('ORVI 99 - TP USD','VI','USD','99','','','','','', '65','44','15','10','5','5','5','5','5','5','5','2','1','true','',''),
    ('ORVI 99 - 20P USD','VI','USD','20','','','','','', '65','44','15','10','5','5','5','5','5','5','5','2','1','true','',''),
    ('ORVI 99 - 20P MAN USD','VI','USD','20','','','','','', '65','44','10','10','9','9','9','9','9','9','9','2','1','true','',''),
    ('ORVI 99 - 15P USD','VI','USD','15','','','','','', '65','35','10','10','9','9','9','9','9','9','9','2','1','true','',''),
    ('ORVI 99 - 10P USD','VI','USD','10','','','','','', '65','36','11','10','8.5','8.5','8.5','8.5','8.5','8.5','8.5','0','1','true','',''),
    ('ORVI 99 - 6P USD','VI','USD','6','','','','','', '65','20','10','5','4','4','4','0','0','0','0','0','1','true','',''),
    ('ORVI 99 - Edad 40-60 USD','VI','USD','60','','','', '>=','18','41','44','10','10','9','9','9','9','9','9','9','2','1','true','',''),
    ('ORVI 99 - Edad 42-60 USD','VI','USD','60','','','', '<=','','41','35','10','10','9','9','9','9','9','9','9','2','1','true','',''),
    ('ORVI 99 - PU USD','VI','USD','1','','','','','', '65','5','0','0','0','0','0','0','0','0','0','0','1','true','',''),
    ('ORVI 99 - 10P UDI','VI','UDI','10','','','','','', '65','35','10','10','9','9','9','9','9','9','9','2','1','true','',''),
    ('ORVI 99 - 20P <1.5 - UDI','VI','UDI','20','<','','1,500,000','','', '65','44','15','10','5','5','5','5','5','5','5','2','1','true','',''),
    ('ORVI 99 - 20P >1.5 UDI','VI','UDI','20','>=','','1,500,000','','', '65','35','15','10','5','5','5','5','5','5','5','2','1','true','',''),
    ('ORVI 99 - TP  UDI','VI','UDI','99','<','','1,500,000','','', '65','44','15','10','5','5','5','5','5','5','5','2','1','true','',''),
    ('ORVI 99 - TP UDI','VI','UDI','99','>=','','1,500,000','','', '65','35','15','10','5','5','5','5','5','5','5','2','1','true','',''),
    ('REALIZA PB - USD','VI','USD','30','','','','','', '65','44','15','10','5','5','5','5','5','5','5','0.8','1','true','',''),
    ('REALIZA PA - USD','VI','USD','30','','','','','', '65','8','0.8','0.8','0.8','0.8','0.8','0.8','0.8','0.8','0.8','0.8','1','true','',''),
    ('REALIZA PB - UDI','VI','UDI','30','','','','','', '65','44','15','10','5','5','5','5','5','5','5','0.8','1','true','',''),
    ('REALIZA PA - UDI','VI','UDI','30','','','','','', '65','8','0.8','0.8','0.8','0.8','0.8','0.8','0.8','0.8','0.8','0.8','1','true','',''),
    ('OBJETIVO VIDA CR_NV - USD','VI','USD','30','','','','','', '65','44','15','10','5','5','5','5','5','5','5','0.8','1','true','',''),
    ('OBJETIVO VIDA PA - USD','VI','USD','30','','','','','', '65','8','0.8','0.8','0.8','0.8','0.8','0.8','0.8','0.8','0.8','0.8','1','true','',''),
    ('OBJETIVO VIDA CR_NV - UDI','VI','UDI','30','','','','','', '65','44','15','10','5','5','5','5','5','5','5','0.8','1','true','',''),
    ('OBJETIVO VIDA PA - UDI','VI','UDI','30','','','','','', '65','8','0.8','0.8','0.8','0.8','0.8','0.8','0.8','0.8','0.8','0.8','1','true','',''),
    ('LEGADO PB - MXN','VI','MXN','30','','','','','', '65','44','15','10','5','5','5','5','5','5','5','1','1','true','',''),
    ('LEGADO PA - MXN','VI','MXN','30','','','','','', '65','4','4','4','4','4','2.5','2.5','2.5','2.5','2.5','2.5','1','true','',''),
    ('LEGADO PB - USD','VI','USD','30','','','','','', '65','44','15','10','5','5','5','5','5','5','5','1','1','true','',''),
    ('LEGADO PA - USD','VI','USD','30','','','','','', '65','4','4','4','4','4','2.5','2.5','2.5','2.5','2.5','2.5','1','true','',''),
    ('STAR DOTAL 5P - USD','VI','USD','5','','','','','', '65','11','5','4','4','4','0','0','0','0','0','0','1','true','',''),
    ('STAR DOTAL 10P - USD','VI','USD','10','','','','','', '65','27','9','7','5','5','5','5','5','5','5','0','1','true','',''),
    ('STAR DOTAL 15P - USD','VI','USD','15','','','','','', '65','28','9','7','5','5','5','5','5','5','5','5','1','true','',''),
    ('STAR DOTAL 20P - USD','VI','USD','20','','','','','', '65','35','12','10','5','5','5','5','5','5','5','2','1','true','',''),
    ('STAR DOTAL 10P - UDI','VI','UDI','10','','','','','', '65','30','9','8','5','5','5','5','5','5','5','0','1','true','',''),
    ('STAR DOTAL 20P - UDI','VI','UDI','20','','','','','', '65','35','12','10','5','5','5','5','5','5','5','2','1','true','',''),
    ('SEGUBECA 17_9 - USD','VI','USD','16','','','','','', '65','30','9','7','3','3','3','3','3','3','3','3','1','true','',''),
    ('SEGUBECA 8_5 - USD','VI','USD','8','','','','','', '65','15','7','3','3','3','3','3','3','3','3','3','1','true','',''),
    ('SEGUBECA 17_9 - UDI','VI','UDI','16','','','','','', '65','38','9','7','3','3','3','3','3','3','3','3','1','true','',''),
    ('SEGUBECA 8_5 - UDI','VI','UDI','8','','','','','', '65','20','8','4','3','3','3','3','3','3','3','3','1','true','',''),
    ('VIDA MUJER - USD','VI','USD','20','','','','','', '65','40','15','10','5','5','5','5','5','5','5','2','1','true','',''),
    ('VIDA MUJER - UDI','VI','UDI','20','','','','','', '65','40','15','10','5','5','5','5','5','5','5','2','1','true','',''),
    ('NUEVO PLENITUD +20P - USD','VI','USD','30','','','','','', '65','35','12','8','5','5','5','5','5','5','5','3.5','1','true','',''),
    ('NUEVO PLENITUD 10_20P - USD','VI','USD','20','','','','','', '65','30','12','8','5','5','5','5','5','5','5','3.5','1','true','',''),
    ('NUEVO PLENITUD 10P - USD','VI','USD','10','','','','','', '65','30','5','4','2','2','2','2','2','2','2','0','1','true','',''),
    ('NUEVO PLENITUD +20P - UDI','VI','UDI','30','','','','','', '65','35','12','8','5','5','5','5','5','5','5','3.5','1','true','',''),
    ('NUEVO PLENITUD 10_20P - UDI','VI','UDI','20','','','','','', '65','30','12','8','5','5','5','5','5','5','5','3.5','1','true','',''),
    ('NUEVO PLENITUD 15P - UDI','VI','UDI','15','','','','','', '65','32','5','4','2','2','2','2','2','2','2','2','1','true','',''),
    ('NUEVO PLENITUD 10P - UDI','VI','UDI','10','','','','','', '65','30','5','4','2','2','2','2','2','2','2','0','1','true','',''),
    ('IMAGINA SER +20P - USD','VI','USD','30','','','','','', '65','35','12','8','5','5','5','5','5','5','5','3.5','1','true','',''),
    ('IMAGINA SER 10_20P - USD','VI','USD','20','','','','','', '65','30','12','8','5','5','5','5','5','5','5','3.5','1','true','',''),
    ('IMAGINA SER PU - USD','VI','USD','1','','','','','', '65','8.5','0','0','0','0','0','0','0','0','0','0','1','true','',''),
    ('IMAGINA SER PP - USD','VI','USD','1','','','','','', '65','0.8','0','0','0','0','0','0','0','0','0','0','1','true','',''),
    ('IMAGINA SER +20P - UDI','VI','UDI','30','','','','','', '65','35','12','8','5','5','5','5','5','5','5','3.5','1','true','',''),
    ('IMAGINA SER 10_20P - UDI','VI','UDI','20','','','','','', '65','30','12','8','5','5','5','5','5','5','5','3.5','1','true','',''),
    ('IMAGINA SER PU - UDI','VI','UDI','1','','','','','', '65','8.5','0','0','0','0','0','0','0','0','0','0','1','true','',''),
    ('IMAGINA SER PP - UDI','VI','UDI','1','','','','','', '65','0.8','0','0','0','0','0','0','0','0','0','0','1','true','',''),
    ('RESPALDO EDUCATIVO - USD','VI','USD','18','','','','','', '65','35','10','10','9','9','0','0','0','0','0','0','1','true','',''),
    ('RESPALDO NEGOCIO - USD','VI','USD','20','','','','','', '65','35','10','10','9','9','0','0','0','0','0','0','1','true','',''),
    ('INTERNACIONAL - USD - NIÃ‘OS','GMM','USD','1','','','','','0','4','17','15','15','15','15','15','15','15','15','15','15','1','true','',''),
    ('INTERNACIONAL - USD - ADULTO','GMM','USD','1','','','','','5','59','25','17','17','17','17','17','17','17','17','17','17','1','true','',''),
    ('INTERNACIONAL - USD - ADULTO MAYOR','GMM','USD','1','','','','','60','99','10','10','10','10','10','10','10','10','10','10','10','1','true','',''),
    ('AM FLEX A - NIÃ‘OS','GMM','MXN','1','','','','','0','4','15','13','13','13','13','13','13','13','13','13','13','1','true','',''),
    ('AM FLEX A - ADULTO 1','GMM','MXN','1','','','','','5','54','30','17','17','17','17','17','17','17','17','17','17','1','true','',''),
    ('AM FLEX A - ADULTO 2','GMM','MXN','1','','','','','55','59','13','13','13','13','13','13','13','13','13','13','13','1','true','',''),
    ('AM FLEX A - ADULTO MAYOR','GMM','MXN','1','','','','','60','99','10','10','10','10','10','10','10','10','10','10','10','1','true','',''),
    ('AM FLEX AA - NIÃ‘OS','GMM','MXN','1','','','','','0','4','15','13','13','13','13','13','13','13','13','13','13','1','true','',''),
    ('AM FLEX AA - ADULTO 1','GMM','MXN','1','','','','','5','54','30','17','17','17','17','17','17','17','17','17','17','1','true','',''),
    ('AM FLEX AA - ADULTO 2','GMM','MXN','1','','','','','55','59','13','13','13','13','13','13','13','13','13','13','13','1','true','',''),
    ('AM FLEX AA - ADULTO MAYOR','GMM','MXN','1','','','','','60','99','10','10','10','10','10','10','10','10','10','10','10','1','true','',''),
    ('AM FLEX AAA - NIÃ‘OS','GMM','MXN','1','','','','','0','4','15','13','13','13','13','13','13','13','13','13','13','1','true','',''),
    ('AM FLEX AAA - ADULTO 1','GMM','MXN','1','','','','','5','54','30','17','17','17','17','17','17','17','17','17','17','1','true','',''),
    ('AM FLEX AAA - ADULTO 2','GMM','MXN','1','','','','','55','59','13','13','13','13','13','13','13','13','13','13','13','1','true','',''),
    ('AM FLEX AAA - ADULTO MAYOR','GMM','MXN','1','','','','','60','99','10','10','10','10','10','10','10','10','10','10','10','1','true','',''),
    ('AM FLEX PREFERENTE - NIÃ‘OS','GMM','MXN','1','','','','','0','4','15','13','13','13','13','13','13','13','13','13','13','1','true','',''),
    ('AM FLEX PREFERENTE - ADULTO 1','GMM','MXN','1','','','','','5','54','30','17','17','17','17','17','17','17','17','17','17','1','true','',''),
    ('AM FLEX PREFERENTE - ADULTO 2','GMM','MXN','1','','','','','55','59','13','13','13','13','13','13','13','13','13','13','13','1','true','',''),
    ('AM FLEX PREFERENTE - ADULTO MAYOR','GMM','MXN','1','','','','','60','99','10','10','10','10','10','10','10','10','10','10','10','1','true','',''),
    ('PRACTICO - NIÃ‘OS','GMM','MXN','1','','','','','0','4','17','15','15','15','15','15','15','15','15','15','15','1','true','',''),
    ('PRACTICO - ADULTO 1','GMM','MXN','1','','','','','5','54','25','17','17','17','17','17','17','17','17','17','17','1','true','',''),
    ('PRACTICO - ADULTO 2','GMM','MXN','1','','','','','55','59','13','13','13','13','13','13','13','13','13','13','13','1','true','',''),
    ('PRACTICO - ADULTO MAYOR','GMM','MXN','1','','','','','60','99','10','10','10','10','10','10','10','10','10','10','10','1','true','',''),
    ('PRACTICO TOTAL - NIÃ‘OS','GMM','MXN','1','','','','','0','4','17','15','15','15','15','15','15','15','15','15','15','1','true','',''),
    ('PRACTICO TOTAL - ADULTO 1','GMM','MXN','1','','','','','5','54','25','17','17','17','17','17','17','17','17','17','17','1','true','',''),
    ('PRACTICO TOTAL - ADULTO 2','GMM','MXN','1','','','','','55','59','13','13','13','13','13','13','13','13','13','13','13','1','true','',''),
    ('PRACTICO TOTAL - ADULTO MAYOR','GMM','MXN','1','','','','','60','99','10','10','10','10','10','10','10','10','10','10','10','1','true','',''),
    ('PLENO - NIÃ‘OS','GMM','MXN','1','','','','','0','4','17','15','15','15','15','15','15','15','15','15','15','1','true','',''),
    ('PLENO - ADULTO 1','GMM','MXN','1','','','','','5','54','25','17','17','17','17','17','17','17','17','17','17','1','true','',''),
    ('PLENO - ADULTO 2','GMM','MXN','1','','','','','55','59','13','13','13','13','13','13','13','13','13','13','13','1','true','',''),
    ('PLENO - ADULTO MAYOR','GMM','MXN','1','','','','','60','99','10','10','10','10','10','10','10','10','10','10','10','1','true','',''),
    ('PLENO NOVO - NIÃ‘OS','GMM','MXN','1','','','','','0','4','17','15','15','15','15','15','15','15','15','15','15','1','true','',''),
    ('PLENO NOVO - ADULTO 1','GMM','MXN','1','','','','','5','54','25','17','17','17','17','17','17','17','17','17','17','1','true','',''),
    ('PLENO NOVO - ADULTO 2','GMM','MXN','1','','','','','55','59','13','13','13','13','13','13','13','13','13','13','13','1','true','',''),
    ('PLENO NOVO - ADULTO MAYOR','GMM','MXN','1','','','','','60','99','10','10','10','10','10','10','10','10','10','10','10','1','true','',''),
    ('PLENO MONTERREY - NIÃ‘OS','GMM','MXN','1','','','','','0','4','17','15','15','15','15','15','15','15','15','15','15','1','true','',''),
    ('PLENO MONTERREY - ADULTO 1','GMM','MXN','1','','','','','5','54','25','17','17','17','17','17','17','17','17','17','17','1','true','',''),
    ('PLENO MONTERREY - ADULTO 2','GMM','MXN','1','','','','','55','59','13','13','13','13','13','13','13','13','13','13','13','1','true','',''),
    ('PLENO MONTERREY - ADULTO MAYOR','GMM','MXN','1','','','','','60','99','10','10','10','10','10','10','10','10','10','10','10','1','true','',''),
    ('PLENO OCCIDENTE - NIÃ‘OS','GMM','MXN','1','','','','','0','4','17','15','15','15','15','15','15','15','15','15','15','1','true','',''),
    ('PLENO OCCIDENTE - ADULTO 1','GMM','MXN','1','','','','','5','54','25','17','17','17','17','17','17','17','17','17','17','1','true','',''),
    ('PLENO OCIDENTE - ADULTO 2','GMM','MXN','1','','','','','55','59','13','13','13','13','13','13','13','13','13','13','13','1','true','',''),
    ('PLENO OCCIDENTE - ADULTO MAYOR','GMM','MXN','1','','','','','60','99','10','10','10','10','10','10','10','10','10','10','10','1','true','',''),
    ('INTEGRO - NIÃ‘OS','GMM','MXN','1','','','','','0','4','17','15','15','15','15','15','15','15','15','15','15','1','true','',''),
    ('INTEGRO - ADULTO 1','GMM','MXN','1','','','','','5','54','25','17','17','17','17','17','17','17','17','17','17','1','true','',''),
    ('INTEGRO - ADULTO 2','GMM','MXN','1','','','','','55','59','13','13','13','13','13','13','13','13','13','13','13','1','true','',''),
    ('INTEGRO - ADULTO MAYOR','GMM','MXN','1','','','','','60','99','10','10','10','10','10','10','10','10','10','10','10','1','true','',''),
    ('ORIGINA - NIÃ‘OS','GMM','MXN','1','','','','','0','4','17','15','15','15','15','15','15','15','15','15','15','1','true','',''),
    ('ORIGINA - ADULTO 1','GMM','MXN','1','','','','','5','54','25','17','17','17','17','17','17','17','17','17','17','1','true','',''),
    ('ORIGINA - ADULTO 2','GMM','MXN','1','','','','','55','59','13','13','13','13','13','13','13','13','13','13','13','1','true','',''),
    ('ORIGINA - ADULTO MAYOR','GMM','MXN','1','','','','','60','99','10','10','10','10','10','10','10','10','10','10','10','1','true','',''),
    ('ORIGINA 1 - NIÃ‘OS','GMM','MXN','1','','','','','0','4','17','15','15','15','15','15','15','15','15','15','15','1','true','',''),
    ('ORIGINA 1 - ADULTO 1','GMM','MXN','1','','','','','5','54','25','17','17','17','17','17','17','17','17','17','17','1','true','',''),
    ('ORIGINA 1 - ADULTO 2','GMM','MXN','1','','','','','55','59','13','13','13','13','13','13','13','13','13','13','13','1','true','',''),
    ('ORIGINA 1 - ADULTO MAYOR','GMM','MXN','1','','','','','60','99','10','10','10','10','10','10','10','10','10','10','10','1','true','',''),
    ('VIDA GRUPO T1 10_299','VI','MXN','1','','','','','', '', '23','23','23','23','23','23','23','23','23','23','23','1','true','',''),
    ('VIDA GRUPO T1 300_599','VI','MXN','1','','','','','', '', '20','20','20','20','20','20','20','20','20','20','20','1','true','',''),
    ('VIDA GRUPO T1 600_999','VI','MXN','1','','','','','', '', '15','15','15','15','15','15','15','15','15','15','15','1','true','',''),
    ('VIDA GRUPO T2 10_299','VI','MXN','2','','','','','', '', '23','23','23','23','23','23','23','23','23','23','23','1','true','',''),
    ('VIDA GRUPO T2 300_599','VI','MXN','2','','','','','', '', '20','20','20','20','20','20','20','20','20','20','20','1','true','',''),
    ('VIDA GRUPO T2 600_999','VI','MXN','2','','','','','', '', '15','15','15','15','15','15','15','15','15','15','15','1','true','',''),
    ('GMM GRUPO ESTÃNDAR','GMM','MXN','1','','','','','', '', '18','18','18','18','18','18','18','18','18','18','18','1','true','',''),
    ('GMM GRUPO OPTIMA','GMM','MXN','1','','','','','', '', '18','18','18','18','18','18','18','18','18','18','18','1','true','',''),
    ('GMM GRUPO MÃXIMA','GMM','MXN','1','','','','','', '', '18','18','18','18','18','18','18','18','18','18','18','1','true','','')
) AS v_raw(
  nombre_comercial, tipo_producto, moneda, duracion_anios_t, condicion_sa_tipo,
  sa_min_t, sa_max_t, condicion_edad_tipo, edad_min_t, edad_max_t,
  anio_1_percent_t, anio_2_percent_t, anio_3_percent_t, anio_4_percent_t, anio_5_percent_t,
  anio_6_percent_t, anio_7_percent_t, anio_8_percent_t, anio_9_percent_t, anio_10_percent_t,
  anio_11_plus_percent_t, puntos_multiplicador_t, activo_t, creado_por, creado_at
)
ON CONFLICT (
  nombre_comercial, moneda_key, duracion_anios_key,
  condicion_sa_tipo_key, sa_min_key, sa_max_key,
  condicion_edad_tipo_key, edad_min_key, edad_max_key
)
DO UPDATE SET
  anio_1_percent = EXCLUDED.anio_1_percent,
  anio_2_percent = EXCLUDED.anio_2_percent,
  anio_3_percent = EXCLUDED.anio_3_percent,
  anio_4_percent = EXCLUDED.anio_4_percent,
  anio_5_percent = EXCLUDED.anio_5_percent,
  anio_6_percent = EXCLUDED.anio_6_percent,
  anio_7_percent = EXCLUDED.anio_7_percent,
  anio_8_percent = EXCLUDED.anio_8_percent,
  anio_9_percent = EXCLUDED.anio_9_percent,
  anio_10_percent = EXCLUDED.anio_10_percent,
  anio_11_plus_percent = EXCLUDED.anio_11_plus_percent,
  puntos_multiplicador = EXCLUDED.puntos_multiplicador,
  activo = COALESCE(EXCLUDED.activo, producto_parametros.activo);

COMMIT;


-- FILE: 20250929_add_pop_fields_to_candidatos.sql
-- Migration: add POP related fields to candidatos
-- Adds textual POP identifier and fecha_creacion_pop date field.
-- Safe to run multiple times (IF NOT EXISTS guards where possible).

-- Simple add (ejecutar una sola vez); si la columna existe fallarÃ¡ y deberÃ¡s borrar esta migraciÃ³n.
ALTER TABLE public.candidatos ADD COLUMN pop text;
ALTER TABLE public.candidatos ADD COLUMN fecha_creacion_pop date;

-- Optional: comment for documentation
COMMENT ON COLUMN public.candidatos.pop IS 'Identificador POP del candidato';
COMMENT ON COLUMN public.candidatos.fecha_creacion_pop IS 'Fecha de creaciÃ³n del POP (aaaa-mm-dd)';


-- FILE: 20250929_add_ya_es_cliente_estado.sql
-- Agrega nuevo estado 'ya_es_cliente' a la restricciÃ³n CHECK de prospectos
ALTER TABLE prospectos
  DROP CONSTRAINT IF EXISTS prospectos_estado_check;

-- Nombrar de forma consistente (Postgres genera nombre automÃ¡tico si no se especificÃ³; aseguramos uno explÃ­cito)
ALTER TABLE prospectos
  ADD CONSTRAINT prospectos_estado_check
  CHECK (estado IN ('pendiente','seguimiento','con_cita','descartado','ya_es_cliente'));

-- Opcional: actualizar filas antiguas que llegasen a tener el nuevo valor (no aplica aquÃ­)
-- UPDATE prospectos SET estado='ya_es_cliente' WHERE estado='cliente'; -- ejemplo si hubiera valor previo distinto


-- FILE: 20251016_phase4_agenda_base.sql
-- Fase 4: estructura base para sistema de agendado interno

DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'meeting_provider') THEN
        CREATE TYPE meeting_provider AS ENUM ('google_meet', 'zoom', 'teams');
    END IF;
END
$$;

DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'cita_estado') THEN
        CREATE TYPE cita_estado AS ENUM ('confirmada', 'cancelada');
    END IF;
END
$$;

ALTER TABLE prospectos
    ADD COLUMN IF NOT EXISTS origen text,
    ADD COLUMN IF NOT EXISTS first_visit_at timestamptz,
    ADD COLUMN IF NOT EXISTS cita_creada boolean DEFAULT false;

CREATE TABLE IF NOT EXISTS tokens_integracion (
    id bigserial PRIMARY KEY,
    usuario_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    proveedor text NOT NULL CHECK (proveedor IN ('google', 'microsoft', 'zoom')),
    access_token text NOT NULL,
    refresh_token text,
    expires_at timestamptz,
    scopes text[],
    created_at timestamptz DEFAULT timezone('utc', now()),
    updated_at timestamptz DEFAULT timezone('utc', now()),
    CONSTRAINT tokens_integracion_usuario_proveedor UNIQUE (usuario_id, proveedor)
);

ALTER TABLE public.usuarios
    ADD COLUMN IF NOT EXISTS is_desarrollador boolean DEFAULT false;

CREATE TABLE IF NOT EXISTS citas (
    id bigserial PRIMARY KEY,
    prospecto_id bigint REFERENCES prospectos(id) ON DELETE SET NULL,
    agente_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE RESTRICT,
    supervisor_id uuid REFERENCES auth.users(id) ON DELETE RESTRICT,
    inicio timestamptz NOT NULL,
    fin timestamptz NOT NULL,
    meeting_url text NOT NULL,
    meeting_provider meeting_provider NOT NULL,
    external_event_id text,
    estado cita_estado NOT NULL DEFAULT 'confirmada',
    created_at timestamptz DEFAULT timezone('utc', now()),
    updated_at timestamptz DEFAULT timezone('utc', now())
);

CREATE INDEX IF NOT EXISTS citas_agente_inicio_idx ON citas (agente_id, inicio);
CREATE INDEX IF NOT EXISTS citas_supervisor_inicio_idx ON citas (supervisor_id, inicio);

CREATE TABLE IF NOT EXISTS logs_integracion (
    id bigserial PRIMARY KEY,
    usuario_id uuid,
    proveedor text,
    operacion text,
    nivel text,
    detalle jsonb,
    created_at timestamptz DEFAULT timezone('utc', now())
);

CREATE INDEX IF NOT EXISTS logs_integracion_created_idx ON logs_integracion (created_at DESC);

CREATE OR REPLACE VIEW citas_ocupadas AS
    SELECT agente_id AS usuario_id, inicio, fin
    FROM citas
    WHERE estado = 'confirmada'
    UNION ALL
    SELECT supervisor_id AS usuario_id, inicio, fin
    FROM citas
    WHERE estado = 'confirmada' AND supervisor_id IS NOT NULL;


-- FILE: 20251019_add_email_to_prospectos.sql
-- AÃ±ade columna de correo electrÃ³nico para prospectos
ALTER TABLE prospectos
  ADD COLUMN IF NOT EXISTS email text;

-- Ãndice simple para bÃºsquedas por correo (opcional, omite si ya existe)
CREATE INDEX IF NOT EXISTS idx_prospectos_email ON prospectos(email);


-- FILE: 20251019_clientes_soft_delete.sql
-- Soft delete support for clientes

alter table clientes
  add column if not exists activo boolean not null default true;

alter table clientes
  add column if not exists inactivado_at timestamptz null;

alter table clientes
  add column if not exists inactivado_por integer null references public.usuarios(id);

create index if not exists idx_clientes_activo on clientes(activo);


-- FILE: 20251019_transfer_usuario_soft_delete.sql
-- Soft delete support for producto_parametros and reassignment helper for usuario eliminations

create or replace function transfer_reassign_usuario(p_old_id bigint, p_new_id bigint, p_actor_email text default null)
returns json
language plpgsql
as $$
declare
  old_usr record;
  new_usr record;
  moved_prospectos bigint := 0;
  moved_planificaciones bigint := 0;
  moved_agente_meta bigint := 0;
  moved_clientes bigint := 0;
  moved_citas_agente bigint := 0;
  moved_citas_super bigint := 0;
begin
  if p_old_id = p_new_id then
    raise exception 'El usuario destino debe ser diferente al usuario original';
  end if;

  select id, email, rol, activo, id_auth into old_usr from usuarios where id = p_old_id;
  if not found then
    raise exception 'Usuario origen no existe';
  end if;

  select id, email, rol, activo, id_auth into new_usr from usuarios where id = p_new_id;
  if not found then
    raise exception 'Usuario destino no existe';
  end if;
  if not new_usr.activo then
    raise exception 'El usuario destino no estÃ¡ activo';
  end if;
  if new_usr.id_auth is null then
    raise exception 'Usuario destino no tiene id_auth asignado';
  end if;

  update prospectos
     set agente_id = new_usr.id
   where agente_id = old_usr.id;
  get diagnostics moved_prospectos = row_count;

  update planificaciones
     set agente_id = new_usr.id
   where agente_id = old_usr.id;
  get diagnostics moved_planificaciones = row_count;

  update agente_meta
     set usuario_id = new_usr.id
   where usuario_id = old_usr.id;
  get diagnostics moved_agente_meta = row_count;

  if old_usr.id_auth is not null then
    update clientes
       set asesor_id = new_usr.id_auth
     where asesor_id = old_usr.id_auth;
    get diagnostics moved_clientes = row_count;

    update citas
       set agente_id = new_usr.id_auth
     where agente_id = old_usr.id_auth;
    get diagnostics moved_citas_agente = row_count;

    update citas
       set supervisor_id = new_usr.id_auth
     where supervisor_id = old_usr.id_auth;
    get diagnostics moved_citas_super = row_count;
  end if;

  delete from usuarios where id = old_usr.id;

  return json_build_object(
    'prospectos', moved_prospectos,
    'planificaciones', moved_planificaciones,
    'agente_meta', moved_agente_meta,
    'clientes', moved_clientes,
    'citas_agente', moved_citas_agente,
    'citas_supervisor', moved_citas_super
  );
end;
$$;

create index if not exists idx_producto_parametros_activo on producto_parametros(activo);


-- FILE: 20251020_tokens_integracion_teams.sql
-- Permitir proveedor 'teams' en tokens_integracion y migrar 'microsoft' existentes

ALTER TABLE tokens_integracion
    DROP CONSTRAINT IF EXISTS tokens_integracion_proveedor_check;

UPDATE tokens_integracion
SET proveedor = 'teams'
WHERE proveedor = 'microsoft';

ALTER TABLE tokens_integracion
    ADD CONSTRAINT tokens_integracion_proveedor_check
    CHECK (proveedor IN ('google', 'zoom', 'teams'));


-- FILE: 20251111_phase5_campaigns_segments.sql
-- Phase 5: Segments, Campaigns, Product Types
-- MigraciÃ³n base para el sistema de campaÃ±as declarativas
-- Incluye: segments, user_segments, product_types, campaigns, campaign_rules,
-- campaign_rewards, campaign_segments, campaign_progress
-- Fecha: 2025-11-11
set check_function_bodies = off;

-- Ensure UUID generation helpers are available
create extension if not exists "pgcrypto" with schema public;

-- -----------------------------------------------------------------------------
-- 1. Catalogs & Segmentation
-- -----------------------------------------------------------------------------
create table if not exists public.segments (
    id uuid primary key default gen_random_uuid(),
    name text not null unique,
    description text,
    active boolean not null default true,
    created_at timestamptz not null default timezone('utc'::text, now()),
    updated_at timestamptz not null default timezone('utc'::text, now())
);

create trigger trg_segments_set_updated_at
    before update on public.segments
    for each row
    execute function public.set_updated_at();

create table if not exists public.user_segments (
    usuario_id bigint not null references public.usuarios(id) on delete cascade,
    segment_id uuid not null references public.segments(id) on delete cascade,
    assigned_by bigint references public.usuarios(id),
    assigned_at timestamptz not null default timezone('utc'::text, now()),
    primary key (usuario_id, segment_id)
);

-- -----------------------------------------------------------------------------
-- 2. Product Types catalog (dynamic replacement for enum tipo_producto)
-- -----------------------------------------------------------------------------
create table if not exists public.product_types (
    id uuid primary key default gen_random_uuid(),
    code text not null unique,
    name text not null,
    description text,
    active boolean not null default true,
    created_at timestamptz not null default timezone('utc'::text, now()),
    updated_at timestamptz not null default timezone('utc'::text, now())
);

create trigger trg_product_types_set_updated_at
    before update on public.product_types
    for each row
    execute function public.set_updated_at();

alter table public.producto_parametros
    add column if not exists product_type_id uuid;

insert into public.product_types (code, name, description)
values
    ('VI', 'Vida Individual', 'Tipo migrado desde enum tipo_producto'),
    ('GMM', 'Gastos MÃ©dicos Mayores', 'Tipo migrado desde enum tipo_producto')
on conflict (code) do nothing;

update public.producto_parametros pp
set product_type_id = pt.id
from public.product_types pt
where pt.code = pp.tipo_producto::text
  and (pp.product_type_id is null);

alter table public.producto_parametros
    alter column product_type_id set not null,
    add constraint producto_parametros_product_type_fk
        foreign key (product_type_id) references public.product_types(id);

-- -----------------------------------------------------------------------------
-- 3. Campaigns core entities
-- -----------------------------------------------------------------------------
create type public.campaign_status as enum ('draft', 'active', 'paused', 'archived');
create type public.campaign_progress_status as enum ('not_eligible', 'eligible', 'completed');

create table public.campaigns (
    id uuid primary key default gen_random_uuid(),
    slug text not null unique,
    name text not null,
    summary text,
    description text,
    status public.campaign_status not null default 'draft',
    active_range daterange not null,
    primary_segment_id uuid references public.segments(id),
    notes text,
    created_by bigint references public.usuarios(id),
    created_at timestamptz not null default timezone('utc'::text, now()),
    updated_at timestamptz not null default timezone('utc'::text, now())
);

create trigger trg_campaigns_set_updated_at
    before update on public.campaigns
    for each row
    execute function public.set_updated_at();

create table public.campaign_rules (
    id uuid primary key default gen_random_uuid(),
    campaign_id uuid not null references public.campaigns(id) on delete cascade,
    scope text not null check (scope in ('eligibility', 'goal')),
    rule_kind text not null,
    config jsonb not null,
    priority integer not null default 0,
    description text,
    created_at timestamptz not null default timezone('utc'::text, now()),
    updated_at timestamptz not null default timezone('utc'::text, now())
);

create index campaign_rules_campaign_scope_idx
    on public.campaign_rules (campaign_id, scope, priority);

create trigger trg_campaign_rules_set_updated_at
    before update on public.campaign_rules
    for each row
    execute function public.set_updated_at();

create table public.campaign_rewards (
    id uuid primary key default gen_random_uuid(),
    campaign_id uuid not null references public.campaigns(id) on delete cascade,
    title text not null,
    description text,
    is_accumulative boolean not null default false,
    sort_order integer not null default 0,
    created_at timestamptz not null default timezone('utc'::text, now()),
    updated_at timestamptz not null default timezone('utc'::text, now())
);

create index campaign_rewards_campaign_idx
    on public.campaign_rewards (campaign_id, sort_order);

create trigger trg_campaign_rewards_set_updated_at
    before update on public.campaign_rewards
    for each row
    execute function public.set_updated_at();

create table public.campaign_segments (
    campaign_id uuid not null references public.campaigns(id) on delete cascade,
    segment_id uuid not null references public.segments(id) on delete cascade,
    sort_order integer not null default 0,
    primary key (campaign_id, segment_id)
);

create table public.campaign_progress (
    id uuid primary key default gen_random_uuid(),
    campaign_id uuid not null references public.campaigns(id) on delete cascade,
    usuario_id bigint not null references public.usuarios(id) on delete cascade,
    eligible boolean not null default false,
    progress numeric(6,3) not null default 0,
    status public.campaign_progress_status not null default 'not_eligible',
    metrics jsonb,
    evaluated_at timestamptz not null default timezone('utc'::text, now()),
    created_at timestamptz not null default timezone('utc'::text, now()),
    updated_at timestamptz not null default timezone('utc'::text, now()),
    constraint campaign_progress_progress_range check (progress >= 0)
);

create unique index campaign_progress_unique_idx
    on public.campaign_progress (campaign_id, usuario_id);

create trigger trg_campaign_progress_set_updated_at
    before update on public.campaign_progress
    for each row
    execute function public.set_updated_at();

-- -----------------------------------------------------------------------------
-- 4. Row Level Security
-- -----------------------------------------------------------------------------
alter table public.segments enable row level security;
alter table public.user_segments enable row level security;
alter table public.product_types enable row level security;
alter table public.campaigns enable row level security;
alter table public.campaign_rules enable row level security;
alter table public.campaign_rewards enable row level security;
alter table public.campaign_segments enable row level security;
alter table public.campaign_progress enable row level security;

create policy segments_select_all on public.segments
    for select using (true);

create policy segments_manage_super on public.segments
    for all
    using (public.is_super_role())
    with check (public.is_super_role());

create policy user_segments_super_manage on public.user_segments
    for all
    using (public.is_super_role())
    with check (public.is_super_role());

create policy product_types_select_all on public.product_types
    for select using (true);

create policy product_types_manage_super on public.product_types
    for all
    using (public.is_super_role())
    with check (public.is_super_role());

create policy campaigns_select_all on public.campaigns
    for select using (true);

create policy campaigns_manage_super on public.campaigns
    for all
    using (public.is_super_role())
    with check (public.is_super_role());

create policy campaign_rules_select_all on public.campaign_rules
    for select using (true);

create policy campaign_rules_manage_super on public.campaign_rules
    for all
    using (public.is_super_role())
    with check (public.is_super_role());

create policy campaign_rewards_select_all on public.campaign_rewards
    for select using (true);

create policy campaign_rewards_manage_super on public.campaign_rewards
    for all
    using (public.is_super_role())
    with check (public.is_super_role());

create policy campaign_segments_select_all on public.campaign_segments
    for select using (true);

create policy campaign_segments_manage_super on public.campaign_segments
    for all
    using (public.is_super_role())
    with check (public.is_super_role());

create policy campaign_progress_select_all on public.campaign_progress
    for select using (true);

create policy campaign_progress_manage_super on public.campaign_progress
    for all
    using (public.is_super_role())
    with check (public.is_super_role());

-- -----------------------------------------------------------------------------
-- 5. Comments & metadata (optional but useful)
-- -----------------------------------------------------------------------------
comment on table public.segments is 'Dynamic user segments for campaign targeting and UI grouping';
comment on table public.user_segments is 'Assignments of usuarios to custom segments';
comment on table public.product_types is 'Catalog of dynamic product types for producto_parametros';
comment on column public.producto_parametros.product_type_id is 'FK to product_types, replaces enum tipo_producto';
comment on table public.campaigns is 'Marketing/engagement campaigns managed by supervisors';
comment on table public.campaign_rules is 'Rule definitions (eligibility/goal) for campaigns';
comment on table public.campaign_rewards is 'Reward catalog per campaign';
comment on table public.campaign_segments is 'Explicit segment associations per campaign';
comment on table public.campaign_progress is 'Per-usuario campaign evaluation snapshots';

-- End of migration


-- FILE: 20251112_phase5_metrics_indexes.sql
-- Phase 5: supporting indexes for reporting views
set statement_timeout = 0;

-- Ensure joins by asesor/auth_id resolve quickly when aggregating metrics
create index if not exists idx_clientes_asesor on public.clientes(asesor_id) where asesor_id is not null;
create index if not exists idx_usuarios_id_auth on public.usuarios(id_auth) where id_auth is not null;

-- Speed up temporal slices used by vw_polizas_metricas and vw_cancelaciones_indices
create index if not exists idx_polizas_fecha_emision on public.polizas(fecha_emision);
create index if not exists idx_polizas_anulada_at on public.polizas(anulada_at);
create index if not exists idx_polizas_cliente_fecha_emision on public.polizas(cliente_id, fecha_emision);
create index if not exists idx_polizas_cliente_anulada on public.polizas(cliente_id, anulada_at);


-- FILE: 20251112_phase5_metrics_views.sql
-- Phase 5: reporting views for campaigns and RC metrics
set check_function_bodies = off;

-- -----------------------------------------------------------------------------
-- vw_polizas_metricas
-- -----------------------------------------------------------------------------
drop view if exists public.vw_polizas_metricas;
create view public.vw_polizas_metricas as
with base as (
  select
    p.id as poliza_id,
    p.estatus,
    p.prima_mxn,
    p.fecha_emision,
    p.updated_at,
    p.anulada_at,
    c.asesor_id,
    u.id as usuario_id,
    u.email as usuario_email,
    u.nombre as usuario_nombre
  from public.polizas p
  join public.clientes c on c.id = p.cliente_id
  left join public.usuarios u on u.id_auth = c.asesor_id
),
cache as (
  select
    pc.poliza_id,
    pc.prima_anual_snapshot,
    pc.base_factor,
    pc.puntos_total
  from public.poliza_puntos_cache pc
)
select
  b.asesor_id,
  b.usuario_id,
  b.usuario_email,
  b.usuario_nombre,
  count(*) as polizas_total,
  count(*) filter (where b.estatus = 'EN_VIGOR') as polizas_vigentes,
  count(*) filter (where b.estatus = 'ANULADA') as polizas_anuladas,
  coalesce(sum(b.prima_mxn), 0::numeric) as prima_total_mxn,
  coalesce(sum(b.prima_mxn) filter (where b.estatus = 'EN_VIGOR'), 0::numeric) as prima_vigente_mxn,
  case when count(*) > 0
       then coalesce(sum(b.prima_mxn), 0::numeric) / count(*)
       else 0::numeric
  end as prima_promedio_mxn,
  coalesce(sum(coalesce(ca.prima_anual_snapshot, b.prima_mxn) * coalesce(ca.base_factor, 0)::numeric / 100.0), 0::numeric) as comision_base_mxn,
  coalesce(sum(coalesce(ca.puntos_total, 0)), 0::numeric) as puntos_totales,
  coalesce(sum(coalesce(ca.puntos_total, 0)), 0::numeric) as momentum_vita,
  min(b.fecha_emision) as primera_emision,
  max(b.fecha_emision) as ultima_emision,
  max(b.anulada_at) as ultima_cancelacion,
  max(b.updated_at) as ultima_actualizacion
from base b
left join cache ca on ca.poliza_id = b.poliza_id
group by b.asesor_id, b.usuario_id, b.usuario_email, b.usuario_nombre;

comment on view public.vw_polizas_metricas is 'Agregados de pÃ³lizas por asesor: conteos, primas, comisiones base y Momentum Vita (puntos acumulados).';

-- -----------------------------------------------------------------------------
-- vw_cancelaciones_indices
-- -----------------------------------------------------------------------------
drop view if exists public.vw_cancelaciones_indices;
create view public.vw_cancelaciones_indices as
with datos as (
  select
    p.id,
    c.asesor_id,
    p.fecha_emision,
    p.anulada_at
  from public.polizas p
  join public.clientes c on c.id = p.cliente_id
),
rangos as (
  select
    generate_series(
      coalesce(date_trunc('month', (select min(fecha_emision) from datos)), date_trunc('month', current_date)),
      coalesce(date_trunc('month', (select max(coalesce(anulada_at::date, fecha_emision)) from datos)), date_trunc('month', current_date)),
      interval '1 month'
    )::date as periodo
),
periodos as (
  select d.asesor_id, r.periodo, (r.periodo + interval '1 month')::date as periodo_fin
  from rangos r
  join (select distinct asesor_id from datos) d on true
)
select
  pr.asesor_id,
  u.id as usuario_id,
  u.email as usuario_email,
  u.nombre as usuario_nombre,
  pr.periodo as periodo_mes,
  extract(year from pr.periodo)::int as anio,
  extract(month from pr.periodo)::int as mes,
  count(d.*) filter (
    where d.fecha_emision >= pr.periodo
      and d.fecha_emision < pr.periodo_fin
  ) as polizas_emitidas,
  count(d.*) filter (
    where d.anulada_at is not null
      and d.anulada_at >= pr.periodo
      and d.anulada_at < pr.periodo_fin
  ) as polizas_canceladas,
  count(d.*) filter (
    where d.fecha_emision < pr.periodo_fin
      and (d.anulada_at is null or d.anulada_at >= pr.periodo_fin)
  ) as polizas_vigentes_al_cierre,
  count(d.*) filter (
    where d.anulada_at is not null
      and d.anulada_at >= pr.periodo - interval '12 months'
      and d.anulada_at < pr.periodo_fin
      and d.fecha_emision >= pr.periodo - interval '12 months'
  ) as cancelaciones_12m,
  count(d.*) filter (
    where d.fecha_emision >= pr.periodo - interval '12 months'
      and d.fecha_emision < pr.periodo_fin
  ) as emisiones_12m,
  case
    when count(d.*) filter (
           where d.fecha_emision >= pr.periodo - interval '12 months'
             and d.fecha_emision < pr.periodo_fin
         ) > 0
    then round(
           1 - (
             count(d.*) filter (
               where d.anulada_at is not null
                 and d.anulada_at >= pr.periodo - interval '12 months'
                 and d.anulada_at < pr.periodo_fin
                 and d.fecha_emision >= pr.periodo - interval '12 months'
             )::numeric
             /
             count(d.*) filter (
               where d.fecha_emision >= pr.periodo - interval '12 months'
                 and d.fecha_emision < pr.periodo_fin
             )
           ),
           4
         )
    else null
  end as indice_limra,
  case
    when count(d.*) filter (
           where d.fecha_emision < pr.periodo_fin
             and (d.anulada_at is null or d.anulada_at >= pr.periodo_fin)
         ) > 0
    then round(
           1 - (
             count(d.*) filter (
               where d.anulada_at is not null
                 and d.anulada_at >= pr.periodo
                 and d.anulada_at < pr.periodo_fin
             )::numeric
             /
             count(d.*) filter (
               where d.fecha_emision < pr.periodo_fin
                 and (d.anulada_at is null or d.anulada_at >= pr.periodo_fin)
             )
           ),
           4
         )
    else null
  end as indice_igc,
  (
    count(d.*) filter (
      where d.fecha_emision >= pr.periodo
        and d.fecha_emision < pr.periodo_fin
    )
    -
    count(d.*) filter (
      where d.anulada_at is not null
        and d.anulada_at >= pr.periodo
        and d.anulada_at < pr.periodo_fin
    )
  ) as momentum_neto
from periodos pr
left join datos d on d.asesor_id is not distinct from pr.asesor_id
  and (
    d.fecha_emision < pr.periodo_fin
    or (d.anulada_at is not null and d.anulada_at >= pr.periodo - interval '12 months')
  )
left join public.usuarios u on u.id_auth = pr.asesor_id
group by pr.asesor_id, u.id, u.email, u.nombre, pr.periodo
order by pr.periodo, pr.asesor_id;

comment on view public.vw_cancelaciones_indices is 'MÃ©tricas mensuales de pÃ³lizas emitidas, cancelaciones y persistencia (LIMRA / IGC) por asesor.';

-- -----------------------------------------------------------------------------
-- vw_rc_metricas
-- -----------------------------------------------------------------------------
drop view if exists public.vw_rc_metricas;
create view public.vw_rc_metricas as
with prospectos_agg as (
  select
    p.agente_id,
    count(*) as prospectos_total,
    count(*) filter (where p.estado in ('con_cita','seguimiento')) as reclutas_calidad,
    count(*) filter (where p.estado = 'con_cita') as prospectos_con_cita,
    count(*) filter (where p.estado = 'seguimiento') as prospectos_seguimiento,
    count(*) filter (where p.estado = 'descartado') as prospectos_descartados
  from public.prospectos p
  group by p.agente_id
),
polizas_agg as (
  select
    u.id as usuario_id,
    c.asesor_id,
    count(*) as polizas_total,
    count(*) filter (where p.estatus = 'EN_VIGOR') as polizas_vigentes,
    count(*) filter (where p.estatus = 'ANULADA') as polizas_anuladas
  from public.polizas p
  join public.clientes c on c.id = p.cliente_id
  left join public.usuarios u on u.id_auth = c.asesor_id
  group by u.id, c.asesor_id
),
usuarios_base as (
  select distinct coalesce(pa.agente_id, pol.usuario_id) as usuario_id
  from prospectos_agg pa
  full outer join polizas_agg pol on pol.usuario_id = pa.agente_id
)
select
  ub.usuario_id,
  case
    when pol.asesor_id is not null then pol.asesor_id
    when u.id_auth is not null and u.id_auth::text ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$'
      then u.id_auth
    else null
  end as asesor_auth_id,
  u.email as usuario_email,
  u.nombre as usuario_nombre,
  coalesce(pa.prospectos_total, 0) as prospectos_total,
  coalesce(pa.reclutas_calidad, 0) as reclutas_calidad,
  coalesce(pa.prospectos_con_cita, 0) as prospectos_con_cita,
  coalesce(pa.prospectos_seguimiento, 0) as prospectos_seguimiento,
  coalesce(pa.prospectos_descartados, 0) as prospectos_descartados,
  coalesce(pol.polizas_total, 0) as polizas_total,
  coalesce(pol.polizas_vigentes, 0) as polizas_vigentes,
  coalesce(pol.polizas_anuladas, 0) as polizas_anuladas,
  case
    when coalesce(pol.polizas_total, 0) > 0
      then round(coalesce(pol.polizas_vigentes, 0)::numeric / pol.polizas_total, 4)
    else null
  end as rc_vigencia,
  case
    when coalesce(pa.prospectos_total, 0) > 0
      then round(coalesce(pa.reclutas_calidad, 0)::numeric / pa.prospectos_total, 4)
    else null
  end as reclutas_calidad_ratio,
  case
    when (coalesce(pol.polizas_vigentes, 0) + coalesce(pol.polizas_anuladas, 0)) > 0
      then round(
        coalesce(pol.polizas_vigentes, 0)::numeric /
        (coalesce(pol.polizas_vigentes, 0) + coalesce(pol.polizas_anuladas, 0)),
        4
      )
    else null
  end as permanencia
from usuarios_base ub
left join prospectos_agg pa on pa.agente_id = ub.usuario_id
left join polizas_agg pol on pol.usuario_id = ub.usuario_id
left join public.usuarios u on u.id = ub.usuario_id;

comment on view public.vw_rc_metricas is 'Consolida mÃ©tricas de reclutas de calidad (prospectos) y permanencia de pÃ³lizas por usuario/asesor.';


-- FILE: 20251112_phase5_product_type_refactor.sql
-- Phase 5 follow-up: refactor puntos calculation to use product_types catalog
set check_function_bodies = off;

create or replace function public.recalc_puntos_poliza(p_poliza_id uuid)
returns void
language plpgsql
as $$
declare
  v_prima_input numeric;
  v_prima_mxn numeric;
  v_prima_moneda moneda_poliza;
  v_sa_mxn numeric;
  v_sa_input numeric;
  v_sa_moneda moneda_poliza;
  v_tipo_code text;
  v_tipo_name text;
  v_tipo_id uuid;
  v_estatus estatus_poliza;
  v_pp_id uuid;
  v_year int;
  v_base_factor numeric;
  v_puntos numeric;
  v_clas tipo_clasificacion_puntos;
  v_fx numeric;
  v_udi numeric;
  v_fecha date;
  v_pp_auto uuid;
  v_sa_mxn_live numeric;
begin
  select p.prima_input, p.prima_mxn, p.prima_moneda, p.sa_mxn, p.sa_input, p.sa_moneda,
         p.estatus, p.producto_parametro_id, p.fecha_emision
    into v_prima_input, v_prima_mxn, v_prima_moneda, v_sa_mxn, v_sa_input, v_sa_moneda,
         v_estatus, v_pp_id, v_fecha
  from polizas p
  where p.id = p_poliza_id;

  if not found then
    raise exception 'poliza % no existe', p_poliza_id;
  end if;

  v_prima_mxn := normalize_prima(v_prima_input, v_prima_moneda, current_date);

  v_fx := null; v_udi := null;
  if v_prima_moneda = 'USD'::moneda_poliza then
    select get_fx_usd(current_date) into v_fx;
  elsif v_prima_moneda = 'UDI'::moneda_poliza then
    select get_current_udi(current_date) into v_udi;
  end if;

  if v_sa_input is not null and v_sa_moneda is not null then
    v_sa_mxn_live := normalize_prima(v_sa_input, v_sa_moneda, current_date);
  else
    v_sa_mxn_live := null;
  end if;

  if v_pp_id is null then
    select pp.id
      into v_pp_auto
    from producto_parametros pp
    where pp.activo = true
      and (pp.moneda is null or pp.moneda = v_prima_moneda)
      and (
        v_sa_mxn_live is null
        or (
          (pp.sa_min is null or v_sa_mxn_live >= pp.sa_min)
          and (pp.sa_max is null or v_sa_mxn_live <= pp.sa_max)
        )
      )
    order by
      case when pp.moneda = v_prima_moneda then 0 else 1 end,
      coalesce(pp.sa_min, (-1)::numeric) desc
    limit 1;

    if v_pp_auto is not null then
      v_pp_id := v_pp_auto;
      update polizas set producto_parametro_id = v_pp_auto, updated_at = now()
      where id = p_poliza_id;
    end if;
  end if;

  if v_estatus = 'ANULADA'::estatus_poliza then
    v_puntos := 0;
    v_clas := 'CERO';
    v_tipo_code := null;
    v_tipo_name := null;
    v_tipo_id := null;
  else
    if v_pp_id is not null then
      select pt.code, pt.name, pt.id
        into v_tipo_code, v_tipo_name, v_tipo_id
      from producto_parametros pp
      join product_types pt on pt.id = pp.product_type_id
      where pp.id = v_pp_id;
    else
      v_tipo_code := null;
      v_tipo_name := null;
      v_tipo_id := null;
    end if;

    if v_tipo_code is not null then
      v_tipo_code := upper(v_tipo_code);
    end if;

    if v_tipo_code = 'GMM' then
      if v_prima_mxn is not null and v_prima_mxn >= 7500 then
        v_puntos := 0.5; v_clas := 'MEDIO';
      else
        v_puntos := 0; v_clas := 'CERO';
      end if;
    elsif v_tipo_code = 'VI' then
      if v_prima_mxn is null or v_prima_mxn < 15000 then
        v_puntos := 0; v_clas := 'CERO';
      elsif v_prima_mxn >= 150000 then
        v_puntos := 3; v_clas := 'TRIPLE';
      elsif v_prima_mxn >= 50000 then
        v_puntos := 2; v_clas := 'DOBLE';
      else
        v_puntos := 1; v_clas := 'SIMPLE';
      end if;
    else
      v_puntos := 0; v_clas := 'CERO';
    end if;
  end if;

  select poliza_year_vigencia(p.fecha_emision) into v_year
  from polizas p where p.id = p_poliza_id;

  if v_pp_id is not null and v_estatus = 'EN_VIGOR'::estatus_poliza then
    select case
             when coalesce(duracion_anios, 9999) <= 10 then
               case least(v_year, coalesce(duracion_anios, 10))
                 when 1 then anio_1_percent
                 when 2 then anio_2_percent
                 when 3 then anio_3_percent
                 when 4 then anio_4_percent
                 when 5 then anio_5_percent
                 when 6 then anio_6_percent
                 when 7 then anio_7_percent
                 when 8 then anio_8_percent
                 when 9 then anio_9_percent
                 when 10 then anio_10_percent
                 else null
               end
             else
               case
                 when v_year = 1 then anio_1_percent
                 when v_year = 2 then anio_2_percent
                 when v_year = 3 then anio_3_percent
                 when v_year = 4 then anio_4_percent
                 when v_year = 5 then anio_5_percent
                 when v_year = 6 then anio_6_percent
                 when v_year = 7 then anio_7_percent
                 when v_year = 8 then anio_8_percent
                 when v_year = 9 then anio_9_percent
                 when v_year = 10 then anio_10_percent
                 else anio_11_plus_percent
               end
           end
      into v_base_factor
    from producto_parametros
    where id = v_pp_id;
  else
    v_base_factor := null;
  end if;

  v_puntos := coalesce(v_puntos, 0);
  v_clas := coalesce(v_clas, 'CERO');

  insert into poliza_puntos_cache (
    poliza_id, puntos_total, clasificacion, base_factor, producto_factor,
    year_factor, prima_anual_snapshot, producto_parametro_id, udi_valor, usd_fx,
    breakdown, recalculo_reason, computed_at, updated_at
  )
  select p.id, v_puntos, v_clas, v_base_factor, null,
         v_year, v_prima_mxn, v_pp_id, v_udi, v_fx,
         jsonb_build_object(
           'year', v_year,
           'factor_base', v_base_factor,
           'producto', v_tipo_code,
           'producto_nombre', v_tipo_name,
           'producto_type_id', v_tipo_id,
           'prima_mxn', v_prima_mxn,
           'sa_mxn', v_sa_mxn_live,
           'prima_moneda', v_prima_moneda,
           'fx_aplicado', v_fx,
           'udi_aplicada', v_udi,
           'tasas_fecha', to_char(current_date, 'YYYY-MM-DD')
         ),
         'recalc', now(), now()
  from polizas p where p.id = p_poliza_id
  on conflict (poliza_id) do update set
    puntos_total = excluded.puntos_total,
    clasificacion = excluded.clasificacion,
    base_factor = excluded.base_factor,
    producto_factor = excluded.producto_factor,
    year_factor = excluded.year_factor,
    prima_anual_snapshot = excluded.prima_anual_snapshot,
    producto_parametro_id = excluded.producto_parametro_id,
    udi_valor = excluded.udi_valor,
    usd_fx = excluded.usd_fx,
    breakdown = excluded.breakdown,
    recalculo_reason = excluded.recalculo_reason,
    computed_at = excluded.computed_at,
    updated_at = excluded.updated_at;
end;
$$;

comment on function public.recalc_puntos_poliza(uuid)
  is 'Recalcula puntos de pÃ³liza utilizando valores actuales de FX/UDI y catÃ¡logo dinÃ¡mico de product_types.';


-- FILE: 20251112_phase5_segment_utilities.sql
-- Phase 5 follow-up: segment utilities & stricter RLS
set check_function_bodies = off;

-- -----------------------------------------------------------------------------
-- Segment assignment helpers
-- -----------------------------------------------------------------------------
create or replace function public.assign_user_segment(
  p_usuario_id bigint,
  p_segment_id uuid,
  p_assigned_by bigint default null
) returns public.user_segments
language plpgsql
security definer
set search_path = public
as $$
declare
  v_row public.user_segments%rowtype;
  v_actor bigint;
begin
  if not public.is_super_role() then
    raise exception 'permiso denegado (requiere rol supervisor o superior)';
  end if;

  v_actor := p_assigned_by;
  if v_actor is null then
    select id into v_actor from public.usuarios where id_auth = auth.uid();
  end if;

  insert into public.user_segments (usuario_id, segment_id, assigned_by)
  values (p_usuario_id, p_segment_id, v_actor)
  on conflict (usuario_id, segment_id) do update
    set assigned_by = coalesce(excluded.assigned_by, user_segments.assigned_by),
        assigned_at = timezone('utc'::text, now())
  returning * into v_row;

  return v_row;
end;
$$;

comment on function public.assign_user_segment(bigint, uuid, bigint)
  is 'Asigna un segmento a un usuario (solo para roles superiores); crea o actualiza la fila en user_segments.';

create or replace function public.assign_user_segment_by_name(
  p_usuario_id bigint,
  p_segment_name text,
  p_assigned_by bigint default null
) returns public.user_segments
language plpgsql
security definer
set search_path = public
as $$
declare
  v_segment_id uuid;
begin
  if p_segment_name is null or length(trim(p_segment_name)) = 0 then
    raise exception 'segmento invÃ¡lido';
  end if;

  select id into v_segment_id
  from public.segments
  where lower(name) = lower(trim(p_segment_name))
    and active is true
  limit 1;

  if v_segment_id is null then
    raise exception 'segmento % no encontrado o inactivo', p_segment_name;
  end if;

  return public.assign_user_segment(p_usuario_id, v_segment_id, p_assigned_by);
end;
$$;

comment on function public.assign_user_segment_by_name(bigint, text, bigint)
  is 'Wrapper de conveniencia para asignar segmentos por nombre (case-insensitive).';

create or replace function public.remove_user_segment(
  p_usuario_id bigint,
  p_segment_id uuid
) returns boolean
language plpgsql
security definer
set search_path = public
as $$
begin
  if not public.is_super_role() then
    raise exception 'permiso denegado (requiere rol supervisor o superior)';
  end if;

  delete from public.user_segments
  where usuario_id = p_usuario_id
    and segment_id = p_segment_id;

  return found;
end;
$$;

comment on function public.remove_user_segment(bigint, uuid)
  is 'Elimina una asignaciÃ³n de segmento para un usuario (solo supervisores/superiores).';

create or replace function public.remove_user_segment_by_name(
  p_usuario_id bigint,
  p_segment_name text
) returns boolean
language plpgsql
security definer
set search_path = public
as $$
declare
  v_segment_id uuid;
begin
  if p_segment_name is null or length(trim(p_segment_name)) = 0 then
    raise exception 'segmento invÃ¡lido';
  end if;

  select id into v_segment_id
  from public.segments
  where lower(name) = lower(trim(p_segment_name))
  limit 1;

  if v_segment_id is null then
    raise exception 'segmento % no encontrado', p_segment_name;
  end if;

  return public.remove_user_segment(p_usuario_id, v_segment_id);
end;
$$;

comment on function public.remove_user_segment_by_name(bigint, text)
  is 'Wrapper para remover segmentos especificando el nombre.';

-- -----------------------------------------------------------------------------
-- RLS adjustments
-- -----------------------------------------------------------------------------
-- Segments: solo visibles cuando activos (salvo roles superiores)
drop policy if exists segments_select_all on public.segments;
drop policy if exists segments_manage_super on public.segments;
drop policy if exists segments_select_visible on public.segments;

create policy segments_select_visible on public.segments
  for select
  using (active or public.is_super_role());

create policy segments_manage_super on public.segments
  for all
  using (public.is_super_role())
  with check (public.is_super_role());

-- User segments: lectura restringida al propio usuario (o superiores)
drop policy if exists user_segments_super_manage on public.user_segments;
drop policy if exists user_segments_select_all on public.user_segments;
drop policy if exists user_segments_manage_super on public.user_segments;
drop policy if exists user_segments_select_self on public.user_segments;
drop policy if exists user_segments_manage on public.user_segments;

create policy user_segments_select_self on public.user_segments
  for select
  using (
    public.is_super_role()
    or exists (
      select 1
      from public.usuarios u
      where u.id = usuario_id
        and u.id_auth = auth.uid()
    )
  );

create policy user_segments_manage_super on public.user_segments
  for all
  using (public.is_super_role())
  with check (public.is_super_role());

-- Campaign progress: permitir consultar solo propias filas o roles superiores
drop policy if exists campaign_progress_select_all on public.campaign_progress;
drop policy if exists campaign_progress_select_self on public.campaign_progress;

create policy campaign_progress_select_self on public.campaign_progress
  for select
  using (
    public.is_super_role()
    or exists (
      select 1
      from public.usuarios u
      where u.id = usuario_id
        and u.id_auth = auth.uid()
    )
  );
-- mantener polÃ­tica de gestiÃ³n para roles superiores (ya creada en migraciÃ³n previa)

-- End of migration


-- FILE: 20251113_add_mes_conexion_to_candidatos.sql
-- Add mes_conexion column to candidatos for tracking connection month
ALTER TABLE public.candidatos
  ADD COLUMN IF NOT EXISTS mes_conexion text;

COMMENT ON COLUMN public.candidatos.mes_conexion IS 'Mes de conexiÃ³n del candidato en formato YYYY-MM';

-- Backfill using existing date fields when available so previously captured data is not lost
UPDATE public.candidatos
SET mes_conexion = to_char(fecha_creacion_ct, 'YYYY-MM')
WHERE mes_conexion IS NULL
  AND fecha_creacion_ct IS NOT NULL;

UPDATE public.candidatos
SET mes_conexion = to_char(fecha_creacion_pop, 'YYYY-MM')
WHERE mes_conexion IS NULL
  AND fecha_creacion_pop IS NOT NULL;


-- FILE: 20251113_phase5_roles_normalization.sql
-- Phase 5: NormalizaciÃ³n de roles (superusuario âžœ supervisor)
set check_function_bodies = off;

alter table public.usuarios
  drop constraint if exists usuarios_rol_check;

-- -----------------------------------------------------------------------------
-- Re-map legacy role values without deleting existing data
-- -----------------------------------------------------------------------------
update public.usuarios
set rol = 'supervisor'
where rol is not null
  and lower(rol) in ('superusuario', 'super usuario', 'super_usuario', 'editor')
  and rol <> 'supervisor';

update public.usuarios
set rol = 'viewer'
where rol is not null
  and lower(rol) in ('lector')
  and rol <> 'viewer';

alter table public.usuarios
  add constraint usuarios_rol_check
  check (rol in ('admin','supervisor','viewer','agente'));


-- FILE: 20251113_phase5_segment_permissions_fix.sql
-- Phase 5: Ajuste de permisos para asignaciÃ³n de segmentos
set check_function_bodies = off;

-- -----------------------------------------------------------------------------
-- Permitir que el servicio (service_role) actÃºe en nombre de supervisores
-- -----------------------------------------------------------------------------
create or replace function public.assign_user_segment(
  p_usuario_id bigint,
  p_segment_id uuid,
  p_assigned_by bigint default null
) returns public.user_segments
language plpgsql
security definer
set search_path = public
as $$
declare
  v_row public.user_segments%rowtype;
  v_actor bigint := p_assigned_by;
  v_actor_role text;
  v_actor_active boolean;
  v_auth_uid uuid := auth.uid();
  v_is_service boolean := (jwt_role() = 'service_role');
begin
  if v_actor is null and v_auth_uid is not null then
    select id
      into v_actor
    from public.usuarios
    where id_auth = v_auth_uid
    limit 1;
  end if;

  if v_actor is null then
    raise exception 'permiso denegado (actor invÃ¡lido)';
  end if;

  select lower(rol), activo
    into v_actor_role, v_actor_active
  from public.usuarios
  where id = v_actor
  limit 1;

  if v_actor_role is null or not coalesce(v_actor_active, false) then
    raise exception 'permiso denegado (actor inexistente o inactivo)';
  end if;

  if v_actor_role not in ('supervisor', 'admin') then
    raise exception 'permiso denegado (requiere rol supervisor o superior)';
  end if;

  if not v_is_service then
    if v_auth_uid is null then
      raise exception 'permiso denegado (sesiÃ³n invÃ¡lida)';
    end if;

    perform 1
    from public.usuarios
    where id = v_actor
      and id_auth = v_auth_uid;

    if not found then
      raise exception 'permiso denegado (no coincide usuario autenticado)';
    end if;
  end if;

  insert into public.user_segments (usuario_id, segment_id, assigned_by)
  values (p_usuario_id, p_segment_id, v_actor)
  on conflict (usuario_id, segment_id) do update
    set assigned_by = coalesce(excluded.assigned_by, user_segments.assigned_by),
        assigned_at = timezone('utc'::text, now())
  returning * into v_row;

  return v_row;
end;
$$;

create or replace function public.remove_user_segment(
  p_usuario_id bigint,
  p_segment_id uuid
) returns boolean
language plpgsql
security definer
set search_path = public
as $$
declare
  v_is_service boolean := (jwt_role() = 'service_role');
begin
  if not public.is_super_role() and not v_is_service then
    raise exception 'permiso denegado (requiere rol supervisor o superior)';
  end if;

  delete from public.user_segments
  where usuario_id = p_usuario_id
    and segment_id = p_segment_id;

  return found;
end;
$$;


-- FILE: 20251117_create_campaigns_custom_metrics.sql
-- Campaign dynamic datasets support
set check_function_bodies = off;

create table if not exists public.campaigns_custom_metrics (
  id bigint generated by default as identity primary key,
  usuario_id bigint not null references public.usuarios(id) on delete cascade,
  dataset text not null,
  metric text not null,
  numeric_value numeric,
  text_value text,
  json_value jsonb,
  updated_at timestamptz not null default timezone('utc', now()),
  constraint campaigns_custom_metrics_value_check
    check (
      numeric_value is not null
      or text_value is not null
      or json_value is not null
    )
);

create unique index if not exists campaigns_custom_metrics_usuario_dataset_metric_key
  on public.campaigns_custom_metrics (usuario_id, dataset, metric);

create index if not exists campaigns_custom_metrics_usuario_idx
  on public.campaigns_custom_metrics (usuario_id);

comment on table public.campaigns_custom_metrics is 'Stores per-usuario campaign metrics produced by external jobs to power declarative rules (replacement for CUSTOM_SQL).';
comment on column public.campaigns_custom_metrics.dataset is 'Dataset identifier consumed by METRIC_CONDITION rules via metrics.datasets.<dataset>.<metric>.';
comment on column public.campaigns_custom_metrics.metric is 'Metric name within the dataset.';
comment on column public.campaigns_custom_metrics.numeric_value is 'Numeric value for the metric (optional).';
comment on column public.campaigns_custom_metrics.text_value is 'Text value for the metric (optional).';
comment on column public.campaigns_custom_metrics.json_value is 'JSON payload for complex metrics (optional).';


-- FILE: 20251118_campaign_progress_summary_view.sql
-- Campaign progress summary view aggregates per-campaign counters.
-- Drop first to allow re-running locally without schema conflicts.
drop view if exists public.campaign_progress_summary;

create view public.campaign_progress_summary as
with status_counts as (
    select
        campaign_id,
        status::text as status,
        count(*) as count
    from public.campaign_progress
    group by campaign_id, status
),
status_map as (
    select
        campaign_id,
        jsonb_object_agg(status, count order by status) as status_counts
    from status_counts
    group by campaign_id
)
select
    cp.campaign_id,
    count(*) as total,
    count(*) filter (where cp.eligible) as eligible_total,
    count(*) filter (where cp.status = 'completed') as completed_total,
    coalesce(sm.status_counts, '{}'::jsonb) as status_counts
from public.campaign_progress cp
left join status_map sm on sm.campaign_id = cp.campaign_id
group by cp.campaign_id, sm.status_counts;

comment on view public.campaign_progress_summary is 'Aggregated progress counters (totals and per-status) for each campaign.';


-- FILE: 20251119_add_logical_groups_to_campaign_rules.sql
-- Add logical groups support for combining campaign rules with AND/OR operators
-- This allows rules like: (rule1 AND rule2 AND rule3) OR (rule4 AND rule5)

-- Add logical_group and logical_operator columns to campaign_rules
ALTER TABLE public.campaign_rules 
ADD COLUMN IF NOT EXISTS logical_group INTEGER DEFAULT 1,
ADD COLUMN IF NOT EXISTS logical_operator TEXT DEFAULT 'AND' CHECK (logical_operator IN ('AND', 'OR'));

-- Create index for efficient querying by logical groups
CREATE INDEX IF NOT EXISTS idx_campaign_rules_logical_group 
ON public.campaign_rules(campaign_id, scope, logical_group);

COMMENT ON COLUMN public.campaign_rules.logical_group IS 'Agrupa reglas que se evalÃºan juntas. Grupos diferentes se combinan con OR, reglas dentro del mismo grupo se combinan con AND';
COMMENT ON COLUMN public.campaign_rules.logical_operator IS 'Operador lÃ³gico para combinar con la siguiente regla en el mismo grupo (AND) o para separar grupos (OR cuando cambia el logical_group)';

-- Example structure:
-- logical_group=1, rule1 (AND)
-- logical_group=1, rule2 (AND)  
-- logical_group=1, rule3 (OR) -> last rule of group uses OR to separate from next group
-- logical_group=2, rule4 (AND)
-- logical_group=2, rule5 (END)
-- 
-- Evaluates as: (rule1 AND rule2 AND rule3) OR (rule4 AND rule5)


-- FILE: 20251120_campaign_cache_cron_job.sql
-- =====================================================
-- Cron job para limpiar cache antiguo de campaign_progress
-- Se ejecuta cada 10 minutos y elimina registros > 5 minutos
-- =====================================================

-- Habilitar pg_cron si no estÃ¡ habilitado (solo una vez, requiere permisos de superuser)
-- CREATE EXTENSION IF NOT EXISTS pg_cron;

-- FunciÃ³n para limpiar cache antiguo
CREATE OR REPLACE FUNCTION clean_stale_campaign_cache()
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_deleted_count integer;
BEGIN
  -- Eliminar registros evaluados hace mÃ¡s de 5 minutos
  DELETE FROM campaign_progress
  WHERE evaluated_at < NOW() - INTERVAL '5 minutes';
  
  GET DIAGNOSTICS v_deleted_count = ROW_COUNT;
  
  RAISE NOTICE 'Cache antiguo limpiado: % registros eliminados', v_deleted_count;
END;
$$;

-- Programar cron job (ejecutar cada 10 minutos)
-- Nota: pg_cron solo estÃ¡ disponible en planes Supabase Pro o superior
/*
SELECT cron.schedule(
  'clean-campaign-cache',           -- nombre del job
  '*/10 * * * *',                    -- cada 10 minutos
  $$SELECT clean_stale_campaign_cache();$$
);
*/

-- Para desarrollo/testing, puedes ejecutar manualmente:
-- SELECT clean_stale_campaign_cache();

-- Ver jobs programados:
-- SELECT * FROM cron.job;

-- Eliminar job si es necesario:
-- SELECT cron.unschedule('clean-campaign-cache');

COMMENT ON FUNCTION clean_stale_campaign_cache IS 
  'Elimina registros de campaign_progress evaluados hace mÃ¡s de 5 minutos. Usar con pg_cron.';


-- FILE: 20251120_campaign_datasets_function.sql
-- Migration to add calculate_campaign_datasets_for_user function
-- This function automatically calculates polizas_prima_minima, polizas_recientes, and polizas_por_producto

CREATE OR REPLACE FUNCTION calculate_campaign_datasets_for_user(p_usuario_id bigint)
RETURNS jsonb
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
    v_id_auth uuid;
    v_result jsonb := '{}'::jsonb;
    v_polizas_prima_minima jsonb;
    v_polizas_recientes jsonb;
    v_polizas_por_producto jsonb;
BEGIN
    -- Get the auth UUID for the user
    SELECT id_auth INTO v_id_auth
    FROM usuarios
    WHERE id = p_usuario_id;
    
    IF v_id_auth IS NULL THEN
        RETURN v_result;
    END IF;
    
    -- Calculate polizas_prima_minima: count policies by minimum premium threshold
    -- This will be parameterized per campaign rule, but we calculate common thresholds
    WITH policy_data AS (
        SELECT 
            p.id,
            p.prima_mxn,
            p.fecha_emision,
            p.estatus
        FROM polizas p
        JOIN clientes c ON c.id = p.cliente_id
        WHERE c.asesor_id = v_id_auth
          AND p.estatus != 'ANULADA'
    )
    SELECT jsonb_build_object(
        'prima_25000', (SELECT COUNT(*) FROM policy_data WHERE prima_mxn >= 25000),
        'prima_50000', (SELECT COUNT(*) FROM policy_data WHERE prima_mxn >= 50000),
        'prima_100000', (SELECT COUNT(*) FROM policy_data WHERE prima_mxn >= 100000)
    ) INTO v_polizas_prima_minima;
    
    v_result := jsonb_set(v_result, '{polizas_prima_minima}', v_polizas_prima_minima);
    
    -- Calculate polizas_recientes: count recent policies within time windows
    WITH policy_data AS (
        SELECT 
            p.id,
            p.prima_mxn,
            p.fecha_emision,
            p.estatus,
            p.cliente_id,
            (CURRENT_DATE - p.fecha_emision) as dias_desde_emision
        FROM polizas p
        JOIN clientes c ON c.id = p.cliente_id
        WHERE c.asesor_id = v_id_auth
          AND p.estatus != 'ANULADA'
    ),
    recent_counts AS (
        SELECT
            COUNT(*) FILTER (WHERE dias_desde_emision <= 30) as recientes_30,
            COUNT(*) FILTER (WHERE dias_desde_emision <= 90) as recientes_90,
            COUNT(*) FILTER (WHERE dias_desde_emision <= 180) as recientes_180,
            COUNT(*) FILTER (WHERE dias_desde_emision <= 365) as recientes_365,
            MIN(dias_desde_emision) as ultima_emision_dias
        FROM policy_data
    )
    SELECT jsonb_build_object(
        'ventana_30', recientes_30,
        'ventana_90', recientes_90,
        'ventana_180', recientes_180,
        'ventana_365', recientes_365,
        'ultima_emision_dias', COALESCE(ultima_emision_dias, 999999)
    ) INTO v_polizas_recientes
    FROM recent_counts;
    
    v_result := jsonb_set(v_result, '{polizas_recientes}', v_polizas_recientes);
    
    -- Calculate polizas_por_producto: count policies by product type
    WITH policy_by_product AS (
        SELECT 
            pp.product_type_id,
            pt.code as product_code,
            COUNT(*) as cantidad
        FROM polizas p
        JOIN clientes c ON c.id = p.cliente_id
        LEFT JOIN producto_parametros pp ON pp.id = p.producto_parametro_id
        LEFT JOIN product_types pt ON pt.id = pp.product_type_id
        WHERE c.asesor_id = v_id_auth
          AND p.estatus != 'ANULADA'
        GROUP BY pp.product_type_id, pt.code
    )
    SELECT jsonb_object_agg(
        COALESCE(product_code, 'sin_tipo'),
        cantidad
    ) INTO v_polizas_por_producto
    FROM policy_by_product;
    
    v_result := jsonb_set(v_result, '{polizas_por_producto}', COALESCE(v_polizas_por_producto, '{}'::jsonb));
    
    RETURN v_result;
END;
$$;

COMMENT ON FUNCTION calculate_campaign_datasets_for_user IS 
'Calculates dynamic campaign datasets (polizas_prima_minima, polizas_recientes, polizas_por_producto) from actual policy data for a given user';


-- FILE: 20251120_invalidate_campaign_cache_triggers.sql
-- =====================================================
-- Triggers para invalidar cache de campaign_progress
-- cuando cambian datos que afectan la elegibilidad
-- 
-- Cobertura completa de todas las fuentes de datos:
-- 1. candidatos (mes_conexion) âœ…
-- 2. polizas â†’ afecta vw_polizas_metricas âœ…
-- 3. clientes â†’ afecta vw_polizas_metricas âœ…
-- 4. prospectos â†’ afecta vw_rc_metricas âœ…
-- 5. planificaciones âœ…
-- 6. campaigns_custom_metrics âœ…
-- 7. user_segments (SEGMENT rules) âœ…
--
-- IMPORTANTE: Las vistas materializadas (vw_polizas_metricas, 
-- vw_cancelaciones_indices, vw_rc_metricas) se refrescan cada 5-10 
-- minutos. Los triggers en tablas base (polizas, clientes, prospectos)
-- invalidan el cache inmediatamente, pero los datos en las vistas
-- pueden tardar hasta 10 min en actualizarse.
--
-- SoluciÃ³n recomendada: Combinar estos triggers con TTL de 5 minutos
-- para balance entre precisiÃ³n y carga en la DB.
-- =====================================================

-- FunciÃ³n para invalidar cache por usuario
CREATE OR REPLACE FUNCTION invalidate_campaign_cache_for_user(p_usuario_id bigint)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  DELETE FROM campaign_progress WHERE usuario_id = p_usuario_id;
  -- Comentar en producciÃ³n si genera mucho ruido en logs
  -- RAISE NOTICE 'Cache de campaÃ±as invalidado para usuario %', p_usuario_id;
END;
$$;

-- FunciÃ³n para invalidar cache cuando cambia candidatos.mes_conexion
CREATE OR REPLACE FUNCTION trigger_invalidate_cache_on_candidatos()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
  v_usuario_id bigint;
BEGIN
  -- Solo invalidar si cambiÃ³ mes_conexion
  IF (TG_OP = 'UPDATE' AND OLD.mes_conexion IS DISTINCT FROM NEW.mes_conexion) 
     OR TG_OP = 'INSERT' THEN
    
    -- Buscar el usuario_id por email
    SELECT u.id INTO v_usuario_id
    FROM usuarios u
    WHERE LOWER(u.email) = LOWER(COALESCE(NEW.email_agente, ''))
    LIMIT 1;
    
    IF v_usuario_id IS NOT NULL THEN
      PERFORM invalidate_campaign_cache_for_user(v_usuario_id);
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$;

-- FunciÃ³n para invalidar cache cuando cambian pÃ³lizas
CREATE OR REPLACE FUNCTION trigger_invalidate_cache_on_polizas()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
  v_usuario_id bigint;
BEGIN
  -- Obtener usuario_id del cliente asociado
  SELECT c.asesor_id INTO v_usuario_id
  FROM clientes c
  JOIN usuarios u ON u.id_auth = c.asesor_id
  WHERE c.id = COALESCE(NEW.cliente_id, OLD.cliente_id)
  LIMIT 1;
  
  IF v_usuario_id IS NOT NULL THEN
    PERFORM invalidate_campaign_cache_for_user(v_usuario_id);
  END IF;
  
  RETURN COALESCE(NEW, OLD);
END;
$$;

-- FunciÃ³n para invalidar cache cuando cambian clientes
CREATE OR REPLACE FUNCTION trigger_invalidate_cache_on_clientes()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
  v_usuario_id bigint;
BEGIN
  -- Obtener usuario_id del asesor
  SELECT u.id INTO v_usuario_id
  FROM usuarios u
  WHERE u.id_auth = COALESCE(NEW.asesor_id, OLD.asesor_id)
  LIMIT 1;
  
  IF v_usuario_id IS NOT NULL THEN
    PERFORM invalidate_campaign_cache_for_user(v_usuario_id);
  END IF;
  
  RETURN COALESCE(NEW, OLD);
END;
$$;

-- Crear triggers
DROP TRIGGER IF EXISTS trg_invalidate_cache_candidatos ON candidatos;
CREATE TRIGGER trg_invalidate_cache_candidatos
  AFTER INSERT OR UPDATE ON candidatos
  FOR EACH ROW
  EXECUTE FUNCTION trigger_invalidate_cache_on_candidatos();

DROP TRIGGER IF EXISTS trg_invalidate_cache_polizas ON polizas;
CREATE TRIGGER trg_invalidate_cache_polizas
  AFTER INSERT OR UPDATE OR DELETE ON polizas
  FOR EACH ROW
  EXECUTE FUNCTION trigger_invalidate_cache_on_polizas();

DROP TRIGGER IF EXISTS trg_invalidate_cache_clientes ON clientes;
CREATE TRIGGER trg_invalidate_cache_clientes
  AFTER INSERT OR UPDATE OR DELETE ON clientes
  FOR EACH ROW
  EXECUTE FUNCTION trigger_invalidate_cache_on_clientes();

-- FunciÃ³n para invalidar cache cuando cambian prospectos (RC metrics)
CREATE OR REPLACE FUNCTION trigger_invalidate_cache_on_prospectos()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
  v_usuario_id bigint;
BEGIN
  -- Obtener usuario_id del agente
  SELECT u.id INTO v_usuario_id
  FROM usuarios u
  WHERE u.id = COALESCE(NEW.agente_id, OLD.agente_id)
  LIMIT 1;
  
  IF v_usuario_id IS NOT NULL THEN
    PERFORM invalidate_campaign_cache_for_user(v_usuario_id);
  END IF;
  
  RETURN COALESCE(NEW, OLD);
END;
$$;

-- FunciÃ³n para invalidar cache cuando cambian planificaciones
CREATE OR REPLACE FUNCTION trigger_invalidate_cache_on_planificaciones()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
  v_usuario_id bigint;
BEGIN
  -- agente_id en planificaciones es directamente el usuario_id
  v_usuario_id := COALESCE(NEW.agente_id, OLD.agente_id);
  
  IF v_usuario_id IS NOT NULL THEN
    PERFORM invalidate_campaign_cache_for_user(v_usuario_id);
  END IF;
  
  RETURN COALESCE(NEW, OLD);
END;
$$;

-- FunciÃ³n para invalidar cache cuando cambian custom metrics
CREATE OR REPLACE FUNCTION trigger_invalidate_cache_on_custom_metrics()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  IF COALESCE(NEW.usuario_id, OLD.usuario_id) IS NOT NULL THEN
    PERFORM invalidate_campaign_cache_for_user(COALESCE(NEW.usuario_id, OLD.usuario_id));
  END IF;
  
  RETURN COALESCE(NEW, OLD);
END;
$$;

-- FunciÃ³n para invalidar cache cuando cambian segmentos de usuario
CREATE OR REPLACE FUNCTION trigger_invalidate_cache_on_user_segments()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  IF COALESCE(NEW.usuario_id, OLD.usuario_id) IS NOT NULL THEN
    PERFORM invalidate_campaign_cache_for_user(COALESCE(NEW.usuario_id, OLD.usuario_id));
  END IF;
  
  RETURN COALESCE(NEW, OLD);
END;
$$;

-- Crear triggers adicionales
DROP TRIGGER IF EXISTS trg_invalidate_cache_prospectos ON prospectos;
CREATE TRIGGER trg_invalidate_cache_prospectos
  AFTER INSERT OR UPDATE OR DELETE ON prospectos
  FOR EACH ROW
  EXECUTE FUNCTION trigger_invalidate_cache_on_prospectos();

DROP TRIGGER IF EXISTS trg_invalidate_cache_planificaciones ON planificaciones;
CREATE TRIGGER trg_invalidate_cache_planificaciones
  AFTER INSERT OR UPDATE OR DELETE ON planificaciones
  FOR EACH ROW
  EXECUTE FUNCTION trigger_invalidate_cache_on_planificaciones();

DROP TRIGGER IF EXISTS trg_invalidate_cache_custom_metrics ON campaigns_custom_metrics;
CREATE TRIGGER trg_invalidate_cache_custom_metrics
  AFTER INSERT OR UPDATE OR DELETE ON campaigns_custom_metrics
  FOR EACH ROW
  EXECUTE FUNCTION trigger_invalidate_cache_on_custom_metrics();

DROP TRIGGER IF EXISTS trg_invalidate_cache_user_segments ON user_segments;
CREATE TRIGGER trg_invalidate_cache_user_segments
  AFTER INSERT OR UPDATE OR DELETE ON user_segments
  FOR EACH ROW
  EXECUTE FUNCTION trigger_invalidate_cache_on_user_segments();

-- Comentarios
COMMENT ON FUNCTION invalidate_campaign_cache_for_user IS 
  'Invalida el cache de campaign_progress para un usuario especÃ­fico';

COMMENT ON FUNCTION trigger_invalidate_cache_on_candidatos IS 
  'Invalida cache cuando cambia mes_conexion u otros datos de candidatos';

COMMENT ON FUNCTION trigger_invalidate_cache_on_polizas IS 
  'Invalida cache cuando se crean/modifican/eliminan pÃ³lizas';

COMMENT ON FUNCTION trigger_invalidate_cache_on_clientes IS 
  'Invalida cache cuando se crean/modifican/eliminan clientes';

COMMENT ON FUNCTION trigger_invalidate_cache_on_prospectos IS 
  'Invalida cache cuando cambian prospectos (afecta RC metrics)';

COMMENT ON FUNCTION trigger_invalidate_cache_on_planificaciones IS 
  'Invalida cache cuando cambian planificaciones';

COMMENT ON FUNCTION trigger_invalidate_cache_on_custom_metrics IS 
  'Invalida cache cuando cambian mÃ©tricas personalizadas de campaÃ±as';

COMMENT ON FUNCTION trigger_invalidate_cache_on_user_segments IS 
  'Invalida cache cuando cambian los segmentos del usuario (afecta elegibilidad por SEGMENT rules)';


-- FILE: 20251124_campaign_evaluation_cron.sql
-- =====================================================
-- FunciÃ³n y Cron Job para evaluaciÃ³n automÃ¡tica de campaÃ±as
-- =====================================================
-- Esta funciÃ³n evalÃºa automÃ¡ticamente el progreso de campaÃ±as activas
-- para todos los usuarios y actualiza la tabla campaign_progress.
-- Se ejecuta cada hora vÃ­a pg_cron.
-- =====================================================

-- FunciÃ³n para evaluar campaÃ±as de todos los usuarios
CREATE OR REPLACE FUNCTION evaluate_all_campaigns()
RETURNS TABLE(
  usuarios_procesados integer,
  campanas_evaluadas integer,
  snapshots_actualizados integer,
  duracion_ms bigint
)
LANGUAGE plpgsql
AS $$
DECLARE
  v_start_time timestamp;
  v_end_time timestamp;
  v_usuarios_count integer := 0;
  v_campanas_count integer := 0;
  v_snapshots_count integer := 0;
  v_usuario_id integer;
  v_campaign_id uuid;
BEGIN
  v_start_time := clock_timestamp();
  
  -- Nota: Esta es una implementaciÃ³n simplificada que limpia cache antiguo
  -- La evaluaciÃ³n real se hace on-demand cuando el usuario accede a /campanias
  -- AquÃ­ solo limpiamos snapshots obsoletos (>30 minutos)
  
  DELETE FROM campaign_progress
  WHERE evaluated_at < NOW() - INTERVAL '30 minutes';
  
  GET DIAGNOSTICS v_snapshots_count = ROW_COUNT;
  
  -- Contar usuarios activos que tienen campaÃ±as
  SELECT COUNT(DISTINCT u.id) INTO v_usuarios_count
  FROM usuarios u
  WHERE u.activo = true 
    AND u.rol IN ('agente', 'asesor', 'supervisor');
  
  -- Contar campaÃ±as activas
  SELECT COUNT(*) INTO v_campanas_count
  FROM campaigns
  WHERE status = 'active'
    AND active_range @> CURRENT_DATE;
  
  v_end_time := clock_timestamp();
  
  RAISE NOTICE 'Limpieza de cache completada: % snapshots eliminados, % usuarios activos, % campaÃ±as activas',
    v_snapshots_count, v_usuarios_count, v_campanas_count;
  
  RETURN QUERY SELECT 
    v_usuarios_count,
    v_campanas_count,
    v_snapshots_count,
    EXTRACT(MILLISECONDS FROM (v_end_time - v_start_time))::bigint;
END;
$$;

COMMENT ON FUNCTION evaluate_all_campaigns IS 
  'Limpia cache antiguo de campaign_progress. La evaluaciÃ³n real es on-demand cuando usuarios acceden a /campanias.';

-- Programar cron job para ejecutar cada hora
-- Nota: Se ejecuta cada hora para limpiar cache, no para evaluar
SELECT cron.schedule(
  'cleanup-campaign-cache',
  '0 * * * *',  -- cada hora en el minuto 0
  $$SELECT evaluate_all_campaigns();$$
);

COMMENT ON FUNCTION evaluate_all_campaigns IS 
  'Limpia snapshots de campaign_progress mÃ¡s antiguos de 30 minutos. Programado para ejecutarse cada hora vÃ­a pg_cron.';


-- FILE: 20251124_fix_invalidate_cache_polizas_trigger.sql
-- Fix: Corregir trigger de invalidaciÃ³n de cache de pÃ³lizas
-- El problema es que intenta asignar asesor_id (uuid) a usuario_id (bigint)

CREATE OR REPLACE FUNCTION trigger_invalidate_cache_on_polizas()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
  v_usuario_id bigint;
BEGIN
  -- Obtener usuario_id del cliente asociado
  SELECT u.id INTO v_usuario_id
  FROM clientes c
  JOIN usuarios u ON u.id_auth = c.asesor_id
  WHERE c.id = COALESCE(NEW.cliente_id, OLD.cliente_id)
  LIMIT 1;
  
  IF v_usuario_id IS NOT NULL THEN
    PERFORM invalidate_campaign_cache_for_user(v_usuario_id);
  END IF;
  
  RETURN COALESCE(NEW, OLD);
END;
$$;


-- FILE: 20251124_fix_polizas_producto_parametro_id_type.sql
-- Fix: Corregir tipo de dato de producto_parametro_id en polizas
-- Fecha: 2025-11-24
-- Ambiente: develop (aplicar solo si la columna es bigint en lugar de uuid)

-- Este script corrige el tipo de dato de la columna producto_parametro_id 
-- en la tabla polizas de bigint a uuid

DO $$
DECLARE
  v_current_type text;
BEGIN
  -- Verificar el tipo actual de la columna
  SELECT data_type INTO v_current_type
  FROM information_schema.columns
  WHERE table_name = 'polizas' 
    AND column_name = 'producto_parametro_id';

  -- Log del tipo actual
  RAISE NOTICE 'Tipo actual de producto_parametro_id: %', v_current_type;

  -- Solo aplicar la correcciÃ³n si el tipo es bigint
  IF v_current_type = 'bigint' THEN
    RAISE NOTICE 'Aplicando correcciÃ³n: bigint -> uuid';

    -- Quitar foreign key constraint si existe
    ALTER TABLE polizas 
    DROP CONSTRAINT IF EXISTS polizas_producto_parametro_id_fkey;

    -- Cambiar tipo de columna a uuid
    -- NOTA: Esto fallarÃ¡ si hay datos invÃ¡lidos en la columna
    ALTER TABLE polizas 
    ALTER COLUMN producto_parametro_id TYPE uuid 
    USING CASE 
      WHEN producto_parametro_id IS NULL THEN NULL
      ELSE producto_parametro_id::text::uuid
    END;

    -- Recrear foreign key constraint
    ALTER TABLE polizas
    ADD CONSTRAINT polizas_producto_parametro_id_fkey 
    FOREIGN KEY (producto_parametro_id) 
    REFERENCES producto_parametros(id);

    RAISE NOTICE 'CorrecciÃ³n aplicada exitosamente';
  ELSIF v_current_type = 'uuid' THEN
    RAISE NOTICE 'La columna ya es de tipo uuid, no se requiere correcciÃ³n';
  ELSE
    RAISE WARNING 'Tipo de dato inesperado: %. Se esperaba bigint o uuid.', v_current_type;
  END IF;
END $$;

-- Verificar el resultado
SELECT 
    column_name,
    data_type,
    udt_name,
    is_nullable
FROM information_schema.columns
WHERE table_name = 'polizas' 
  AND column_name = 'producto_parametro_id';


-- FILE: 20251124_materialize_cancelaciones_indices.sql
-- =====================================================
-- Materializar vw_cancelaciones_indices para resolver timeout
-- =====================================================
-- Esta migraciÃ³n convierte la vista vw_cancelaciones_indices en una vista
-- materializada para mejorar el rendimiento de consultas y evitar timeouts.
-- 
-- Problema: La vista original hace un cross-join de asesores Ã— perÃ­odos mensuales
-- con mÃºltiples agregaciones complejas, causando timeouts en consultas por usuario.
--
-- SoluciÃ³n: Materializar la vista y crear Ã­ndices en usuario_id y periodo_mes.
-- =====================================================

-- Eliminar vista normal si existe
DROP VIEW IF EXISTS public.vw_cancelaciones_indices;

-- Crear vista materializada
CREATE MATERIALIZED VIEW public.vw_cancelaciones_indices AS
WITH datos AS (
  SELECT
    p.id,
    c.asesor_id,
    p.fecha_emision,
    p.anulada_at
  FROM public.polizas p
  JOIN public.clientes c ON c.id = p.cliente_id
),
rangos AS (
  SELECT
    generate_series(
      COALESCE(date_trunc('month', (SELECT MIN(fecha_emision) FROM datos)), date_trunc('month', CURRENT_DATE)),
      COALESCE(date_trunc('month', (SELECT MAX(COALESCE(anulada_at::date, fecha_emision)) FROM datos)), date_trunc('month', CURRENT_DATE)),
      interval '1 month'
    )::date AS periodo
),
periodos AS (
  SELECT d.asesor_id, r.periodo, (r.periodo + interval '1 month')::date AS periodo_fin
  FROM rangos r
  JOIN (SELECT DISTINCT asesor_id FROM datos) d ON true
)
SELECT
  pr.asesor_id,
  u.id AS usuario_id,
  u.email AS usuario_email,
  u.nombre AS usuario_nombre,
  pr.periodo AS periodo_mes,
  EXTRACT(year FROM pr.periodo)::int AS anio,
  EXTRACT(month FROM pr.periodo)::int AS mes,
  COUNT(d.*) FILTER (
    WHERE d.fecha_emision >= pr.periodo
      AND d.fecha_emision < pr.periodo_fin
  ) AS polizas_emitidas,
  COUNT(d.*) FILTER (
    WHERE d.anulada_at IS NOT NULL
      AND d.anulada_at >= pr.periodo
      AND d.anulada_at < pr.periodo_fin
  ) AS polizas_canceladas,
  COUNT(d.*) FILTER (
    WHERE d.fecha_emision < pr.periodo_fin
      AND (d.anulada_at IS NULL OR d.anulada_at >= pr.periodo_fin)
  ) AS polizas_vigentes_al_cierre,
  COUNT(d.*) FILTER (
    WHERE d.anulada_at IS NOT NULL
      AND d.anulada_at >= pr.periodo - interval '12 months'
      AND d.anulada_at < pr.periodo_fin
      AND d.fecha_emision >= pr.periodo - interval '12 months'
  ) AS cancelaciones_12m,
  COUNT(d.*) FILTER (
    WHERE d.fecha_emision >= pr.periodo - interval '12 months'
      AND d.fecha_emision < pr.periodo_fin
  ) AS emisiones_12m,
  CASE
    WHEN COUNT(d.*) FILTER (
           WHERE d.fecha_emision >= pr.periodo - interval '12 months'
             AND d.fecha_emision < pr.periodo_fin
         ) > 0
    THEN ROUND(
           1 - (
             COUNT(d.*) FILTER (
               WHERE d.anulada_at IS NOT NULL
                 AND d.anulada_at >= pr.periodo - interval '12 months'
                 AND d.anulada_at < pr.periodo_fin
                 AND d.fecha_emision >= pr.periodo - interval '12 months'
             )::numeric
             /
             COUNT(d.*) FILTER (
               WHERE d.fecha_emision >= pr.periodo - interval '12 months'
                 AND d.fecha_emision < pr.periodo_fin
             )
           ),
           4
         )
    ELSE NULL
  END AS indice_limra,
  CASE
    WHEN COUNT(d.*) FILTER (
           WHERE d.fecha_emision < pr.periodo_fin
             AND (d.anulada_at IS NULL OR d.anulada_at >= pr.periodo_fin)
         ) > 0
    THEN ROUND(
           1 - (
             COUNT(d.*) FILTER (
               WHERE d.anulada_at IS NOT NULL
                 AND d.anulada_at >= pr.periodo
                 AND d.anulada_at < pr.periodo_fin
             )::numeric
             /
             COUNT(d.*) FILTER (
               WHERE d.fecha_emision < pr.periodo_fin
                 AND (d.anulada_at IS NULL OR d.anulada_at >= pr.periodo_fin)
             )
           ),
           4
         )
    ELSE NULL
  END AS indice_igc,
  (
    COUNT(d.*) FILTER (
      WHERE d.fecha_emision >= pr.periodo
        AND d.fecha_emision < pr.periodo_fin
    )
    -
    COUNT(d.*) FILTER (
      WHERE d.anulada_at IS NOT NULL
        AND d.anulada_at >= pr.periodo
        AND d.anulada_at < pr.periodo_fin
    )
  ) AS momentum_neto
FROM periodos pr
LEFT JOIN datos d ON d.asesor_id IS NOT DISTINCT FROM pr.asesor_id
  AND (
    d.fecha_emision < pr.periodo_fin
    OR (d.anulada_at IS NOT NULL AND d.anulada_at >= pr.periodo - interval '12 months')
  )
LEFT JOIN public.usuarios u ON u.id_auth = pr.asesor_id
GROUP BY pr.asesor_id, u.id, u.email, u.nombre, pr.periodo
ORDER BY pr.periodo, pr.asesor_id;

COMMENT ON MATERIALIZED VIEW public.vw_cancelaciones_indices IS 'MÃ©tricas mensuales de pÃ³lizas emitidas, cancelaciones y persistencia (LIMRA / IGC) por asesor. Materializada para mejor rendimiento.';

-- Crear Ã­ndices para mejorar consultas
CREATE INDEX idx_vw_cancelaciones_usuario_id ON public.vw_cancelaciones_indices(usuario_id);
CREATE INDEX idx_vw_cancelaciones_periodo ON public.vw_cancelaciones_indices(periodo_mes DESC);
CREATE INDEX idx_vw_cancelaciones_usuario_periodo ON public.vw_cancelaciones_indices(usuario_id, periodo_mes DESC);
CREATE INDEX idx_vw_cancelaciones_asesor_id ON public.vw_cancelaciones_indices(asesor_id);

-- FunciÃ³n para refrescar la vista materializada
-- SET statement_timeout = 0 permite que la operaciÃ³n tome el tiempo necesario
CREATE OR REPLACE FUNCTION refresh_vw_cancelaciones_indices()
RETURNS void
LANGUAGE plpgsql
SET statement_timeout = 0
AS $$
BEGIN
  BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY public.vw_cancelaciones_indices;
    RAISE NOTICE 'Vista materializada vw_cancelaciones_indices refrescada (CONCURRENTLY)';
  EXCEPTION
    WHEN OTHERS THEN
      -- Si falla CONCURRENTLY (requiere Ã­ndice Ãºnico), intentar sin CONCURRENTLY
      REFRESH MATERIALIZED VIEW public.vw_cancelaciones_indices;
      RAISE NOTICE 'Vista materializada vw_cancelaciones_indices refrescada (sin CONCURRENTLY)';
  END;
END;
$$;

COMMENT ON FUNCTION refresh_vw_cancelaciones_indices IS 'Refresca la vista materializada vw_cancelaciones_indices. Usar con pg_cron cada 5-10 minutos.';

-- Nota: Para programar refresco automÃ¡tico con pg_cron:
-- IMPORTANTE: El comando del cron job debe incluir SET statement_timeout = 0
-- para evitar timeouts en bases de datos con timeout configurado (ej. 2min en producciÃ³n)
-- 
-- SELECT cron.schedule(
--   'refresh-cancelaciones-indices',
--   '*/10 * * * *',  -- cada 10 minutos
--   $$SET statement_timeout = 0; SELECT refresh_vw_cancelaciones_indices();$$
-- );

-- Refrescar inmediatamente despuÃ©s de crear
REFRESH MATERIALIZED VIEW public.vw_cancelaciones_indices;


-- FILE: 20251125_optimize_cancelaciones_view.sql
-- =====================================================
-- Vista materializada optimizada de cancelaciones
-- ReducciÃ³n estimada: 90% del tamaÃ±o (de 657MB a ~65MB)
-- =====================================================
-- Cambios principales:
-- 1. Solo Ãºltimos 24 meses (vs todo el histÃ³rico)
-- 2. Solo usuarios activos
-- 3. Columnas esenciales (sin email/nombre redundantes)
-- 4. Ãndices parciales en datos recientes
-- =====================================================

-- Eliminar vista anterior si existe
DROP MATERIALIZED VIEW IF EXISTS public.vw_cancelaciones_indices CASCADE;

-- Crear vista materializada optimizada
CREATE MATERIALIZED VIEW public.vw_cancelaciones_indices AS
WITH datos AS (
  SELECT
    p.id,
    c.asesor_id,
    p.fecha_emision,
    p.anulada_at
  FROM public.polizas p
  JOIN public.clientes c ON c.id = p.cliente_id
  -- OptimizaciÃ³n: Solo pÃ³lizas de Ãºltimos 36 meses (para calcular 24 meses + ventana de 12)
  WHERE p.fecha_emision >= date_trunc('month', CURRENT_DATE - INTERVAL '36 months')
     OR (p.anulada_at IS NOT NULL 
         AND p.anulada_at >= date_trunc('month', CURRENT_DATE - INTERVAL '36 months'))
),
rangos AS (
  SELECT
    -- OptimizaciÃ³n: Solo Ãºltimos 24 meses
    generate_series(
      date_trunc('month', CURRENT_DATE - INTERVAL '24 months'),
      date_trunc('month', CURRENT_DATE),
      interval '1 month'
    )::date AS periodo
),
periodos AS (
  SELECT d.asesor_id, r.periodo, (r.periodo + interval '1 month')::date AS periodo_fin
  FROM rangos r
  CROSS JOIN (
    -- OptimizaciÃ³n: Solo usuarios activos
    SELECT DISTINCT c.asesor_id 
    FROM datos d
    JOIN public.clientes c ON c.asesor_id = d.asesor_id
    JOIN public.usuarios u ON u.id_auth = c.asesor_id
    WHERE u.activo = true
  ) d
)
SELECT
  pr.asesor_id,
  u.id AS usuario_id,
  -- Columnas redundantes eliminadas: usuario_email, usuario_nombre
  pr.periodo AS periodo_mes,
  -- Columnas redundantes eliminadas: anio, mes (se calculan del periodo_mes)
  COUNT(d.*) FILTER (
    WHERE d.fecha_emision >= pr.periodo
      AND d.fecha_emision < pr.periodo_fin
  ) AS polizas_emitidas,
  COUNT(d.*) FILTER (
    WHERE d.anulada_at IS NOT NULL
      AND d.anulada_at >= pr.periodo
      AND d.anulada_at < pr.periodo_fin
  ) AS polizas_canceladas,
  COUNT(d.*) FILTER (
    WHERE d.fecha_emision < pr.periodo_fin
      AND (d.anulada_at IS NULL OR d.anulada_at >= pr.periodo_fin)
  ) AS polizas_vigentes_al_cierre,
  COUNT(d.*) FILTER (
    WHERE d.anulada_at IS NOT NULL
      AND d.anulada_at >= pr.periodo - interval '12 months'
      AND d.anulada_at < pr.periodo_fin
      AND d.fecha_emision >= pr.periodo - interval '12 months'
  ) AS cancelaciones_12m,
  COUNT(d.*) FILTER (
    WHERE d.fecha_emision >= pr.periodo - interval '12 months'
      AND d.fecha_emision < pr.periodo_fin
  ) AS emisiones_12m,
  CASE
    WHEN COUNT(d.*) FILTER (
           WHERE d.fecha_emision >= pr.periodo - interval '12 months'
             AND d.fecha_emision < pr.periodo_fin
         ) > 0
    THEN ROUND(
           1 - (
             COUNT(d.*) FILTER (
               WHERE d.anulada_at IS NOT NULL
                 AND d.anulada_at >= pr.periodo - interval '12 months'
                 AND d.anulada_at < pr.periodo_fin
                 AND d.fecha_emision >= pr.periodo - interval '12 months'
             )::numeric
             /
             COUNT(d.*) FILTER (
               WHERE d.fecha_emision >= pr.periodo - interval '12 months'
                 AND d.fecha_emision < pr.periodo_fin
             )
           ),
           4
         )
    ELSE NULL
  END AS indice_limra,
  CASE
    WHEN COUNT(d.*) FILTER (
           WHERE d.fecha_emision < pr.periodo_fin
             AND (d.anulada_at IS NULL OR d.anulada_at >= pr.periodo_fin)
         ) > 0
    THEN ROUND(
           1 - (
             COUNT(d.*) FILTER (
               WHERE d.anulada_at IS NOT NULL
                 AND d.anulada_at >= pr.periodo
                 AND d.anulada_at < pr.periodo_fin
             )::numeric
             /
             COUNT(d.*) FILTER (
               WHERE d.fecha_emision < pr.periodo_fin
                 AND (d.anulada_at IS NULL OR d.anulada_at >= pr.periodo_fin)
             )
           ),
           4
         )
    ELSE NULL
  END AS indice_igc,
  (
    COUNT(d.*) FILTER (
      WHERE d.fecha_emision >= pr.periodo
        AND d.fecha_emision < pr.periodo_fin
    )
    -
    COUNT(d.*) FILTER (
      WHERE d.anulada_at IS NOT NULL
        AND d.anulada_at >= pr.periodo
        AND d.anulada_at < pr.periodo_fin
    )
  ) AS momentum_neto
FROM periodos pr
LEFT JOIN datos d ON d.asesor_id IS NOT DISTINCT FROM pr.asesor_id
  AND (
    d.fecha_emision < pr.periodo_fin
    OR (d.anulada_at IS NOT NULL AND d.anulada_at >= pr.periodo - interval '12 months')
  )
LEFT JOIN public.usuarios u ON u.id_auth = pr.asesor_id
WHERE u.activo = true  -- Solo usuarios activos
GROUP BY pr.asesor_id, u.id, pr.periodo
ORDER BY pr.periodo DESC, pr.asesor_id;

COMMENT ON MATERIALIZED VIEW public.vw_cancelaciones_indices IS 
  'MÃ©tricas de cancelaciones optimizada: Ãºltimos 24 meses, solo usuarios activos. TamaÃ±o ~10% del original.';

-- Ãndices optimizados (solo en datos recientes)
CREATE INDEX idx_vw_cancelaciones_usuario_id ON public.vw_cancelaciones_indices(usuario_id);
CREATE INDEX idx_vw_cancelaciones_periodo ON public.vw_cancelaciones_indices(periodo_mes DESC)
  WHERE periodo_mes >= date_trunc('month', CURRENT_DATE - INTERVAL '12 months');
CREATE INDEX idx_vw_cancelaciones_usuario_periodo ON public.vw_cancelaciones_indices(usuario_id, periodo_mes DESC)
  WHERE periodo_mes >= date_trunc('month', CURRENT_DATE - INTERVAL '12 months');

-- FunciÃ³n de refresco optimizada
CREATE OR REPLACE FUNCTION refresh_vw_cancelaciones_indices()
RETURNS void
LANGUAGE plpgsql
SET statement_timeout = 0
AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY public.vw_cancelaciones_indices;
  RAISE NOTICE 'Vista optimizada refrescada (CONCURRENTLY)';
EXCEPTION
  WHEN OTHERS THEN
    REFRESH MATERIALIZED VIEW public.vw_cancelaciones_indices;
    RAISE NOTICE 'Vista optimizada refrescada (sin CONCURRENTLY)';
END;
$$;

COMMENT ON FUNCTION refresh_vw_cancelaciones_indices IS 
  'Refresca vista materializada optimizada de cancelaciones.';

-- Refrescar la vista inmediatamente
REFRESH MATERIALIZED VIEW public.vw_cancelaciones_indices;

-- Mostrar estadÃ­sticas de tamaÃ±o
SELECT 
  pg_size_pretty(pg_total_relation_size('public.vw_cancelaciones_indices')) AS tamaÃ±o_total,
  COUNT(*) AS total_filas
FROM public.vw_cancelaciones_indices;


-- FILE: 20251210_enable_rls_missing_tables.sql
-- Migration: Enable RLS on missing tables
-- Date: 2025-12-10
-- Description: Enable Row Level Security on public tables that are missing it

-- =======================
-- 1. ENABLE RLS
-- =======================

-- campaigns_custom_metrics
ALTER TABLE public.campaigns_custom_metrics ENABLE ROW LEVEL SECURITY;

-- usuarios
ALTER TABLE public.usuarios ENABLE ROW LEVEL SECURITY;

-- tokens_integracion
ALTER TABLE public.tokens_integracion ENABLE ROW LEVEL SECURITY;

-- agente_meta
ALTER TABLE public.agente_meta ENABLE ROW LEVEL SECURITY;

-- prospectos
ALTER TABLE public.prospectos ENABLE ROW LEVEL SECURITY;

-- logs_integracion
ALTER TABLE public.logs_integracion ENABLE ROW LEVEL SECURITY;


-- =======================
-- 2. RLS POLICIES
-- =======================

-- ============================================
-- CAMPAIGNS_CUSTOM_METRICS
-- ============================================
-- Todos pueden leer mÃ©tricas custom
CREATE POLICY "campaigns_custom_metrics_select_all"
ON public.campaigns_custom_metrics
FOR SELECT
USING (true);

-- Solo admin y supervisor pueden insertar
CREATE POLICY "campaigns_custom_metrics_insert_admin_supervisor"
ON public.campaigns_custom_metrics
FOR INSERT TO authenticated
WITH CHECK (public.is_super_role());

-- Solo admin y supervisor pueden actualizar
CREATE POLICY "campaigns_custom_metrics_update_admin_supervisor"
ON public.campaigns_custom_metrics
FOR UPDATE TO authenticated
USING (public.is_super_role())
WITH CHECK (public.is_super_role());

-- Solo admin puede eliminar
CREATE POLICY "campaigns_custom_metrics_delete_admin_supervisor"
ON public.campaigns_custom_metrics
FOR DELETE TO authenticated
USING (public.is_super_role());


-- ============================================
-- USUARIOS
-- ============================================
-- Todos los usuarios autenticados pueden ver usuarios
CREATE POLICY "usuarios_select_authenticated"
ON public.usuarios
FOR SELECT TO authenticated
USING (true);

-- Solo admin y supervisor pueden insertar usuarios
CREATE POLICY "usuarios_insert_admin_supervisor"
ON public.usuarios
FOR INSERT TO authenticated
WITH CHECK (public.is_super_role());

-- Admin y supervisor pueden actualizar, o el propio usuario puede actualizar su perfil
CREATE POLICY "usuarios_update_admin_supervisor_self"
ON public.usuarios
FOR UPDATE TO authenticated
USING (
  usuarios.id_auth = auth.uid()
  OR public.is_super_role()
);

-- Solo admin y supervisor pueden eliminar usuarios (no admin/supervisor)
CREATE POLICY "usuarios_delete_admin_supervisor"
ON public.usuarios
FOR DELETE TO authenticated
USING (
  public.is_super_role()
  AND LOWER(usuarios.rol) NOT IN ('admin', 'supervisor')
);


-- ============================================
-- TOKENS_INTEGRACION
-- ============================================
-- Los usuarios solo pueden ver sus propios tokens o admin/supervisor pueden ver todos
CREATE POLICY "tokens_integracion_select_own"
ON public.tokens_integracion
FOR SELECT TO authenticated
USING (
  tokens_integracion.usuario_id = auth.uid()
  OR public.is_super_role()
);

-- Los usuarios pueden insertar sus propios tokens
CREATE POLICY "tokens_integracion_insert_own"
ON public.tokens_integracion
FOR INSERT TO authenticated
WITH CHECK (tokens_integracion.usuario_id = auth.uid());

-- Los usuarios pueden actualizar sus propios tokens
CREATE POLICY "tokens_integracion_update_own"
ON public.tokens_integracion
FOR UPDATE TO authenticated
USING (tokens_integracion.usuario_id = auth.uid());

-- Los usuarios pueden eliminar sus propios tokens
CREATE POLICY "tokens_integracion_delete_own"
ON public.tokens_integracion
FOR DELETE TO authenticated
USING (tokens_integracion.usuario_id = auth.uid());


-- ============================================
-- AGENTE_META
-- ============================================
-- Todos los usuarios autenticados pueden leer agente_meta
CREATE POLICY "agente_meta_select_authenticated"
ON public.agente_meta
FOR SELECT TO authenticated
USING (true);

-- Admin y supervisor pueden insertar
CREATE POLICY "agente_meta_insert_admin_supervisor"
ON public.agente_meta
FOR INSERT TO authenticated
WITH CHECK (public.is_super_role());

-- Admin, supervisor y el propio agente pueden actualizar
CREATE POLICY "agente_meta_update_admin_supervisor_self"
ON public.agente_meta
FOR UPDATE TO authenticated
USING (
  agente_meta.usuario_id IN (
    SELECT id FROM public.usuarios WHERE id_auth = auth.uid()
  )
  OR public.is_super_role()
);

-- Solo admin y supervisor pueden eliminar
CREATE POLICY "agente_meta_delete_admin_supervisor"
ON public.agente_meta
FOR DELETE TO authenticated
USING (public.is_super_role());


-- ============================================
-- PROSPECTOS
-- ============================================
-- Todos los usuarios autenticados pueden ver prospectos
CREATE POLICY "prospectos_select_authenticated"
ON public.prospectos
FOR SELECT TO authenticated
USING (true);

-- Agente, supervisor y admin pueden insertar prospectos
CREATE POLICY "prospectos_insert_agente_supervisor_admin"
ON public.prospectos
FOR INSERT TO authenticated
WITH CHECK (
  EXISTS (
    SELECT 1 FROM public.usuarios
    WHERE usuarios.id_auth = auth.uid()
    AND usuarios.activo = true
    AND LOWER(usuarios.rol) IN ('agente', 'supervisor', 'admin')
  )
);

-- El agente propietario o admin/supervisor pueden actualizar
CREATE POLICY "prospectos_update_creator_admin_supervisor"
ON public.prospectos
FOR UPDATE TO authenticated
USING (
  prospectos.agente_id IN (
    SELECT id FROM public.usuarios WHERE id_auth = auth.uid()
  )
  OR public.is_super_role()
);

-- Admin y supervisor pueden eliminar
CREATE POLICY "prospectos_delete_admin_supervisor"
ON public.prospectos
FOR DELETE TO authenticated
USING (public.is_super_role());


-- ============================================
-- LOGS_INTEGRACION
-- ============================================
-- Admin y supervisor pueden ver todos los logs, otros solo los propios
CREATE POLICY "logs_integracion_select_own_or_admin"
ON public.logs_integracion
FOR SELECT TO authenticated
USING (
  logs_integracion.usuario_id = auth.uid()
  OR public.is_super_role()
);

-- Los usuarios pueden insertar sus propios logs
CREATE POLICY "logs_integracion_insert_own"
ON public.logs_integracion
FOR INSERT TO authenticated
WITH CHECK (logs_integracion.usuario_id = auth.uid());

-- Solo admin y supervisor pueden actualizar logs
CREATE POLICY "logs_integracion_update_admin_supervisor"
ON public.logs_integracion
FOR UPDATE TO authenticated
USING (public.is_super_role());

-- Solo admin y supervisor pueden eliminar logs
CREATE POLICY "logs_integracion_delete_admin_supervisor"
ON public.logs_integracion
FOR DELETE TO authenticated
USING (public.is_super_role());


-- =======================
-- 3. PERFORMANCE INDEXES
-- =======================

-- Ãndices para campaigns_custom_metrics
-- (ya existen en 20251117_create_campaigns_custom_metrics.sql, no duplicamos)

-- Ãndices para usuarios
CREATE INDEX IF NOT EXISTS idx_usuarios_id_auth 
ON public.usuarios(id_auth);

CREATE INDEX IF NOT EXISTS idx_usuarios_email 
ON public.usuarios(LOWER(email));

CREATE INDEX IF NOT EXISTS idx_usuarios_rol_activo 
ON public.usuarios(LOWER(rol), activo);

-- Ãndices para tokens_integracion
CREATE INDEX IF NOT EXISTS idx_tokens_integracion_usuario_id 
ON public.tokens_integracion(usuario_id);

CREATE INDEX IF NOT EXISTS idx_tokens_integracion_proveedor 
ON public.tokens_integracion(proveedor);

CREATE INDEX IF NOT EXISTS idx_tokens_integracion_usuario_proveedor 
ON public.tokens_integracion(usuario_id, proveedor);

-- Ãndices para agente_meta
CREATE INDEX IF NOT EXISTS idx_agente_meta_usuario_id 
ON public.agente_meta(usuario_id);

-- Ãndices para prospectos
-- (agente_id, anio, semana_iso) y (estado) ya existen en 20250827_fase2_prospectos_planificacion.sql

-- Ãndices para logs_integracion
CREATE INDEX IF NOT EXISTS idx_logs_integracion_usuario_id 
ON public.logs_integracion(usuario_id);

CREATE INDEX IF NOT EXISTS idx_logs_integracion_proveedor 
ON public.logs_integracion(proveedor);

-- (created_at DESC) ya existe como logs_integracion_created_idx

CREATE INDEX IF NOT EXISTS idx_logs_integracion_usuario_proveedor_date 
ON public.logs_integracion(usuario_id, proveedor, created_at DESC);


-- =======================
-- COMENTARIOS
-- =======================

COMMENT ON POLICY "campaigns_custom_metrics_select_all" 
ON public.campaigns_custom_metrics IS 'Todos pueden leer mÃ©tricas custom de campaÃ±as';

COMMENT ON POLICY "usuarios_select_authenticated" 
ON public.usuarios IS 'Usuarios autenticados pueden ver la lista de usuarios';

COMMENT ON POLICY "tokens_integracion_select_own" 
ON public.tokens_integracion IS 'Los usuarios solo pueden ver sus propios tokens o admin/supervisor pueden ver todos';

COMMENT ON POLICY "agente_meta_select_authenticated" 
ON public.agente_meta IS 'Todos los usuarios autenticados pueden leer metadatos de agentes';

COMMENT ON POLICY "prospectos_select_authenticated" 
ON public.prospectos IS 'Todos los usuarios autenticados pueden ver prospectos';

COMMENT ON POLICY "logs_integracion_select_own_or_admin" 
ON public.logs_integracion IS 'Los usuarios pueden ver sus propios logs, admin/supervisor pueden ver todos';


-- FILE: 20251210_fix_function_search_path.sql
-- =====================================================
-- Migration: Fix Function Search Path Security Warnings
-- Date: 2024-12-10
-- Description: Add SET search_path to all functions to prevent
--              search_path hijacking attacks
-- =====================================================

-- All functions with correct signatures
ALTER FUNCTION public.transfer_reassign_usuario(p_old_id bigint, p_new_id bigint, p_actor_email text) SET search_path = '';
ALTER FUNCTION public.generar_cliente_code() SET search_path = '';
ALTER FUNCTION public.set_updated_at() SET search_path = '';
ALTER FUNCTION public.producto_parametros_set_keys() SET search_path = '';
ALTER FUNCTION public.producto_parametros_after_update_sync_moneda() SET search_path = '';
ALTER FUNCTION public.polizas_before_insupd_enforce_moneda() SET search_path = '';
ALTER FUNCTION public.get_current_udi(p_fecha date) SET search_path = '';
ALTER FUNCTION public.get_fx_usd(p_fecha date) SET search_path = '';
ALTER FUNCTION public.normalize_prima(p_monto numeric, p_moneda moneda_poliza, p_fecha date) SET search_path = '';
ALTER FUNCTION public.polizas_normalize_amounts() SET search_path = '';
ALTER FUNCTION public.poliza_year_vigencia(p_fecha_emision date) SET search_path = '';
ALTER FUNCTION public.polizas_after_change_recalc() SET search_path = '';
ALTER FUNCTION public.recalc_puntos_poliza(p_poliza_id uuid) SET search_path = '';
ALTER FUNCTION public.recalc_puntos_poliza_all(p_limit integer) SET search_path = '';
ALTER FUNCTION public.submit_cliente_update(p_cliente_id uuid, p_payload jsonb) SET search_path = '';
ALTER FUNCTION public.apply_cliente_update(p_request_id uuid) SET search_path = '';
ALTER FUNCTION public.reject_cliente_update(p_request_id uuid, p_motivo text) SET search_path = '';
ALTER FUNCTION public.jwt_role() SET search_path = '';
ALTER FUNCTION public.refresh_vw_cancelaciones_indices() SET search_path = '';
ALTER FUNCTION public.calculate_campaign_datasets_for_user(p_usuario_id bigint) SET search_path = '';
ALTER FUNCTION public.invalidate_campaign_cache_for_user(p_usuario_id bigint) SET search_path = '';
ALTER FUNCTION public.trigger_invalidate_cache_on_candidatos() SET search_path = '';
ALTER FUNCTION public.trigger_invalidate_cache_on_clientes() SET search_path = '';
ALTER FUNCTION public.submit_poliza_update(p_poliza_id uuid, p_payload jsonb) SET search_path = '';
ALTER FUNCTION public.trigger_invalidate_cache_on_prospectos() SET search_path = '';
ALTER FUNCTION public.reject_poliza_update(p_request_id uuid, p_motivo text) SET search_path = '';
ALTER FUNCTION public.trigger_invalidate_cache_on_planificaciones() SET search_path = '';
ALTER FUNCTION public.trigger_invalidate_cache_on_custom_metrics() SET search_path = '';
ALTER FUNCTION public.trigger_invalidate_cache_on_user_segments() SET search_path = '';
ALTER FUNCTION public.trigger_invalidate_cache_on_polizas() SET search_path = '';
ALTER FUNCTION public.recalc_polizas_by_producto_parametro(p_pp_id uuid) SET search_path = '';
ALTER FUNCTION public.apply_poliza_update(p_request_id uuid) SET search_path = '';
ALTER FUNCTION public.evaluate_all_campaigns() SET search_path = '';
-- ALTER FUNCTION public.apply_poliza_update_dbg(p_request_id uuid) SET search_path = ''; -- Debug function, may not exist in prod
ALTER FUNCTION public.producto_parametros_after_update_recalc() SET search_path = '';

-- =====================================================
-- Performance optimizations: Add missing FK indexes
-- =====================================================

-- campaign_progress.usuario_id (bigint FK to usuarios.id)
CREATE INDEX IF NOT EXISTS idx_campaign_progress_usuario_id 
  ON public.campaign_progress(usuario_id);

-- campaign_segments.segment_id (bigint FK to segments.id)
CREATE INDEX IF NOT EXISTS idx_campaign_segments_segment_id 
  ON public.campaign_segments(segment_id);

-- candidatos foreign keys
CREATE INDEX IF NOT EXISTS idx_candidatos_efc 
  ON public.candidatos(efc);

CREATE INDEX IF NOT EXISTS idx_candidatos_mes 
  ON public.candidatos(mes);

-- user_segments.segment_id (bigint FK to segments.id)
CREATE INDEX IF NOT EXISTS idx_user_segments_segment_id 
  ON public.user_segments(segment_id);

-- =====================================================
-- END OF MIGRATION
-- =====================================================


-- FILE: 20251210_fix_remaining_security_issues.sql
-- Fix remaining security issues from Supabase linter
-- 11 ERROR issues: 6 SECURITY DEFINER views + 5 tables without RLS

-- ============================================
-- 1. ENABLE RLS ON REMAINING TABLES
-- ============================================

ALTER TABLE public.registro_acciones ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.planificaciones ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.citas ENABLE ROW LEVEL SECURITY;
ALTER TABLE public."Parametros" ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.prospectos_historial ENABLE ROW LEVEL SECURITY;


-- ============================================
-- 2. CREATE RLS POLICIES
-- ============================================

-- REGISTRO_ACCIONES
-- Admin y supervisor pueden ver todos, usuarios normales solo los propios
CREATE POLICY "registro_acciones_select_own_or_super"
ON public.registro_acciones
FOR SELECT TO authenticated
USING (
  registro_acciones.usuario IN (
    SELECT email FROM public.usuarios WHERE id_auth = (SELECT auth.uid())
  )
  OR public.is_super_role()
);

-- Solo admin y supervisor pueden insertar registros de acciones
CREATE POLICY "registro_acciones_insert_super"
ON public.registro_acciones
FOR INSERT TO authenticated
WITH CHECK (public.is_super_role());

-- Solo admin y supervisor pueden actualizar
CREATE POLICY "registro_acciones_update_super"
ON public.registro_acciones
FOR UPDATE TO authenticated
USING (public.is_super_role());

-- Solo admin y supervisor pueden eliminar
CREATE POLICY "registro_acciones_delete_super"
ON public.registro_acciones
FOR DELETE TO authenticated
USING (public.is_super_role());


-- PLANIFICACIONES
-- Todos pueden leer planificaciones
CREATE POLICY "planificaciones_select_all"
ON public.planificaciones
FOR SELECT TO authenticated
USING (true);

-- El agente propietario o admin/supervisor pueden insertar
CREATE POLICY "planificaciones_insert_owner_or_super"
ON public.planificaciones
FOR INSERT TO authenticated
WITH CHECK (
  planificaciones.agente_id IN (
    SELECT id FROM public.usuarios WHERE id_auth = (SELECT auth.uid())
  )
  OR public.is_super_role()
);

-- El agente propietario o admin/supervisor pueden actualizar
CREATE POLICY "planificaciones_update_owner_or_super"
ON public.planificaciones
FOR UPDATE TO authenticated
USING (
  planificaciones.agente_id IN (
    SELECT id FROM public.usuarios WHERE id_auth = (SELECT auth.uid())
  )
  OR public.is_super_role()
);

-- Solo admin y supervisor pueden eliminar
CREATE POLICY "planificaciones_delete_super"
ON public.planificaciones
FOR DELETE TO authenticated
USING (public.is_super_role());


-- CITAS
-- Todos pueden ver todas las citas
CREATE POLICY "citas_select_all"
ON public.citas
FOR SELECT TO authenticated
USING (true);

-- El agente o supervisor de la cita, o admin/supervisor pueden insertar
CREATE POLICY "citas_insert_involved_or_super"
ON public.citas
FOR INSERT TO authenticated
WITH CHECK (
  citas.agente_id = (SELECT auth.uid())
  OR citas.supervisor_id = (SELECT auth.uid())
  OR public.is_super_role()
);

-- El agente o supervisor de la cita, o admin/supervisor pueden actualizar
CREATE POLICY "citas_update_involved_or_super"
ON public.citas
FOR UPDATE TO authenticated
USING (
  citas.agente_id = (SELECT auth.uid())
  OR citas.supervisor_id = (SELECT auth.uid())
  OR public.is_super_role()
);

-- Solo admin y supervisor pueden eliminar
CREATE POLICY "citas_delete_super"
ON public.citas
FOR DELETE TO authenticated
USING (public.is_super_role());


-- PARAMETROS (tabla de configuraciÃ³n)
-- Todos pueden leer parÃ¡metros
CREATE POLICY "parametros_select_all"
ON public."Parametros"
FOR SELECT TO authenticated
USING (true);

-- Solo admin y supervisor pueden modificar
CREATE POLICY "parametros_insert_super"
ON public."Parametros"
FOR INSERT TO authenticated
WITH CHECK (public.is_super_role());

CREATE POLICY "parametros_update_super"
ON public."Parametros"
FOR UPDATE TO authenticated
USING (public.is_super_role());

CREATE POLICY "parametros_delete_super"
ON public."Parametros"
FOR DELETE TO authenticated
USING (public.is_super_role());


-- PROSPECTOS_HISTORIAL
-- Todos pueden leer el historial
CREATE POLICY "prospectos_historial_select_all"
ON public.prospectos_historial
FOR SELECT TO authenticated
USING (true);

-- Solo el sistema puede insertar (triggers), admin/supervisor tambiÃ©n
CREATE POLICY "prospectos_historial_insert_super"
ON public.prospectos_historial
FOR INSERT TO authenticated
WITH CHECK (public.is_super_role());

-- Solo admin y supervisor pueden actualizar
CREATE POLICY "prospectos_historial_update_super"
ON public.prospectos_historial
FOR UPDATE TO authenticated
USING (public.is_super_role());

-- Solo admin y supervisor pueden eliminar
CREATE POLICY "prospectos_historial_delete_super"
ON public.prospectos_historial
FOR DELETE TO authenticated
USING (public.is_super_role());


-- ============================================
-- 3. FIX SECURITY DEFINER VIEWS
-- ============================================
-- Convert SECURITY DEFINER views to SECURITY INVOKER
-- This makes them use the permissions of the calling user instead of the view creator

ALTER VIEW public.polizas_ui SET (security_invoker = true);
ALTER VIEW public.polizas_valores_actuales SET (security_invoker = true);
ALTER VIEW public.campaign_progress_summary SET (security_invoker = true);
ALTER VIEW public.vw_polizas_metricas SET (security_invoker = true);
ALTER VIEW public.vw_rc_metricas SET (security_invoker = true);
ALTER VIEW public.citas_ocupadas SET (security_invoker = true);


-- ============================================
-- 4. PERFORMANCE INDEXES
-- ============================================

-- Ãndices para registro_acciones
CREATE INDEX IF NOT EXISTS idx_registro_acciones_usuario 
ON public.registro_acciones(usuario);

CREATE INDEX IF NOT EXISTS idx_registro_acciones_fecha 
ON public.registro_acciones(fecha DESC);

CREATE INDEX IF NOT EXISTS idx_registro_acciones_tabla 
ON public.registro_acciones(tabla_afectada);

-- Ãndices para planificaciones (ya existen, verificar)
-- idx_planif_agente_semana ya existe

-- Ãndices para citas (algunos ya existen)
-- citas_agente_inicio_idx ya existe
-- citas_supervisor_inicio_idx ya existe

CREATE INDEX IF NOT EXISTS idx_citas_estado 
ON public.citas(estado);

-- Ãndices para Parametros
CREATE INDEX IF NOT EXISTS idx_parametros_tipo_clave 
ON public."Parametros"(tipo, clave);


-- ============================================
-- COMENTARIOS
-- ============================================

COMMENT ON POLICY "registro_acciones_select_own_or_super" 
ON public.registro_acciones IS 'Los usuarios pueden ver sus propios registros, admin/supervisor ven todos';

COMMENT ON POLICY "planificaciones_select_all" 
ON public.planificaciones IS 'Todos los usuarios autenticados pueden ver planificaciones';

COMMENT ON POLICY "citas_select_all" 
ON public.citas IS 'Todos los usuarios autenticados pueden ver citas';

COMMENT ON POLICY "parametros_select_all" 
ON public."Parametros" IS 'Todos pueden leer parÃ¡metros de configuraciÃ³n';

COMMENT ON POLICY "prospectos_historial_select_all" 
ON public.prospectos_historial IS 'Todos pueden leer el historial de prospectos';


-- FILE: 20251210_optimize_performance_security.sql
-- =====================================================
-- Migration: Performance and Security Optimizations
-- Date: 2024-12-10
-- Description: 
--   1. Optimize 27 RLS policies with auth.uid() (wrap in subquery)
--   2. Add 13 missing foreign key indexes
--   3. Add policies to 4 tables with RLS but no policies
--   4. Review unused indexes (kept for now, documented)
-- =====================================================

-- =====================================================
-- SECTION 1: OPTIMIZE RLS POLICIES (auth_rls_initplan)
-- Wrap auth.uid() in SELECT subquery to prevent initplan issues
-- =====================================================

-- agente_meta
DROP POLICY IF EXISTS agente_meta_update_admin_supervisor_self ON public.agente_meta;
CREATE POLICY agente_meta_update_admin_supervisor_self ON public.agente_meta
  FOR UPDATE TO authenticated
  USING (
    EXISTS (SELECT 1 FROM public.usuarios WHERE id = agente_meta.usuario_id AND id_auth = (SELECT auth.uid()))
    OR is_super_role()
  )
  WITH CHECK (
    EXISTS (SELECT 1 FROM public.usuarios WHERE id = agente_meta.usuario_id AND id_auth = (SELECT auth.uid()))
    OR is_super_role()
  );

-- campaign_progress
DROP POLICY IF EXISTS campaign_progress_select_self ON public.campaign_progress;
CREATE POLICY campaign_progress_select_self ON public.campaign_progress
  FOR SELECT TO authenticated
  USING (
    usuario_id IN (SELECT id FROM public.usuarios WHERE id_auth = (SELECT auth.uid()))
    OR is_super_role()
  );

-- citas
DROP POLICY IF EXISTS citas_insert_involved_or_super ON public.citas;
CREATE POLICY citas_insert_involved_or_super ON public.citas
  FOR INSERT TO authenticated
  WITH CHECK (
    agente_id = (SELECT auth.uid())
    OR supervisor_id = (SELECT auth.uid())
    OR is_super_role()
  );

DROP POLICY IF EXISTS citas_update_involved_or_super ON public.citas;
CREATE POLICY citas_update_involved_or_super ON public.citas
  FOR UPDATE TO authenticated
  USING (
    agente_id = (SELECT auth.uid())
    OR supervisor_id = (SELECT auth.uid())
    OR is_super_role()
  )
  WITH CHECK (
    agente_id = (SELECT auth.uid())
    OR supervisor_id = (SELECT auth.uid())
    OR is_super_role()
  );

-- cliente_update_requests
DROP POLICY IF EXISTS ins_cliente_update_requests ON public.cliente_update_requests;
CREATE POLICY ins_cliente_update_requests ON public.cliente_update_requests
  FOR INSERT TO authenticated
  WITH CHECK (solicitante_id = (SELECT auth.uid()));

DROP POLICY IF EXISTS sel_cliente_update_requests ON public.cliente_update_requests;
CREATE POLICY sel_cliente_update_requests ON public.cliente_update_requests
  FOR SELECT TO authenticated
  USING (
    solicitante_id = (SELECT auth.uid())
    OR is_super_role()
  );

-- clientes
DROP POLICY IF EXISTS ins_clientes_asesor ON public.clientes;
CREATE POLICY ins_clientes_asesor ON public.clientes
  FOR INSERT TO authenticated
  WITH CHECK (
    asesor_id = (SELECT auth.uid())
    OR is_super_role()
  );

DROP POLICY IF EXISTS sel_clientes ON public.clientes;
CREATE POLICY sel_clientes ON public.clientes
  FOR SELECT TO authenticated
  USING (
    asesor_id = (SELECT auth.uid())
    OR is_super_role()
  );

-- historial_costos_poliza
DROP POLICY IF EXISTS ins_historial_costos_poliza_super ON public.historial_costos_poliza;
CREATE POLICY ins_historial_costos_poliza_super ON public.historial_costos_poliza
  FOR INSERT TO authenticated
  WITH CHECK (is_super_role());

DROP POLICY IF EXISTS sel_historial_costos_poliza_super ON public.historial_costos_poliza;
CREATE POLICY sel_historial_costos_poliza_super ON public.historial_costos_poliza
  FOR SELECT TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.polizas p
      JOIN public.clientes c ON p.cliente_id = c.id
      WHERE p.id = historial_costos_poliza.poliza_id
        AND (c.asesor_id = (SELECT auth.uid())
             OR is_super_role())
    )
  );

-- logs_integracion
DROP POLICY IF EXISTS logs_integracion_insert_own ON public.logs_integracion;
CREATE POLICY logs_integracion_insert_own ON public.logs_integracion
  FOR INSERT TO authenticated
  WITH CHECK (usuario_id = (SELECT auth.uid()));

DROP POLICY IF EXISTS logs_integracion_select_own_or_admin ON public.logs_integracion;
CREATE POLICY logs_integracion_select_own_or_admin ON public.logs_integracion
  FOR SELECT TO authenticated
  USING (usuario_id = (SELECT auth.uid()) OR is_super_role());

-- planificaciones
DROP POLICY IF EXISTS planificaciones_insert_owner_or_super ON public.planificaciones;
CREATE POLICY planificaciones_insert_owner_or_super ON public.planificaciones
  FOR INSERT TO authenticated
  WITH CHECK (
    agente_id IN (SELECT id FROM public.usuarios WHERE id_auth = (SELECT auth.uid()))
    OR is_super_role()
  );

DROP POLICY IF EXISTS planificaciones_update_owner_or_super ON public.planificaciones;
CREATE POLICY planificaciones_update_owner_or_super ON public.planificaciones
  FOR UPDATE TO authenticated
  USING (
    agente_id IN (SELECT id FROM public.usuarios WHERE id_auth = (SELECT auth.uid()))
    OR is_super_role()
  )
  WITH CHECK (
    agente_id IN (SELECT id FROM public.usuarios WHERE id_auth = (SELECT auth.uid()))
    OR is_super_role()
  );

-- poliza_puntos_cache
DROP POLICY IF EXISTS sel_poliza_puntos_cache ON public.poliza_puntos_cache;
CREATE POLICY sel_poliza_puntos_cache ON public.poliza_puntos_cache
  FOR SELECT TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.polizas p
      JOIN public.clientes c ON p.cliente_id = c.id
      WHERE p.id = poliza_puntos_cache.poliza_id
        AND (c.asesor_id = (SELECT auth.uid())
             OR is_super_role())
    )
  );

-- poliza_update_requests
DROP POLICY IF EXISTS ins_poliza_update_requests ON public.poliza_update_requests;
CREATE POLICY ins_poliza_update_requests ON public.poliza_update_requests
  FOR INSERT TO authenticated
  WITH CHECK (solicitante_id = (SELECT auth.uid()));

DROP POLICY IF EXISTS sel_poliza_update_requests ON public.poliza_update_requests;
CREATE POLICY sel_poliza_update_requests ON public.poliza_update_requests
  FOR SELECT TO authenticated
  USING (
    solicitante_id = (SELECT auth.uid())
    OR is_super_role()
  );

-- polizas
DROP POLICY IF EXISTS sel_polizas ON public.polizas;
CREATE POLICY sel_polizas ON public.polizas
  FOR SELECT TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.clientes c
      WHERE c.id = polizas.cliente_id
        AND (c.asesor_id = (SELECT auth.uid())
             OR is_super_role())
    )
  );

-- prospectos
DROP POLICY IF EXISTS prospectos_insert_agente_supervisor_admin ON public.prospectos;
CREATE POLICY prospectos_insert_agente_supervisor_admin ON public.prospectos
  FOR INSERT TO authenticated
  WITH CHECK (
    agente_id IN (SELECT id FROM public.usuarios WHERE id_auth = (SELECT auth.uid()))
    OR is_super_role()
  );

DROP POLICY IF EXISTS prospectos_update_creator_admin_supervisor ON public.prospectos;
CREATE POLICY prospectos_update_creator_admin_supervisor ON public.prospectos
  FOR UPDATE TO authenticated
  USING (
    agente_id IN (SELECT id FROM public.usuarios WHERE id_auth = (SELECT auth.uid()))
    OR is_super_role()
  )
  WITH CHECK (
    agente_id IN (SELECT id FROM public.usuarios WHERE id_auth = (SELECT auth.uid()))
    OR is_super_role()
  );

-- registro_acciones
DROP POLICY IF EXISTS registro_acciones_select_own_or_super ON public.registro_acciones;
CREATE POLICY registro_acciones_select_own_or_super ON public.registro_acciones
  FOR SELECT TO authenticated
  USING (
    usuario IN (SELECT email FROM public.usuarios WHERE id_auth = (SELECT auth.uid()))
    OR is_super_role()
  );

-- tokens_integracion
DROP POLICY IF EXISTS tokens_integracion_delete_own ON public.tokens_integracion;
CREATE POLICY tokens_integracion_delete_own ON public.tokens_integracion
  FOR DELETE TO authenticated
  USING (usuario_id = (SELECT auth.uid()));

DROP POLICY IF EXISTS tokens_integracion_insert_own ON public.tokens_integracion;
CREATE POLICY tokens_integracion_insert_own ON public.tokens_integracion
  FOR INSERT TO authenticated
  WITH CHECK (usuario_id = (SELECT auth.uid()));

DROP POLICY IF EXISTS tokens_integracion_select_own ON public.tokens_integracion;
CREATE POLICY tokens_integracion_select_own ON public.tokens_integracion
  FOR SELECT TO authenticated
  USING (usuario_id = (SELECT auth.uid()));

DROP POLICY IF EXISTS tokens_integracion_update_own ON public.tokens_integracion;
CREATE POLICY tokens_integracion_update_own ON public.tokens_integracion
  FOR UPDATE TO authenticated
  USING (usuario_id = (SELECT auth.uid()))
  WITH CHECK (usuario_id = (SELECT auth.uid()));

-- user_segments
DROP POLICY IF EXISTS user_segments_select_self ON public.user_segments;
CREATE POLICY user_segments_select_self ON public.user_segments
  FOR SELECT TO authenticated
  USING (
    usuario_id IN (SELECT id FROM public.usuarios WHERE id_auth = (SELECT auth.uid()))
    OR is_super_role()
  );

-- usuarios
DROP POLICY IF EXISTS usuarios_update_admin_supervisor_self ON public.usuarios;
CREATE POLICY usuarios_update_admin_supervisor_self ON public.usuarios
  FOR UPDATE TO authenticated
  USING (
    id_auth = (SELECT auth.uid())
    OR is_super_role()
  )
  WITH CHECK (
    id_auth = (SELECT auth.uid())
    OR is_super_role()
  );

-- =====================================================
-- SECTION 2: ADD MISSING FOREIGN KEY INDEXES (13 total)
-- =====================================================

-- candidatos foreign keys
CREATE INDEX IF NOT EXISTS idx_candidatos_usuario_creador ON public.candidatos(usuario_creador);
CREATE INDEX IF NOT EXISTS idx_candidatos_usuario_que_actualizo ON public.candidatos(usuario_que_actualizo);

-- producto_parametros foreign keys
CREATE INDEX IF NOT EXISTS idx_producto_parametros_product_type_id ON public.producto_parametros(product_type_id);

-- clientes foreign keys
CREATE INDEX IF NOT EXISTS idx_clientes_inactivado_por ON public.clientes(inactivado_por);

-- poliza_puntos_cache foreign keys
CREATE INDEX IF NOT EXISTS idx_poliza_puntos_cache_producto_parametro_id ON public.poliza_puntos_cache(producto_parametro_id);

-- cliente_historial foreign keys
CREATE INDEX IF NOT EXISTS idx_cliente_historial_cliente_id ON public.cliente_historial(cliente_id);

-- cliente_update_requests foreign keys
CREATE INDEX IF NOT EXISTS idx_cliente_update_requests_cliente_id ON public.cliente_update_requests(cliente_id);

-- historial_costos_poliza foreign keys
CREATE INDEX IF NOT EXISTS idx_historial_costos_poliza_poliza_id ON public.historial_costos_poliza(poliza_id);

-- poliza_update_requests foreign keys
CREATE INDEX IF NOT EXISTS idx_poliza_update_requests_poliza_id ON public.poliza_update_requests(poliza_id);

-- citas foreign keys
CREATE INDEX IF NOT EXISTS idx_citas_prospecto_id ON public.citas(prospecto_id);

-- user_segments foreign keys
CREATE INDEX IF NOT EXISTS idx_user_segments_assigned_by ON public.user_segments(assigned_by);

-- campaigns foreign keys
CREATE INDEX IF NOT EXISTS idx_campaigns_created_by ON public.campaigns(created_by);
CREATE INDEX IF NOT EXISTS idx_campaigns_primary_segment_id ON public.campaigns(primary_segment_id);

-- =====================================================
-- SECTION 3: ADD POLICIES TO TABLES WITH RLS BUT NO POLICIES
-- These tables currently have RLS enabled but no policies (4 tables)
-- =====================================================

-- dias_mes (lookup table - read-only for all authenticated users)
CREATE POLICY dias_mes_select_all ON public.dias_mes
  FOR SELECT TO authenticated
  USING (true);

CREATE POLICY dias_mes_insert_super ON public.dias_mes
  FOR INSERT TO authenticated
  WITH CHECK (is_super_role());

CREATE POLICY dias_mes_update_super ON public.dias_mes
  FOR UPDATE TO authenticated
  USING (is_super_role())
  WITH CHECK (is_super_role());

CREATE POLICY dias_mes_delete_super ON public.dias_mes
  FOR DELETE TO authenticated
  USING (is_super_role());

-- fx_values (financial data - read-only for all authenticated users)
CREATE POLICY fx_values_select_all ON public.fx_values
  FOR SELECT TO authenticated
  USING (true);

CREATE POLICY fx_values_insert_super ON public.fx_values
  FOR INSERT TO authenticated
  WITH CHECK (is_super_role());

CREATE POLICY fx_values_update_super ON public.fx_values
  FOR UPDATE TO authenticated
  USING (is_super_role())
  WITH CHECK (is_super_role());

CREATE POLICY fx_values_delete_super ON public.fx_values
  FOR DELETE TO authenticated
  USING (is_super_role());

-- producto_parametros (product config - read for all, write for super)
CREATE POLICY producto_parametros_select_all ON public.producto_parametros
  FOR SELECT TO authenticated
  USING (true);

CREATE POLICY producto_parametros_insert_super ON public.producto_parametros
  FOR INSERT TO authenticated
  WITH CHECK (is_super_role());

CREATE POLICY producto_parametros_update_super ON public.producto_parametros
  FOR UPDATE TO authenticated
  USING (is_super_role())
  WITH CHECK (is_super_role());

CREATE POLICY producto_parametros_delete_super ON public.producto_parametros
  FOR DELETE TO authenticated
  USING (is_super_role());

-- udi_values (financial data - read-only for all authenticated users)
CREATE POLICY udi_values_select_all ON public.udi_values
  FOR SELECT TO authenticated
  USING (true);

CREATE POLICY udi_values_insert_super ON public.udi_values
  FOR INSERT TO authenticated
  WITH CHECK (is_super_role());

CREATE POLICY udi_values_update_super ON public.udi_values
  FOR UPDATE TO authenticated
  USING (is_super_role())
  WITH CHECK (is_super_role());

CREATE POLICY udi_values_delete_super ON public.udi_values
  FOR DELETE TO authenticated
  USING (is_super_role());

-- =====================================================
-- SECTION 4: UNUSED INDEXES DOCUMENTATION
-- The following 32 indexes show 0 scans but are kept because:
-- - They may be used during low-traffic periods or specific operations
-- - Unique constraints (ux_, _key) are required for data integrity
-- - Some are needed for specific query patterns not yet in production
-- 
-- If these indexes cause performance issues, they can be dropped individually.
-- Monitor pg_stat_user_indexes over time to confirm true unused status.
-- =====================================================

-- Notable unused indexes to review later:
-- - idx_registro_acciones_* (3 indexes, 456 kB total)
-- - Unique constraints on candidatos, clientes (required for integrity)
-- - Date/status indexes that may be used in reports

-- =====================================================
-- END OF MIGRATION
-- =====================================================


-- FILE: 20251211_fix_8_remaining_functions.sql
-- =====================================================
-- Migration: Fix remaining 8 poliza/cliente functions
-- Date: 2024-12-11
-- Description: Add explicit public. schema to all table references
-- =====================================================

-- apply_cliente_update
CREATE OR REPLACE FUNCTION public.apply_cliente_update(p_request_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
DECLARE
  v_cliente_id uuid;
  v_payload jsonb;
  r_old public.clientes%ROWTYPE;
  r_new public.clientes%ROWTYPE;
BEGIN
  IF NOT public.is_super_role() THEN
    RAISE EXCEPTION 'permiso denegado (se requiere supervisor/super_usuario)';
  END IF;

  SELECT cliente_id, payload_propuesto
    INTO v_cliente_id, v_payload
  FROM public.cliente_update_requests
  WHERE id = p_request_id AND estado = 'PENDIENTE'
  FOR UPDATE;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'solicitud no encontrada o no pendiente';
  END IF;

  SELECT * INTO r_old FROM public.clientes WHERE id = v_cliente_id FOR UPDATE;

  -- Actualiza campos permitidos (usa COALESCE para mantener si no viene en payload)
  UPDATE public.clientes SET
    primer_nombre      = COALESCE(UPPER(TRIM(v_payload->>'primer_nombre')), primer_nombre),
    segundo_nombre     = COALESCE(UPPER(TRIM(v_payload->>'segundo_nombre')), segundo_nombre),
    primer_apellido    = COALESCE(UPPER(TRIM(v_payload->>'primer_apellido')), primer_apellido),
    segundo_apellido   = COALESCE(UPPER(TRIM(v_payload->>'segundo_apellido')), segundo_apellido),
    telefono_celular   = COALESCE(TRIM(v_payload->>'telefono_celular'), telefono_celular),
    correo             = COALESCE(LOWER(TRIM(v_payload->>'correo')), correo),
    full_name_normalizado = UPPER(TRIM(
      COALESCE(v_payload->>'primer_nombre', primer_nombre) || ' ' ||
      COALESCE(v_payload->>'segundo_nombre', COALESCE(segundo_nombre,'')) || ' ' ||
      COALESCE(v_payload->>'primer_apellido', primer_apellido) || ' ' ||
      COALESCE(v_payload->>'segundo_apellido', segundo_apellido)
    )),
    updated_at = now()
  WHERE id = v_cliente_id;

  SELECT * INTO r_new FROM public.clientes WHERE id = v_cliente_id;

  INSERT INTO public.cliente_historial (
    id, cliente_id, cambio_tipo, payload_old, payload_new, actor_id, creado_at
  ) VALUES (
    gen_random_uuid(), v_cliente_id, 'APROBACION', to_jsonb(r_old), to_jsonb(r_new), auth.uid(), now()
  );

  UPDATE public.cliente_update_requests
  SET estado = 'APROBADA', resuelto_at = now(), resuelto_por = auth.uid()
  WHERE id = p_request_id;
END;
$function$
;

-- apply_poliza_update
CREATE OR REPLACE FUNCTION public.apply_poliza_update(p_request_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
DECLARE
  v_poliza_id uuid;
  v_payload jsonb;
  v_estado text;
  r_old public.polizas%ROWTYPE;
  r_new public.polizas%ROWTYPE;
  v_old_prima numeric(14,2);
  v_new_prima numeric(14,2);
  v_periodicidad_raw text;
  v_periodicidad_txt text;
BEGIN
  IF NOT public.is_super_role() THEN
    RAISE EXCEPTION 'permiso denegado (se requiere supervisor/super_usuario)';
  END IF;

  -- Leer la solicitud SIN FOR UPDATE (parece causar que no se devuelva fila en RLS)
  SELECT poliza_id, payload_propuesto, estado
    INTO v_poliza_id, v_payload, v_estado
  FROM public.poliza_update_requests
  WHERE id = p_request_id;

  IF v_poliza_id IS NULL THEN
    RAISE EXCEPTION 'solicitud no encontrada';
  END IF;
  IF v_estado <> 'PENDIENTE' THEN
    RAISE EXCEPTION 'solicitud no pendiente (estado=%)', v_estado;
  END IF;

  -- Bloquear la pÃ³liza (evita condiciones de carrera)
  SELECT * INTO r_old FROM public.polizas WHERE id = v_poliza_id FOR UPDATE;

  v_periodicidad_raw := NULLIF(v_payload->>'periodicidad_pago','');
  IF v_periodicidad_raw IS NOT NULL THEN
    v_periodicidad_raw := upper(trim(v_periodicidad_raw));
    IF v_periodicidad_raw IN ('A','ANUAL','ANUALIDAD') THEN v_periodicidad_txt := 'A';
    ELSIF v_periodicidad_raw IN ('S','SEMESTRAL','SEMESTRA') THEN v_periodicidad_txt := 'S';
    ELSIF v_periodicidad_raw IN ('T','TRIMESTRAL','TRIMESTRE') THEN v_periodicidad_txt := 'T';
    ELSIF v_periodicidad_raw IN ('M','MENSUAL','MES') THEN v_periodicidad_txt := 'M';
    ELSIF v_periodicidad_raw IN ('A','S','T','M') THEN v_periodicidad_txt := v_periodicidad_raw; ELSE v_periodicidad_txt := NULL; END IF;
  END IF;

  UPDATE public.polizas SET
    numero_poliza         = COALESCE(NULLIF(TRIM(v_payload->>'numero_poliza'),''), numero_poliza),
    estatus               = COALESCE(NULLIF(v_payload->>'estatus','')::public.estatus_poliza, estatus),
    fecha_emision         = COALESCE(NULLIF(v_payload->>'fecha_emision','')::date, fecha_emision),
    fecha_renovacion      = COALESCE(NULLIF(v_payload->>'fecha_renovacion','')::date, fecha_renovacion),
    forma_pago            = COALESCE(NULLIF(v_payload->>'forma_pago','')::forma_pago, forma_pago),
    periodicidad_pago     = COALESCE((CASE WHEN v_periodicidad_txt IS NOT NULL THEN v_periodicidad_txt::public.periodicidad_pago END), periodicidad_pago),
    dia_pago              = COALESCE(NULLIF(v_payload->>'dia_pago','')::int, dia_pago),
    prima_input           = COALESCE(NULLIF(v_payload->>'prima_input','')::numeric, prima_input),
    prima_moneda          = COALESCE(NULLIF(v_payload->>'prima_moneda','')::public.moneda_poliza, prima_moneda),
    sa_input              = COALESCE(NULLIF(v_payload->>'sa_input','')::numeric, sa_input),
    sa_moneda             = COALESCE(NULLIF(v_payload->>'sa_moneda','')::public.moneda_poliza, sa_moneda),
    producto_parametro_id = COALESCE(NULLIF(v_payload->>'producto_parametro_id','')::uuid, producto_parametro_id),
    meses_check           = COALESCE((CASE WHEN jsonb_typeof(v_payload->'meses_check')='object' THEN v_payload->'meses_check' END), meses_check),
    updated_at            = now()
  WHERE id = v_poliza_id;

  SELECT * INTO r_new FROM public.polizas WHERE id = v_poliza_id;

  v_old_prima := r_old.prima_input;
  v_new_prima := r_new.prima_input;
  IF v_old_prima IS DISTINCT FROM v_new_prima THEN
    INSERT INTO public.historial_costos_poliza(
      id, poliza_id, prima_anual_old, prima_anual_new, porcentaje_comision_old, porcentaje_comision_new, actor_id, creado_at
    ) VALUES (
      gen_random_uuid(), v_poliza_id, v_old_prima, v_new_prima, NULL, NULL, auth.uid(), now()
    );
  END IF;

  UPDATE public.poliza_update_requests
  SET estado='APROBADA', resuelto_at=now(), resuelto_por=auth.uid()
  WHERE id = p_request_id AND estado='PENDIENTE';

  PERFORM public.recalc_puntos_poliza(v_poliza_id);
END;
$function$
;

-- apply_poliza_update_dbg
CREATE OR REPLACE FUNCTION public.apply_poliza_update_dbg(p_request_id uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
DECLARE
  v_row public.poliza_update_requests%ROWTYPE;
  v_is_super boolean;
  v_poliza_before public.polizas%ROWTYPE;
  v_poliza_after public.polizas%ROWTYPE;
  v_err text;
  v_state text;
BEGIN
  v_is_super := public.is_super_role();
  SELECT * INTO v_row FROM public.poliza_update_requests WHERE id = p_request_id;
  IF v_row.poliza_id IS NOT NULL THEN
    SELECT * INTO v_poliza_before FROM public.polizas WHERE id = v_row.poliza_id;
  END IF;
  BEGIN
    PERFORM apply_poliza_update(p_request_id);
    IF v_row.poliza_id IS NOT NULL THEN
      SELECT * INTO v_poliza_after FROM public.polizas WHERE id = v_row.poliza_id;
    END IF;
    RETURN jsonb_build_object(
      'status','ok',
      'is_super', v_is_super,
      'request_row', to_jsonb(v_row),
      'poliza_before', to_jsonb(v_poliza_before),
      'poliza_after', to_jsonb(v_poliza_after)
    );
  EXCEPTION WHEN OTHERS THEN
    v_err := SQLERRM; v_state := SQLSTATE;
    RETURN jsonb_build_object(
      'status','error',
      'is_super', v_is_super,
      'sqlstate', v_state,
      'error', v_err,
      'request_row', to_jsonb(v_row)
    );
  END;
END;
$function$
;

-- polizas_before_insupd_enforce_moneda
CREATE OR REPLACE FUNCTION public.polizas_before_insupd_enforce_moneda()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
DECLARE
  v_moneda public.moneda_poliza;
BEGIN
  IF NEW.producto_parametro_id IS NOT NULL THEN
    SELECT moneda INTO v_moneda FROM public.producto_parametros WHERE id = NEW.producto_parametro_id;
    IF v_moneda IS NOT NULL THEN
      NEW.prima_moneda := v_moneda;
      NEW.sa_moneda := v_moneda;
    END IF;
  END IF;
  RETURN NEW;
END;
$function$
;

-- producto_parametros_after_update_sync_moneda
CREATE OR REPLACE FUNCTION public.producto_parametros_after_update_sync_moneda()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
DECLARE
  v_changed boolean := false;
  v_updated int := 0;
BEGIN
  IF NEW.moneda IS DISTINCT FROM OLD.moneda THEN
    v_changed := true;
  END IF;

  IF v_changed THEN
    -- Si la nueva moneda es NULL, no forzamos sincronizaciÃ³n (sin especificaciÃ³n de moneda)
    IF NEW.moneda IS NOT NULL THEN
      -- Actualizar moneda de primas y suma asegurada de pÃ³lizas que apuntan a este producto
      UPDATE public.polizas
        SET prima_moneda = NEW.moneda,
            sa_moneda = NEW.moneda,
            updated_at = now()
        WHERE producto_parametro_id = NEW.id
          AND (
            prima_moneda IS DISTINCT FROM NEW.moneda
            OR sa_moneda IS DISTINCT FROM NEW.moneda
            OR sa_moneda IS NULL
          );
    END IF;

    -- Recalcular cache/puntos de las pÃ³lizas afectadas
    PERFORM recalc_polizas_by_producto_parametro(NEW.id);
  END IF;
  RETURN NEW;
END;
$function$
;

-- recalc_polizas_by_producto_parametro
CREATE OR REPLACE FUNCTION public.recalc_polizas_by_producto_parametro(p_pp_id uuid)
 RETURNS integer
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
DECLARE
  v_count int := 0;
  r RECORD;
BEGIN
  FOR r IN SELECT id FROM public.polizas WHERE producto_parametro_id = p_pp_id LOOP
    PERFORM public.recalc_puntos_poliza(r.id);
    v_count := v_count + 1;
  END LOOP;
  RETURN v_count;
END;
$function$
;

-- recalc_puntos_poliza
CREATE OR REPLACE FUNCTION public.recalc_puntos_poliza(p_poliza_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
declare
  v_prima_input numeric;
  v_prima_mxn numeric;
  v_prima_moneda public.moneda_poliza;
  v_sa_mxn numeric;
  v_sa_input numeric;
  v_sa_moneda public.moneda_poliza;
  v_tipo_code text;
  v_tipo_name text;
  v_tipo_id uuid;
  v_estatus public.estatus_poliza;
  v_pp_id uuid;
  v_year int;
  v_base_factor numeric;
  v_puntos numeric;
  v_clas public.tipo_clasificacion_puntos;
  v_fx numeric;
  v_udi numeric;
  v_fecha date;
  v_pp_auto uuid;
  v_sa_mxn_live numeric;
begin
  select p.prima_input, p.prima_mxn, p.prima_moneda, p.sa_mxn, p.sa_input, p.sa_moneda,
         p.estatus, p.producto_parametro_id, p.fecha_emision
    into v_prima_input, v_prima_mxn, v_prima_moneda, v_sa_mxn, v_sa_input, v_sa_moneda,
         v_estatus, v_pp_id, v_fecha
  FROM public.polizas p
  where p.id = p_poliza_id;

  if not found then
    raise exception 'poliza % no existe', p_poliza_id;
  end if;

  v_prima_mxn := normalize_prima(v_prima_input, v_prima_moneda, current_date);

  v_fx := null; v_udi := null;
  if v_prima_moneda = 'USD'::public.moneda_poliza then
    select get_fx_usd(current_date) into v_fx;
  elsif v_prima_moneda = 'UDI'::public.moneda_poliza then
    select get_current_udi(current_date) into v_udi;
  end if;

  if v_sa_input is not null and v_sa_moneda is not null then
    v_sa_mxn_live := normalize_prima(v_sa_input, v_sa_moneda, current_date);
  else
    v_sa_mxn_live := null;
  end if;

  if v_pp_id is null then
    select pp.id
      into v_pp_auto
    FROM public.producto_parametros pp
    where pp.activo = true
      and (pp.moneda is null or pp.moneda = v_prima_moneda)
      and (
        v_sa_mxn_live is null
        or (
          (pp.sa_min is null or v_sa_mxn_live >= pp.sa_min)
          and (pp.sa_max is null or v_sa_mxn_live <= pp.sa_max)
        )
      )
    order by
      case when pp.moneda = v_prima_moneda then 0 else 1 end,
      coalesce(pp.sa_min, (-1)::numeric) desc
    limit 1;

    if v_pp_auto is not null then
      v_pp_id := v_pp_auto;
      UPDATE public.polizas set producto_parametro_id = v_pp_auto, updated_at = now()
      where id = p_poliza_id;
    end if;
  end if;

  if v_estatus = 'ANULADA'::public.estatus_poliza then
    v_puntos := 0;
    v_clas := 'CERO';
    v_tipo_code := null;
    v_tipo_name := null;
    v_tipo_id := null;
  else
    if v_pp_id is not null then
      select pt.code, pt.name, pt.id
        into v_tipo_code, v_tipo_name, v_tipo_id
      FROM public.producto_parametros pp
      JOIN public.product_types pt on pt.id = pp.product_type_id
      where pp.id = v_pp_id;
    else
      v_tipo_code := null;
      v_tipo_name := null;
      v_tipo_id := null;
    end if;

    if v_tipo_code is not null then
      v_tipo_code := upper(v_tipo_code);
    end if;

    if v_tipo_code = 'GMM' then
      if v_prima_mxn is not null and v_prima_mxn >= 7500 then
        v_puntos := 0.5; v_clas := 'MEDIO';
      else
        v_puntos := 0; v_clas := 'CERO';
      end if;
    elsif v_tipo_code = 'VI' then
      if v_prima_mxn is null or v_prima_mxn < 15000 then
        v_puntos := 0; v_clas := 'CERO';
      elsif v_prima_mxn >= 150000 then
        v_puntos := 3; v_clas := 'TRIPLE';
      elsif v_prima_mxn >= 50000 then
        v_puntos := 2; v_clas := 'DOBLE';
      else
        v_puntos := 1; v_clas := 'SIMPLE';
      end if;
    else
      v_puntos := 0; v_clas := 'CERO';
    end if;
  end if;

  select poliza_year_vigencia(p.fecha_emision) into v_year
  FROM public.polizas p where p.id = p_poliza_id;

  if v_pp_id is not null and v_estatus = 'EN_VIGOR'::public.estatus_poliza then
    select case
             when coalesce(duracion_anios, 9999) <= 10 then
               case least(v_year, coalesce(duracion_anios, 10))
                 when 1 then anio_1_percent
                 when 2 then anio_2_percent
                 when 3 then anio_3_percent
                 when 4 then anio_4_percent
                 when 5 then anio_5_percent
                 when 6 then anio_6_percent
                 when 7 then anio_7_percent
                 when 8 then anio_8_percent
                 when 9 then anio_9_percent
                 when 10 then anio_10_percent
                 else null
               end
             else
               case
                 when v_year = 1 then anio_1_percent
                 when v_year = 2 then anio_2_percent
                 when v_year = 3 then anio_3_percent
                 when v_year = 4 then anio_4_percent
                 when v_year = 5 then anio_5_percent
                 when v_year = 6 then anio_6_percent
                 when v_year = 7 then anio_7_percent
                 when v_year = 8 then anio_8_percent
                 when v_year = 9 then anio_9_percent
                 when v_year = 10 then anio_10_percent
                 else anio_11_plus_percent
               end
           end
      into v_base_factor
    FROM public.producto_parametros
    where id = v_pp_id;
  else
    v_base_factor := null;
  end if;

  v_puntos := coalesce(v_puntos, 0);
  v_clas := coalesce(v_clas, 'CERO');

  insert INTO public.poliza_puntos_cache (
    poliza_id, puntos_total, clasificacion, base_factor, producto_factor,
    year_factor, prima_anual_snapshot, producto_parametro_id, udi_valor, usd_fx,
    breakdown, recalculo_reason, computed_at, updated_at
  )
  select p.id, v_puntos, v_clas, v_base_factor, null,
         v_year, v_prima_mxn, v_pp_id, v_udi, v_fx,
         jsonb_build_object(
           'year', v_year,
           'factor_base', v_base_factor,
           'producto', v_tipo_code,
           'producto_nombre', v_tipo_name,
           'producto_type_id', v_tipo_id,
           'prima_mxn', v_prima_mxn,
           'sa_mxn', v_sa_mxn_live,
           'prima_moneda', v_prima_moneda,
           'fx_aplicado', v_fx,
           'udi_aplicada', v_udi,
           'tasas_fecha', to_char(current_date, 'YYYY-MM-DD')
         ),
         'recalc', now(), now()
  FROM public.polizas p where p.id = p_poliza_id
  on conflict (poliza_id) do update set
    puntos_total = excluded.puntos_total,
    clasificacion = excluded.clasificacion,
    base_factor = excluded.base_factor,
    producto_factor = excluded.producto_factor,
    year_factor = excluded.year_factor,
    prima_anual_snapshot = excluded.prima_anual_snapshot,
    producto_parametro_id = excluded.producto_parametro_id,
    udi_valor = excluded.udi_valor,
    usd_fx = excluded.usd_fx,
    breakdown = excluded.breakdown,
    recalculo_reason = excluded.recalculo_reason,
    computed_at = excluded.computed_at,
    updated_at = excluded.updated_at;
end;
$function$
;

-- recalc_puntos_poliza_all
CREATE OR REPLACE FUNCTION public.recalc_puntos_poliza_all(p_limit integer DEFAULT NULL::integer)
 RETURNS integer
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
DECLARE
  v_count int := 0;
  r RECORD;
BEGIN
  FOR r IN 
    SELECT id FROM public.polizas
    ORDER BY updated_at DESC
    LIMIT COALESCE(p_limit, 2147483647)
  LOOP
    PERFORM public.recalc_puntos_poliza(r.id);
    v_count := v_count + 1;
  END LOOP;
  RETURN v_count;
END;
$function$
;

COMMENT ON FUNCTION public.apply_cliente_update(uuid) IS 'Aplica actualizaciÃ³n de cliente con schema explÃ­cito';
COMMENT ON FUNCTION public.apply_poliza_update(uuid) IS 'Aplica actualizaciÃ³n de pÃ³liza con schema explÃ­cito';
COMMENT ON FUNCTION public.recalc_puntos_poliza(uuid) IS 'Recalcula puntos de pÃ³liza con schema explÃ­cito';


-- FILE: 20251211_fix_all_usuarios_functions.sql
-- =====================================================
-- Migration: Fix remaining functions with usuarios references
-- Date: 2024-12-11
-- Description: Add public. schema to all usuarios references
--              in functions with empty search_path
-- =====================================================

-- Fix calculate_campaign_datasets_for_user
CREATE OR REPLACE FUNCTION public.calculate_campaign_datasets_for_user(p_usuario_id bigint)
 RETURNS jsonb
 LANGUAGE plpgsql
 STABLE
 SET search_path TO ''
AS $function$
DECLARE
    v_id_auth uuid;
    v_result jsonb := '{}'::jsonb;
    v_polizas_prima_minima jsonb;
    v_polizas_recientes jsonb;
    v_polizas_por_producto jsonb;
BEGIN
    -- Get the auth UUID for the user
    SELECT id_auth INTO v_id_auth
    FROM public.usuarios
    WHERE id = p_usuario_id;

    IF v_id_auth IS NULL THEN
        RETURN v_result;
    END IF;

    -- Calculate polizas_prima_minima: count policies by minimum premium threshold
    WITH policy_data AS (
        SELECT
            p.id,
            p.prima_mxn,
            p.fecha_emision,
            p.estatus
        FROM public.polizas p
        JOIN public.clientes c ON c.id = p.cliente_id
        WHERE c.asesor_id = v_id_auth
          AND p.estatus != 'ANULADA'
    )
    SELECT jsonb_build_object(
        'prima_25000', (SELECT COUNT(*) FROM policy_data WHERE prima_mxn >= 25000),
        'prima_50000', (SELECT COUNT(*) FROM policy_data WHERE prima_mxn >= 50000),
        'prima_100000', (SELECT COUNT(*) FROM policy_data WHERE prima_mxn >= 100000)
    ) INTO v_polizas_prima_minima;

    v_result := jsonb_set(v_result, '{polizas_prima_minima}', v_polizas_prima_minima);

    -- Calculate polizas_recientes: count recent policies within time windows
    WITH policy_data AS (
        SELECT
            p.id,
            p.prima_mxn,
            p.fecha_emision,
            p.estatus,
            p.cliente_id,
            (CURRENT_DATE - p.fecha_emision) as dias_desde_emision
        FROM public.polizas p
        JOIN public.clientes c ON c.id = p.cliente_id
        WHERE c.asesor_id = v_id_auth
          AND p.estatus != 'ANULADA'
    ),
    recent_counts AS (
        SELECT
            COUNT(*) FILTER (WHERE dias_desde_emision <= 30) as recientes_30,
            COUNT(*) FILTER (WHERE dias_desde_emision <= 90) as recientes_90,
            COUNT(*) FILTER (WHERE dias_desde_emision <= 180) as recientes_180,
            COUNT(*) FILTER (WHERE dias_desde_emision <= 365) as recientes_365,
            MIN(dias_desde_emision) as ultima_emision_dias
        FROM policy_data
    )
    SELECT jsonb_build_object(
        'ventana_30', recientes_30,
        'ventana_90', recientes_90,
        'ventana_180', recientes_180,
        'ventana_365', recientes_365,
        'ultima_emision_dias', COALESCE(ultima_emision_dias, 999999)
    ) INTO v_polizas_recientes
    FROM recent_counts;

    v_result := jsonb_set(v_result, '{polizas_recientes}', v_polizas_recientes);

    -- Calculate polizas_por_producto: count policies by product type
    WITH policy_by_product AS (
        SELECT
            pp.product_type_id,
            pt.code as product_code,
            COUNT(*) as cantidad
        FROM public.polizas p
        JOIN public.clientes c ON c.id = p.cliente_id
        LEFT JOIN public.producto_parametros pp ON pp.id = p.producto_parametro_id
        LEFT JOIN public.product_types pt ON pt.id = pp.product_type_id
        WHERE c.asesor_id = v_id_auth
          AND p.estatus != 'ANULADA'
        GROUP BY pp.product_type_id, pt.code
    )
    SELECT jsonb_object_agg(
        COALESCE(product_code, 'sin_tipo'),
        cantidad
    ) INTO v_polizas_por_producto
    FROM policy_by_product;

    v_result := jsonb_set(v_result, '{polizas_por_producto}', COALESCE(v_polizas_por_producto, '{}'::jsonb));

    RETURN v_result;
END;
$function$;

-- Fix evaluate_all_campaigns
CREATE OR REPLACE FUNCTION public.evaluate_all_campaigns()
 RETURNS TABLE(usuarios_procesados integer, campanas_evaluadas integer, snapshots_actualizados integer, duracion_ms bigint)
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
DECLARE
  v_start_time timestamp;
  v_end_time timestamp;
  v_usuarios_count integer := 0;
  v_campanas_count integer := 0;
  v_snapshots_count integer := 0;
  v_usuario_id integer;
  v_campaign_id uuid;
BEGIN
  v_start_time := clock_timestamp();

  DELETE FROM public.campaign_progress
  WHERE evaluated_at < NOW() - INTERVAL '30 minutes';

  GET DIAGNOSTICS v_snapshots_count = ROW_COUNT;

  SELECT COUNT(DISTINCT u.id) INTO v_usuarios_count
  FROM public.usuarios u
  WHERE u.activo = true
    AND u.rol IN ('agente', 'asesor', 'supervisor');

  SELECT COUNT(*) INTO v_campanas_count
  FROM public.campaigns
  WHERE status = 'active'
    AND active_range @> CURRENT_DATE;

  v_end_time := clock_timestamp();

  RAISE NOTICE 'Limpieza de cache completada: % snapshots eliminados, % usuarios activos, % campaÃ±as activas',
    v_snapshots_count, v_usuarios_count, v_campanas_count;

  RETURN QUERY SELECT
    v_usuarios_count,
    v_campanas_count,
    v_snapshots_count,
    EXTRACT(MILLISECONDS FROM (v_end_time - v_start_time))::bigint;
END;
$function$;

-- Fix transfer_reassign_usuario
CREATE OR REPLACE FUNCTION public.transfer_reassign_usuario(p_old_id bigint, p_new_id bigint, p_actor_email text DEFAULT NULL::text)
 RETURNS json
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
declare
  old_usr record;
  new_usr record;
  moved_prospectos bigint := 0;
  moved_planificaciones bigint := 0;
  moved_agente_meta bigint := 0;
  moved_clientes bigint := 0;
  moved_citas_agente bigint := 0;
  moved_citas_super bigint := 0;
begin
  if p_old_id = p_new_id then
    raise exception 'El usuario destino debe ser diferente al usuario original';
  end if;

  select id, email, rol, activo, id_auth into old_usr from public.usuarios where id = p_old_id;
  if not found then
    raise exception 'Usuario origen no existe';
  end if;

  select id, email, rol, activo, id_auth into new_usr from public.usuarios where id = p_new_id;
  if not found then
    raise exception 'Usuario destino no existe';
  end if;
  if not new_usr.activo then
    raise exception 'El usuario destino no estÃ¡ activo';
  end if;
  if new_usr.id_auth is null then
    raise exception 'Usuario destino no tiene id_auth asignado';
  end if;

  update public.prospectos
     set agente_id = new_usr.id
   where agente_id = old_usr.id;
  get diagnostics moved_prospectos = row_count;

  update public.planificaciones
     set agente_id = new_usr.id
   where agente_id = old_usr.id;
  get diagnostics moved_planificaciones = row_count;

  update public.agente_meta
     set usuario_id = new_usr.id
   where usuario_id = old_usr.id;
  get diagnostics moved_agente_meta = row_count;

  if old_usr.id_auth is not null then
    update public.clientes
       set asesor_id = new_usr.id_auth
     where asesor_id = old_usr.id_auth;
    get diagnostics moved_clientes = row_count;

    update public.citas
       set agente_id = new_usr.id_auth
     where agente_id = old_usr.id_auth;
    get diagnostics moved_citas_agente = row_count;

    update public.citas
       set supervisor_id = new_usr.id_auth
     where supervisor_id = old_usr.id_auth;
    get diagnostics moved_citas_super = row_count;
  end if;

  delete from public.usuarios where id = old_usr.id;

  return json_build_object(
    'prospectos', moved_prospectos,
    'planificaciones', moved_planificaciones,
    'agente_meta', moved_agente_meta,
    'clientes', moved_clientes,
    'citas_agente', moved_citas_agente,
    'citas_supervisor', moved_citas_super
  );
end;
$function$;

-- Fix trigger_invalidate_cache_on_candidatos
CREATE OR REPLACE FUNCTION public.trigger_invalidate_cache_on_candidatos()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
DECLARE
  v_usuario_id bigint;
BEGIN
  IF (TG_OP = 'UPDATE' AND OLD.mes_conexion IS DISTINCT FROM NEW.mes_conexion)
     OR TG_OP = 'INSERT' THEN

    SELECT u.id INTO v_usuario_id
    FROM public.usuarios u
    WHERE LOWER(u.email) = LOWER(COALESCE(NEW.email_agente, ''))
    LIMIT 1;

    IF v_usuario_id IS NOT NULL THEN
      PERFORM public.invalidate_campaign_cache_for_user(v_usuario_id);
    END IF;
  END IF;

  RETURN NEW;
END;
$function$;

-- Fix trigger_invalidate_cache_on_clientes
CREATE OR REPLACE FUNCTION public.trigger_invalidate_cache_on_clientes()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
DECLARE
  v_usuario_id bigint;
BEGIN
  SELECT u.id INTO v_usuario_id
  FROM public.usuarios u
  WHERE u.id_auth = COALESCE(NEW.asesor_id, OLD.asesor_id)
  LIMIT 1;

  IF v_usuario_id IS NOT NULL THEN
    PERFORM public.invalidate_campaign_cache_for_user(v_usuario_id);
  END IF;

  RETURN COALESCE(NEW, OLD);
END;
$function$;

-- Fix trigger_invalidate_cache_on_prospectos
CREATE OR REPLACE FUNCTION public.trigger_invalidate_cache_on_prospectos()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
DECLARE
  v_usuario_id bigint;
BEGIN
  SELECT u.id INTO v_usuario_id
  FROM public.usuarios u
  WHERE u.id = COALESCE(NEW.agente_id, OLD.agente_id)
  LIMIT 1;

  IF v_usuario_id IS NOT NULL THEN
    PERFORM public.invalidate_campaign_cache_for_user(v_usuario_id);
  END IF;

  RETURN COALESCE(NEW, OLD);
END;
$function$;

COMMENT ON FUNCTION public.calculate_campaign_datasets_for_user(bigint) IS 'Calcula datasets de campaÃ±a con schema explÃ­cito';
COMMENT ON FUNCTION public.trigger_invalidate_cache_on_prospectos() IS 'Invalida cache de campaÃ±as al cambiar prospectos con schema explÃ­cito';


-- FILE: 20251211_fix_invalidate_cache_function.sql
-- =====================================================
-- Migration: Fix invalidate_campaign_cache_for_user
-- Date: 2024-12-11
-- Description: Add explicit schema to campaign_progress
-- =====================================================

CREATE OR REPLACE FUNCTION public.invalidate_campaign_cache_for_user(p_usuario_id bigint)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
BEGIN
  DELETE FROM public.campaign_progress WHERE usuario_id = p_usuario_id;
END;
$function$;

COMMENT ON FUNCTION public.invalidate_campaign_cache_for_user(bigint) IS 'Invalida cache de campaÃ±as para un usuario con schema explÃ­cito';


-- FILE: 20251211_fix_is_super_role_search_path.sql
-- =====================================================
-- Migration: Fix is_super_role search_path for security
-- Date: 2024-12-11
-- Description: Update is_super_role to use explicit schema
--              and empty search_path for security
-- =====================================================

CREATE OR REPLACE FUNCTION public.is_super_role()
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  v_is_super boolean := false;
BEGIN
  -- Check usuarios table by id_auth (requires usuarios.id_auth populated)
  SELECT TRUE INTO v_is_super
  FROM public.usuarios
  WHERE id_auth = auth.uid()
    AND activo IS TRUE
    AND lower(rol) IN ('supervisor','admin')
  LIMIT 1;

  IF v_is_super THEN
    RETURN TRUE;
  END IF;

  -- Fallback: check JWT role claim
  RETURN public.jwt_role() IN ('supervisor','admin');
END;
$$;

COMMENT ON FUNCTION public.is_super_role() IS 'Determina si el usuario autenticado tiene rol supervisor o admin. Usa schema explÃ­cito para seguridad.';


-- FILE: 20251211_fix_planificaciones_trigger.sql
-- =====================================================
-- Migration: Fix trigger_invalidate_cache_on_planificaciones
-- Date: 2024-12-11
-- Description: Add public. schema to function call
-- =====================================================

CREATE OR REPLACE FUNCTION public.trigger_invalidate_cache_on_planificaciones()
RETURNS trigger
LANGUAGE plpgsql
SET search_path TO ''
AS $$
DECLARE
  v_usuario_id bigint;
BEGIN
  -- agente_id en planificaciones es directamente el usuario_id
  v_usuario_id := COALESCE(NEW.agente_id, OLD.agente_id);
  
  IF v_usuario_id IS NOT NULL THEN
    PERFORM public.invalidate_campaign_cache_for_user(v_usuario_id);
  END IF;
  
  RETURN COALESCE(NEW, OLD);
END;
$$;

COMMENT ON FUNCTION public.trigger_invalidate_cache_on_planificaciones() IS 'Trigger para invalidar cache de campaÃ±as al actualizar planificaciones con schema pÃºblico explÃ­cito';


-- FILE: 20251211_fix_polizas_trigger.sql
-- =====================================================
-- Migration: Fix trigger_invalidate_cache_on_polizas
-- Date: 2024-12-11
-- Description: Add explicit schema to usuarios and clientes
-- =====================================================

CREATE OR REPLACE FUNCTION public.trigger_invalidate_cache_on_polizas()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
DECLARE
  v_usuario_id bigint;
BEGIN
  -- Obtener usuario_id del asesor a travÃ©s de clientes
  SELECT u.id INTO v_usuario_id
  FROM public.clientes c
  JOIN public.usuarios u ON u.id_auth = c.asesor_id
  WHERE c.id = COALESCE(NEW.cliente_id, OLD.cliente_id)
  LIMIT 1;

  IF v_usuario_id IS NOT NULL THEN
    PERFORM public.invalidate_campaign_cache_for_user(v_usuario_id);
  END IF;

  RETURN COALESCE(NEW, OLD);
END;
$function$;

COMMENT ON FUNCTION public.trigger_invalidate_cache_on_polizas() IS 'Invalida cache de campaÃ±as al cambiar pÃ³lizas con schema explÃ­cito';


-- FILE: 20251211_fix_prospectos_policies_search_path.sql
-- =====================================================
-- Migration: Fix RLS policies search_path references
-- Date: 2024-12-11
-- Description: Ensure all table references in RLS policies
--              use explicit schema qualification
-- =====================================================

-- Drop and recreate prospectos policies with explicit schemas
DROP POLICY IF EXISTS "prospectos_select_authenticated" ON public.prospectos;
DROP POLICY IF EXISTS "prospectos_insert_agente_supervisor_admin" ON public.prospectos;
DROP POLICY IF EXISTS "prospectos_update_creator_admin_supervisor" ON public.prospectos;
DROP POLICY IF EXISTS "prospectos_delete_admin_supervisor" ON public.prospectos;

-- Todos los usuarios autenticados pueden ver prospectos
CREATE POLICY "prospectos_select_authenticated"
ON public.prospectos
FOR SELECT TO authenticated
USING (true);

-- Agente, supervisor y admin pueden insertar prospectos
CREATE POLICY "prospectos_insert_agente_supervisor_admin"
ON public.prospectos
FOR INSERT TO authenticated
WITH CHECK (
  EXISTS (
    SELECT 1 FROM public.usuarios u
    WHERE u.id_auth = auth.uid()
    AND u.activo = true
    AND LOWER(u.rol) IN ('agente', 'supervisor', 'admin')
  )
);

-- El agente propietario o admin/supervisor pueden actualizar
CREATE POLICY "prospectos_update_creator_admin_supervisor"
ON public.prospectos
FOR UPDATE TO authenticated
USING (
  prospectos.agente_id IN (
    SELECT u.id FROM public.usuarios u WHERE u.id_auth = auth.uid()
  )
  OR public.is_super_role()
);

-- Admin y supervisor pueden eliminar
CREATE POLICY "prospectos_delete_admin_supervisor"
ON public.prospectos
FOR DELETE TO authenticated
USING (public.is_super_role());

COMMENT ON POLICY "prospectos_insert_agente_supervisor_admin" ON public.prospectos IS 'Permite insertar prospectos a agentes, supervisores y admins activos';


-- FILE: 20251211_fix_remaining_9_functions.sql
-- =====================================================
-- Migration: Fix remaining 9 functions with table references
-- Date: 2024-12-11
-- Description: Add explicit public. schema to all table references
-- =====================================================

-- Fix apply_cliente_update
CREATE OR REPLACE FUNCTION public.apply_cliente_update(p_request_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
DECLARE
  v_cliente_id uuid;
  v_payload jsonb;
  r_old public.clientes%ROWTYPE;
  r_new public.clientes%ROWTYPE;
BEGIN
  IF NOT public.is_super_role() THEN
    RAISE EXCEPTION 'permiso denegado (se requiere supervisor/super_usuario)';
  END IF;

  SELECT cliente_id, payload_propuesto
    INTO v_cliente_id, v_payload
  FROM public.cliente_update_requests 
  WHERE id = p_request_id AND estado = 'PENDIENTE'
  FOR UPDATE;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'solicitud no encontrada o no pendiente';
  END IF;

  SELECT * INTO r_old FROM public.clientes WHERE id = v_cliente_id FOR UPDATE;

  -- Actualiza campos permitidos (usa COALESCE para mantener si no viene en payload)
  UPDATE public.clientes SET
    primer_nombre      = COALESCE(UPPER(TRIM(v_payload->>'primer_nombre')), primer_nombre),
    segundo_nombre     = COALESCE(UPPER(TRIM(v_payload->>'segundo_nombre')), segundo_nombre),
    primer_apellido    = COALESCE(UPPER(TRIM(v_payload->>'primer_apellido')), primer_apellido),
    segundo_apellido   = COALESCE(UPPER(TRIM(v_payload->>'segundo_apellido')), segundo_apellido),
    telefono_celular   = COALESCE(TRIM(v_payload->>'telefono_celular'), telefono_celular),
    correo             = COALESCE(LOWER(TRIM(v_payload->>'correo')), correo),
    full_name_normalizado = UPPER(TRIM(
      COALESCE(v_payload->>'primer_nombre', primer_nombre) || ' ' ||
      COALESCE(v_payload->>'segundo_nombre', COALESCE(segundo_nombre,'')) || ' ' ||
      COALESCE(v_payload->>'primer_apellido', primer_apellido) || ' ' ||
      COALESCE(v_payload->>'segundo_apellido', segundo_apellido)
    )),
    updated_at = now()
  WHERE id = v_cliente_id;

  SELECT * INTO r_new FROM public.clientes WHERE id = v_cliente_id;

  INSERT INTO public.cliente_historial (
    id, cliente_id, cambio_tipo, payload_old, payload_new, actor_id, creado_at
  ) VALUES (
    gen_random_uuid(), v_cliente_id, 'APROBACION', to_jsonb(r_old), to_jsonb(r_new), auth.uid(), now()
  );

  UPDATE public.cliente_update_requests 
  SET estado = 'APROBADA', resuelto_at = now(), resuelto_por = auth.uid()
  WHERE id = p_request_id;
END;
$function$
;

-- Fix apply_poliza_update
CREATE OR REPLACE FUNCTION public.apply_poliza_update(p_request_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
DECLARE
  v_poliza_id uuid;
  v_payload jsonb;
  v_estado text;
  r_old polizas%ROWTYPE;
  r_new polizas%ROWTYPE;
  v_old_prima numeric(14,2);
  v_new_prima numeric(14,2);
  v_periodicidad_raw text;
  v_periodicidad_txt text;
BEGIN
  IF NOT is_super_role() THEN
    RAISE EXCEPTION 'permiso denegado (se requiere supervisor/super_usuario)';
  END IF;

  -- Leer la solicitud SIN FOR UPDATE (parece causar que no se devuelva fila en RLS)
  SELECT poliza_id, payload_propuesto, estado
    INTO v_poliza_id, v_payload, v_estado
  FROM public.poliza_update_requests 
  WHERE id = p_request_id;

  IF v_poliza_id IS NULL THEN
    RAISE EXCEPTION 'solicitud no encontrada';
  END IF;
  IF v_estado <> 'PENDIENTE' THEN
    RAISE EXCEPTION 'solicitud no pendiente (estado=%)', v_estado;
  END IF;

  -- Bloquear la pÃ³liza (evita condiciones de carrera)
  SELECT * INTO r_old FROM public.polizas WHERE id = v_poliza_id FOR UPDATE;

  v_periodicidad_raw := NULLIF(v_payload->>'periodicidad_pago','');
  IF v_periodicidad_raw IS NOT NULL THEN
    v_periodicidad_raw := upper(trim(v_periodicidad_raw));
    IF v_periodicidad_raw IN ('A','ANUAL','ANUALIDAD') THEN v_periodicidad_txt := 'A';
    ELSIF v_periodicidad_raw IN ('S','SEMESTRAL','SEMESTRA') THEN v_periodicidad_txt := 'S';
    ELSIF v_periodicidad_raw IN ('T','TRIMESTRAL','TRIMESTRE') THEN v_periodicidad_txt := 'T';
    ELSIF v_periodicidad_raw IN ('M','MENSUAL','MES') THEN v_periodicidad_txt := 'M';
    ELSIF v_periodicidad_raw IN ('A','S','T','M') THEN v_periodicidad_txt := v_periodicidad_raw; ELSE v_periodicidad_txt := NULL; END IF;
  END IF;

  UPDATE public.polizas SET
    numero_poliza         = COALESCE(NULLIF(TRIM(v_payload->>'numero_poliza'),''), numero_poliza),
    estatus               = COALESCE(NULLIF(v_payload->>'estatus','')::estatus_poliza, estatus),
    fecha_emision         = COALESCE(NULLIF(v_payload->>'fecha_emision','')::date, fecha_emision),
    fecha_renovacion      = COALESCE(NULLIF(v_payload->>'fecha_renovacion','')::date, fecha_renovacion),
    forma_pago            = COALESCE(NULLIF(v_payload->>'forma_pago','')::forma_pago, forma_pago),
    periodicidad_pago     = COALESCE((CASE WHEN v_periodicidad_txt IS NOT NULL THEN v_periodicidad_txt::public.periodicidad_pago END), periodicidad_pago),
    dia_pago              = COALESCE(NULLIF(v_payload->>'dia_pago','')::int, dia_pago),
    prima_input           = COALESCE(NULLIF(v_payload->>'prima_input','')::numeric, prima_input),
    prima_moneda          = COALESCE(NULLIF(v_payload->>'prima_moneda','')::moneda_poliza, prima_moneda),
    sa_input              = COALESCE(NULLIF(v_payload->>'sa_input','')::numeric, sa_input),
    sa_moneda             = COALESCE(NULLIF(v_payload->>'sa_moneda','')::moneda_poliza, sa_moneda),
    producto_parametro_id = COALESCE(NULLIF(v_payload->>'producto_parametro_id','')::uuid, producto_parametro_id),
    meses_check           = COALESCE((CASE WHEN jsonb_typeof(v_payload->'meses_check')='object' THEN v_payload->'meses_check' END), meses_check),
    updated_at            = now()
  WHERE id = v_poliza_id;

  SELECT * INTO r_new FROM public.polizas WHERE id = v_poliza_id;

  v_old_prima := r_old.prima_input;
  v_new_prima := r_new.prima_input;
  IF v_old_prima IS DISTINCT FROM v_new_prima THEN
    INSERT INTO historial_costos_poliza(
      id, poliza_id, prima_anual_old, prima_anual_new, porcentaje_comision_old, porcentaje_comision_new, actor_id, creado_at
    ) VALUES (
      gen_random_uuid(), v_poliza_id, v_old_prima, v_new_prima, NULL, NULL, auth.uid(), now()
    );
  END IF;

  UPDATE public.poliza_update_requests 
  SET estado='APROBADA', resuelto_at=now(), resuelto_por=auth.uid()
  WHERE id = p_request_id AND estado='PENDIENTE';

  PERFORM recalc_puntos_poliza(v_poliza_id);
END;
$function$
;

-- Fix apply_poliza_update_dbg
CREATE OR REPLACE FUNCTION public.apply_poliza_update_dbg(p_request_id uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
DECLARE
  v_row poliza_update_requests%ROWTYPE;
  v_is_super boolean;
  v_poliza_before polizas%ROWTYPE;
  v_poliza_after polizas%ROWTYPE;
  v_err text;
  v_state text;
BEGIN
  v_is_super := is_super_role();
  SELECT * INTO v_row FROM public.poliza_update_requests WHERE id = p_request_id;
  IF v_row.poliza_id IS NOT NULL THEN
    SELECT * INTO v_poliza_before FROM public.polizas WHERE id = v_row.poliza_id;
  END IF;
  BEGIN
    PERFORM apply_poliza_update(p_request_id);
    IF v_row.poliza_id IS NOT NULL THEN
      SELECT * INTO v_poliza_after FROM public.polizas WHERE id = v_row.poliza_id;
    END IF;
    RETURN jsonb_build_object(
      'status','ok',
      'is_super', v_is_super,
      'request_row', to_jsonb(v_row),
      'poliza_before', to_jsonb(v_poliza_before),
      'poliza_after', to_jsonb(v_poliza_after)
    );
  EXCEPTION WHEN OTHERS THEN
    v_err := SQLERRM; v_state := SQLSTATE;
    RETURN jsonb_build_object(
      'status','error',
      'is_super', v_is_super,
      'sqlstate', v_state,
      'error', v_err,
      'request_row', to_jsonb(v_row)
    );
  END;
END;
$function$
;

-- Fix polizas_before_insupd_enforce_moneda
CREATE OR REPLACE FUNCTION public.polizas_before_insupd_enforce_moneda()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
DECLARE
  v_moneda moneda_poliza;
BEGIN
  IF NEW.producto_parametro_id IS NOT NULL THEN
    SELECT moneda INTO v_moneda FROM public.producto_parametros WHERE id = NEW.producto_parametro_id;
    IF v_moneda IS NOT NULL THEN
      NEW.prima_moneda := v_moneda;
      NEW.sa_moneda := v_moneda;
    END IF;
  END IF;
  RETURN NEW;
END;
$function$
;

-- Fix producto_parametros_after_update_sync_moneda
CREATE OR REPLACE FUNCTION public.producto_parametros_after_update_sync_moneda()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
DECLARE
  v_changed boolean := false;
  v_updated int := 0;
BEGIN
  IF NEW.moneda IS DISTINCT FROM OLD.moneda THEN
    v_changed := true;
  END IF;

  IF v_changed THEN
    -- Si la nueva moneda es NULL, no forzamos sincronizaciÃ³n (sin especificaciÃ³n de moneda)
    IF NEW.moneda IS NOT NULL THEN
      -- Actualizar moneda de primas y suma asegurada de pÃ³lizas que apuntan a este producto
      UPDATE public.polizas 
        SET prima_moneda = NEW.moneda,
            sa_moneda = NEW.moneda,
            updated_at = now()
        WHERE producto_parametro_id = NEW.id
          AND (
            prima_moneda IS DISTINCT FROM NEW.moneda
            OR sa_moneda IS DISTINCT FROM NEW.moneda
            OR sa_moneda IS NULL
          );
    END IF;

    -- Recalcular cache/puntos de las pÃ³lizas afectadas
    PERFORM recalc_polizas_by_producto_parametro(NEW.id);
  END IF;
  RETURN NEW;
END;
$function$
;

-- Fix recalc_polizas_by_producto_parametro
CREATE OR REPLACE FUNCTION public.recalc_polizas_by_producto_parametro(p_pp_id uuid)
 RETURNS integer
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
DECLARE
  v_count int := 0;
  r RECORD;
BEGIN
  FOR r IN SELECT id FROM public.polizas WHERE producto_parametro_id = p_pp_id LOOP
    PERFORM recalc_puntos_poliza(r.id);
    v_count := v_count + 1;
  END LOOP;
  RETURN v_count;
END;
$function$
;

-- Fix recalc_puntos_poliza
CREATE OR REPLACE FUNCTION public.recalc_puntos_poliza(p_poliza_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
declare
  v_prima_input numeric;
  v_prima_mxn numeric;
  v_prima_moneda moneda_poliza;
  v_sa_mxn numeric;
  v_sa_input numeric;
  v_sa_moneda moneda_poliza;
  v_tipo_code text;
  v_tipo_name text;
  v_tipo_id uuid;
  v_estatus estatus_poliza;
  v_pp_id uuid;
  v_year int;
  v_base_factor numeric;
  v_puntos numeric;
  v_clas tipo_clasificacion_puntos;
  v_fx numeric;
  v_udi numeric;
  v_fecha date;
  v_pp_auto uuid;
  v_sa_mxn_live numeric;
begin
  select p.prima_input, p.prima_mxn, p.prima_moneda, p.sa_mxn, p.sa_input, p.sa_moneda,
         p.estatus, p.producto_parametro_id, p.fecha_emision
    into v_prima_input, v_prima_mxn, v_prima_moneda, v_sa_mxn, v_sa_input, v_sa_moneda,
         v_estatus, v_pp_id, v_fecha
  from public.polizas p
  where p.id = p_poliza_id;

  if not found then
    raise exception 'poliza % no existe', p_poliza_id;
  end if;

  v_prima_mxn := normalize_prima(v_prima_input, v_prima_moneda, current_date);

  v_fx := null; v_udi := null;
  if v_prima_moneda = 'USD'::moneda_poliza then
    select get_fx_usd(current_date) into v_fx;
  elsif v_prima_moneda = 'UDI'::moneda_poliza then
    select get_current_udi(current_date) into v_udi;
  end if;

  if v_sa_input is not null and v_sa_moneda is not null then
    v_sa_mxn_live := normalize_prima(v_sa_input, v_sa_moneda, current_date);
  else
    v_sa_mxn_live := null;
  end if;

  if v_pp_id is null then
    select pp.id
      into v_pp_auto
    from public.producto_parametros pp
    where pp.activo = true
      and (pp.moneda is null or pp.moneda = v_prima_moneda)
      and (
        v_sa_mxn_live is null
        or (
          (pp.sa_min is null or v_sa_mxn_live >= pp.sa_min)
          and (pp.sa_max is null or v_sa_mxn_live <= pp.sa_max)
        )
      )
    order by
      case when pp.moneda = v_prima_moneda then 0 else 1 end,
      coalesce(pp.sa_min, (-1)::numeric) desc
    limit 1;

    if v_pp_auto is not null then
      v_pp_id := v_pp_auto;
      update public.polizas set producto_parametro_id = v_pp_auto, updated_at = now()
      where id = p_poliza_id;
    end if;
  end if;

  if v_estatus = 'ANULADA'::estatus_poliza then
    v_puntos := 0;
    v_clas := 'CERO';
    v_tipo_code := null;
    v_tipo_name := null;
    v_tipo_id := null;
  else
    if v_pp_id is not null then
      select pt.code, pt.name, pt.id
        into v_tipo_code, v_tipo_name, v_tipo_id
      from public.producto_parametros pp
      join public.product_types pt on pt.id = pp.product_type_id
      where pp.id = v_pp_id;
    else
      v_tipo_code := null;
      v_tipo_name := null;
      v_tipo_id := null;
    end if;

    if v_tipo_code is not null then
      v_tipo_code := upper(v_tipo_code);
    end if;

    if v_tipo_code = 'GMM' then
      if v_prima_mxn is not null and v_prima_mxn >= 7500 then
        v_puntos := 0.5; v_clas := 'MEDIO';
      else
        v_puntos := 0; v_clas := 'CERO';
      end if;
    elsif v_tipo_code = 'VI' then
      if v_prima_mxn is null or v_prima_mxn < 15000 then
        v_puntos := 0; v_clas := 'CERO';
      elsif v_prima_mxn >= 150000 then
        v_puntos := 3; v_clas := 'TRIPLE';
      elsif v_prima_mxn >= 50000 then
        v_puntos := 2; v_clas := 'DOBLE';
      else
        v_puntos := 1; v_clas := 'SIMPLE';
      end if;
    else
      v_puntos := 0; v_clas := 'CERO';
    end if;
  end if;

  select poliza_year_vigencia(p.fecha_emision) into v_year
  from public.polizas p where p.id = p_poliza_id;

  if v_pp_id is not null and v_estatus = 'EN_VIGOR'::estatus_poliza then
    select case
             when coalesce(duracion_anios, 9999) <= 10 then
               case least(v_year, coalesce(duracion_anios, 10))
                 when 1 then anio_1_percent
                 when 2 then anio_2_percent
                 when 3 then anio_3_percent
                 when 4 then anio_4_percent
                 when 5 then anio_5_percent
                 when 6 then anio_6_percent
                 when 7 then anio_7_percent
                 when 8 then anio_8_percent
                 when 9 then anio_9_percent
                 when 10 then anio_10_percent
                 else null
               end
             else
               case
                 when v_year = 1 then anio_1_percent
                 when v_year = 2 then anio_2_percent
                 when v_year = 3 then anio_3_percent
                 when v_year = 4 then anio_4_percent
                 when v_year = 5 then anio_5_percent
                 when v_year = 6 then anio_6_percent
                 when v_year = 7 then anio_7_percent
                 when v_year = 8 then anio_8_percent
                 when v_year = 9 then anio_9_percent
                 when v_year = 10 then anio_10_percent
                 else anio_11_plus_percent
               end
           end
      into v_base_factor
    from public.producto_parametros 
    where id = v_pp_id;
  else
    v_base_factor := null;
  end if;

  v_puntos := coalesce(v_puntos, 0);
  v_clas := coalesce(v_clas, 'CERO');

  insert into public.poliza_puntos_cache (
    poliza_id, puntos_total, clasificacion, base_factor, producto_factor,
    year_factor, prima_anual_snapshot, producto_parametro_id, udi_valor, usd_fx,
    breakdown, recalculo_reason, computed_at, updated_at
  )
  select p.id, v_puntos, v_clas, v_base_factor, null,
         v_year, v_prima_mxn, v_pp_id, v_udi, v_fx,
         jsonb_build_object(
           'year', v_year,
           'factor_base', v_base_factor,
           'producto', v_tipo_code,
           'producto_nombre', v_tipo_name,
           'producto_type_id', v_tipo_id,
           'prima_mxn', v_prima_mxn,
           'sa_mxn', v_sa_mxn_live,
           'prima_moneda', v_prima_moneda,
           'fx_aplicado', v_fx,
           'udi_aplicada', v_udi,
           'tasas_fecha', to_char(current_date, 'YYYY-MM-DD')
         ),
         'recalc', now(), now()
  from public.polizas p where p.id = p_poliza_id
  on conflict (poliza_id) do update set
    puntos_total = excluded.puntos_total,
    clasificacion = excluded.clasificacion,
    base_factor = excluded.base_factor,
    producto_factor = excluded.producto_factor,
    year_factor = excluded.year_factor,
    prima_anual_snapshot = excluded.prima_anual_snapshot,
    producto_parametro_id = excluded.producto_parametro_id,
    udi_valor = excluded.udi_valor,
    usd_fx = excluded.usd_fx,
    breakdown = excluded.breakdown,
    recalculo_reason = excluded.recalculo_reason,
    computed_at = excluded.computed_at,
    updated_at = excluded.updated_at;
end;
$function$
;

-- Fix recalc_puntos_poliza_all
CREATE OR REPLACE FUNCTION public.recalc_puntos_poliza_all(p_limit integer DEFAULT NULL::integer)
 RETURNS integer
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
DECLARE
  v_count int := 0;
  r RECORD;
BEGIN
  FOR r IN 
    SELECT id FROM public.polizas 
    ORDER BY updated_at DESC
    LIMIT COALESCE(p_limit, 2147483647)
  LOOP
    PERFORM recalc_puntos_poliza(r.id);
    v_count := v_count + 1;
  END LOOP;
  RETURN v_count;
END;
$function$
;

-- Fix trigger_invalidate_cache_on_polizas
CREATE OR REPLACE FUNCTION public.trigger_invalidate_cache_on_polizas()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
DECLARE
  v_usuario_id bigint;
BEGIN
  -- Obtener usuario_id del cliente asociado
  SELECT u.id INTO v_usuario_id
  FROM public.clientes c
  JOIN public.usuarios u ON u.id_auth = c.asesor_id
  WHERE c.id = COALESCE(NEW.cliente_id, OLD.cliente_id)
  LIMIT 1;
  
  IF v_usuario_id IS NOT NULL THEN
    PERFORM invalidate_campaign_cache_for_user(v_usuario_id);
  END IF;
  
  RETURN COALESCE(NEW, OLD);
END;
$function$
;

COMMENT ON FUNCTION public.apply_cliente_update(uuid) IS 'Aplica actualizaciÃ³n de cliente con schema explÃ­cito';
COMMENT ON FUNCTION public.recalc_puntos_poliza(uuid) IS 'Recalcula puntos de pÃ³liza con schema explÃ­cito';


-- FILE: 20251227_fase6_pagos_comisiones.sql
-- Fase 6: Pagos mensuales y comisiones de pÃ³lizas
-- Fecha: 2025-12-27
-- DescripciÃ³n: Registro de pagos mensuales, alertas de vencimiento, y dashboard de comisiones

-- =======================
-- 1. MODIFICAR ENUM periodicidad_pago
-- =======================
-- Cambiar de cÃ³digos cortos ('A','S','T','M') a valores legibles

-- Paso 1: Guardar definiciÃ³n de vista polizas_ui
DO $$ 
DECLARE
  view_def text;
BEGIN
  SELECT pg_get_viewdef('polizas_ui', true) INTO view_def;
  RAISE NOTICE 'Guardada definiciÃ³n de polizas_ui';
END $$;

-- Paso 2: Dropear vista que depende de periodicidad_pago
DROP VIEW IF EXISTS polizas_ui CASCADE;

-- Paso 3: Renombrar enum actual
ALTER TYPE periodicidad_pago RENAME TO periodicidad_pago_old;

-- Paso 4: Crear nuevo enum con valores legibles
CREATE TYPE periodicidad_pago AS ENUM ('mensual', 'trimestral', 'semestral', 'anual');

-- Paso 5: Actualizar columna con conversiÃ³n de valores
ALTER TABLE polizas 
  ALTER COLUMN periodicidad_pago TYPE periodicidad_pago 
  USING (
    CASE periodicidad_pago::text
      WHEN 'M' THEN 'mensual'::periodicidad_pago
      WHEN 'T' THEN 'trimestral'::periodicidad_pago
      WHEN 'S' THEN 'semestral'::periodicidad_pago
      WHEN 'A' THEN 'anual'::periodicidad_pago
      ELSE NULL
    END
  );

-- Paso 6: Eliminar enum antiguo
DROP TYPE periodicidad_pago_old;

-- Paso 7: Recrear vista polizas_ui con nuevo enum
CREATE OR REPLACE VIEW polizas_ui AS
SELECT 
  id,
  cliente_id,
  numero_poliza,
  estatus,
  forma_pago,
  periodicidad_pago,
  prima_input,
  prima_moneda,
  sa_input,
  sa_moneda,
  fecha_emision,
  fecha_renovacion,
  tipo_pago,
  dia_pago,
  meses_check,
  producto_parametro_id,
  fecha_alta_sistema
FROM polizas;

COMMENT ON TYPE periodicidad_pago IS 'Periodicidad de pago de pÃ³lizas: mensual (12 pagos/aÃ±o), trimestral (4), semestral (2), anual (1)';

-- =======================
-- 2. AGREGAR CAMPOS FALTANTES A polizas
-- =======================
ALTER TABLE polizas 
  ADD COLUMN IF NOT EXISTS fecha_limite_pago date;

COMMENT ON COLUMN polizas.fecha_limite_pago IS 'Fecha lÃ­mite general para pagos (se puede sobrescribir por periodo)';

-- Ãndice para bÃºsquedas por fecha lÃ­mite
CREATE INDEX IF NOT EXISTS idx_polizas_fecha_limite_pago 
  ON polizas(fecha_limite_pago) 
  WHERE fecha_limite_pago IS NOT NULL;

-- =======================
-- 3. CREAR ENUM poliza_pago_estado
-- =======================
CREATE TYPE poliza_pago_estado AS ENUM ('pendiente', 'pagado', 'vencido', 'omitido');

COMMENT ON TYPE poliza_pago_estado IS 'Estados de pago: pendiente (no pagado aÃºn), pagado (confirmado), vencido (pasÃ³ fecha lÃ­mite), omitido (no aplica)';

-- =======================
-- 4. CREAR TABLA poliza_pagos_mensuales
-- =======================
CREATE TABLE poliza_pagos_mensuales (
  id bigserial PRIMARY KEY,
  poliza_id uuid NOT NULL REFERENCES polizas(id) ON DELETE CASCADE,
  periodo_mes date NOT NULL,  -- Primer dÃ­a del mes (ej: '2025-01-01')
  fecha_programada date NOT NULL,  -- Fecha esperada de pago segÃºn periodicidad
  fecha_limite date NOT NULL,  -- Fecha lÃ­mite para pagar (editable)
  monto_programado numeric(14,2) NOT NULL CHECK (monto_programado >= 0),
  monto_pagado numeric(14,2) CHECK (monto_pagado >= 0),
  fecha_pago_real timestamptz,
  estado poliza_pago_estado NOT NULL DEFAULT 'pendiente',
  notas text,
  created_by uuid REFERENCES auth.users(id) ON DELETE SET NULL,
  updated_by uuid REFERENCES auth.users(id) ON DELETE SET NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  
  CONSTRAINT uq_poliza_periodo UNIQUE(poliza_id, periodo_mes),
  CONSTRAINT ck_fecha_pago_con_monto CHECK (
    (fecha_pago_real IS NULL AND monto_pagado IS NULL) OR 
    (fecha_pago_real IS NOT NULL AND monto_pagado IS NOT NULL)
  )
);

-- Ãndices para rendimiento
CREATE INDEX idx_poliza_pagos_poliza_id ON poliza_pagos_mensuales(poliza_id);
CREATE INDEX idx_poliza_pagos_estado ON poliza_pagos_mensuales(estado);
CREATE INDEX idx_poliza_pagos_fecha_limite ON poliza_pagos_mensuales(fecha_limite);
CREATE INDEX idx_poliza_pagos_periodo_mes ON poliza_pagos_mensuales(periodo_mes);

-- Ãndice compuesto para alertas (pagos vencidos o prÃ³ximos)
CREATE INDEX idx_poliza_pagos_alertas 
  ON poliza_pagos_mensuales(estado, fecha_limite) 
  WHERE estado = 'pendiente';

COMMENT ON TABLE poliza_pagos_mensuales IS 'Registro de pagos programados y realizados por pÃ³liza y periodo';
COMMENT ON COLUMN poliza_pagos_mensuales.periodo_mes IS 'Primer dÃ­a del mes al que corresponde el pago';
COMMENT ON COLUMN poliza_pagos_mensuales.monto_programado IS 'Monto esperado segÃºn prima anual / periodicidad';

-- Trigger para updated_at
CREATE TRIGGER trg_poliza_pagos_set_updated_at
  BEFORE UPDATE ON poliza_pagos_mensuales
  FOR EACH ROW
  EXECUTE FUNCTION set_updated_at();

-- =======================
-- 5. FUNCIÃ“N: Generar pagos programados
-- =======================
CREATE OR REPLACE FUNCTION fn_generar_pagos_programados()
RETURNS TRIGGER AS $$
DECLARE
  v_divisor integer;
  v_monto_periodo numeric(14,2);
  v_meses_entre_pagos integer;
  v_fecha_primer_pago date;
  v_fecha_limite date;
  v_idx integer;
  v_offset interval;
  v_periodo date;
  v_fecha_prog timestamp;
  v_fecha_limite_calc date;
BEGIN
  -- Solo generar si tiene periodicidad y prima
  IF NEW.periodicidad_pago IS NULL OR NEW.prima_mxn IS NULL OR NEW.prima_mxn <= 0 THEN
    RETURN NEW;
  END IF;

  -- Determinar divisor y meses entre pagos segÃºn periodicidad
  CASE NEW.periodicidad_pago
    WHEN 'mensual' THEN
      v_divisor := 12;
      v_meses_entre_pagos := 1;
    WHEN 'trimestral' THEN
      v_divisor := 4;
      v_meses_entre_pagos := 3;
    WHEN 'semestral' THEN
      v_divisor := 2;
      v_meses_entre_pagos := 6;
    WHEN 'anual' THEN
      v_divisor := 1;
      v_meses_entre_pagos := 12;
    ELSE
      RETURN NEW; -- Periodicidad desconocida
  END CASE;

  -- Calcular monto por periodo
  v_monto_periodo := ROUND(NEW.prima_mxn / v_divisor, 2);

  -- Fecha de primer pago: usar dia_pago o dÃ­a 1 del mes de emisiÃ³n
  v_fecha_primer_pago := DATE_TRUNC('month', NEW.fecha_emision)::date 
    + INTERVAL '1 month' * (CASE WHEN NEW.dia_pago IS NOT NULL THEN NEW.dia_pago - 1 ELSE 0 END);

  -- Fecha lÃ­mite base: usar fecha_limite_pago de pÃ³liza o Ãºltimo dÃ­a del mes
  v_fecha_limite := COALESCE(
    NEW.fecha_limite_pago,
    (DATE_TRUNC('month', v_fecha_primer_pago) + INTERVAL '1 month - 1 day')::date
  );

  -- Eliminar pagos pendientes existentes (no tocar pagados/vencidos/omitidos)
  DELETE FROM poliza_pagos_mensuales 
  WHERE poliza_id = NEW.id 
    AND estado = 'pendiente';

  -- Generar periodos de forma segura (evita insertar siempre el mismo periodo)
  FOR v_idx IN 0..(v_divisor - 1) LOOP
    v_offset := (v_idx * v_meses_entre_pagos || ' months')::interval;
    v_periodo := (DATE_TRUNC('month', v_fecha_primer_pago) + v_offset)::date;
    v_fecha_prog := v_fecha_primer_pago + v_offset;
    v_fecha_limite_calc := (v_fecha_limite + v_offset)::date;

    INSERT INTO poliza_pagos_mensuales (
      poliza_id,
      periodo_mes,
      fecha_programada,
      fecha_limite,
      monto_programado,
      estado,
      created_by
    ) VALUES (
      NEW.id,
      v_periodo,
      v_fecha_prog,
      v_fecha_limite_calc,
      v_monto_periodo,
      'pendiente',
      NEW.creado_por
    )
    ON CONFLICT (poliza_id, periodo_mes) DO NOTHING;
  END LOOP;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION fn_generar_pagos_programados() IS 'Genera pagos programados al insertar/actualizar pÃ³liza. Solo elimina/regenera pagos pendientes.';

-- =======================
-- 6. TRIGGER: Generar pagos al crear/modificar pÃ³liza
-- =======================
CREATE TRIGGER trg_polizas_generar_pagos
  AFTER INSERT OR UPDATE OF periodicidad_pago, fecha_limite_pago, prima_mxn, fecha_emision, dia_pago
  ON polizas
  FOR EACH ROW
  WHEN (NEW.periodicidad_pago IS NOT NULL)
  EXECUTE FUNCTION fn_generar_pagos_programados();

COMMENT ON TRIGGER trg_polizas_generar_pagos ON polizas IS 'Regenera pagos programados cuando cambian datos relevantes de la pÃ³liza';

-- =======================
-- 7. FUNCIÃ“N: Actualizar pagos vencidos (para cron)
-- =======================
CREATE OR REPLACE FUNCTION fn_actualizar_pagos_vencidos()
RETURNS TABLE(updated_count bigint) 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  row_count bigint;
BEGIN
  UPDATE poliza_pagos_mensuales
  SET estado = 'vencido', 
      updated_at = NOW()
  WHERE estado = 'pendiente' 
    AND fecha_limite < CURRENT_DATE;
  
  GET DIAGNOSTICS row_count = ROW_COUNT;
  RETURN QUERY SELECT row_count;
END;
$$;

COMMENT ON FUNCTION fn_actualizar_pagos_vencidos() IS 'Marca como vencidos los pagos pendientes que pasaron su fecha lÃ­mite. Usar desde Edge Function o cron.';

GRANT EXECUTE ON FUNCTION fn_actualizar_pagos_vencidos() TO service_role;

-- =======================
-- 8. VISTAS: Dashboard de comisiones
-- =======================

-- Vista: Agentes con mes de conexiÃ³n
CREATE OR REPLACE VIEW vw_agentes_con_mes_conexion AS
SELECT 
  u.id as usuario_id,
  u.id_auth,
  u.email,
  u.nombre as agente_nombre,
  c.mes_conexion,
  c.candidato,
  c.efc
FROM usuarios u
INNER JOIN candidatos c ON LOWER(c.email_agente) = LOWER(u.email)
WHERE u.rol = 'agente' 
  AND u.activo = true
  AND c.eliminado = false
  AND c.mes_conexion IS NOT NULL;

COMMENT ON VIEW vw_agentes_con_mes_conexion IS 'Agentes que tienen mes de conexiÃ³n registrado en candidatos';

-- Vista: Agentes sin mes de conexiÃ³n
CREATE OR REPLACE VIEW vw_agentes_sin_mes_conexion AS
SELECT 
  u.id as usuario_id,
  u.id_auth,
  u.email,
  u.nombre as agente_nombre
FROM usuarios u
WHERE u.rol = 'agente' 
  AND u.activo = true
  AND NOT EXISTS (
    SELECT 1 
    FROM candidatos c 
    WHERE LOWER(c.email_agente) = LOWER(u.email)
      AND c.eliminado = false
      AND c.mes_conexion IS NOT NULL
  );

COMMENT ON VIEW vw_agentes_sin_mes_conexion IS 'Agentes que NO tienen mes de conexiÃ³n en candidatos';

-- Vista: Comisiones por agente y mes
CREATE OR REPLACE VIEW vw_comisiones_agente_mes AS
SELECT 
  cl.asesor_id,
  u.id as usuario_id,
  u.nombre as agente_nombre,
  u.email as agente_email,
  DATE_TRUNC('month', p.fecha_emision)::date as mes_emision,
  TO_CHAR(DATE_TRUNC('month', p.fecha_emision), 'YYYY-MM') as periodo,
  COUNT(DISTINCT p.id) as total_polizas,
  SUM(p.prima_mxn) as prima_total,
  -- Usar base_factor del cache (porcentaje real de comisiÃ³n por pÃ³liza)
  SUM(p.prima_mxn * COALESCE(ppc.base_factor, 0) / 100) as comision_estimada,
  SUM(
    CASE 
      WHEN p.estatus = 'EN_VIGOR' 
      THEN p.prima_mxn * COALESCE(ppc.base_factor, 0) / 100 
      ELSE 0 
    END
  ) as comision_vigente
FROM polizas p
INNER JOIN clientes cl ON p.cliente_id = cl.id
INNER JOIN usuarios u ON cl.asesor_id = u.id_auth
LEFT JOIN poliza_puntos_cache ppc ON p.id = ppc.poliza_id
WHERE p.anulada_at IS NULL
  AND u.rol = 'agente'
  AND u.activo = true
GROUP BY cl.asesor_id, u.id, u.nombre, u.email, DATE_TRUNC('month', p.fecha_emision);

COMMENT ON VIEW vw_comisiones_agente_mes IS 'Comisiones agregadas por agente y mes, usando base_factor real de cada pÃ³liza';

-- Vista: Dashboard comisiones CON mes de conexiÃ³n
CREATE OR REPLACE VIEW vw_dashboard_comisiones_con_conexion AS
SELECT 
  acm.periodo,
  acm.mes_emision,
  agc.agente_nombre,
  agc.mes_conexion,
  agc.efc,
  acm.total_polizas,
  acm.prima_total,
  acm.comision_estimada,
  acm.comision_vigente,
  agc.usuario_id,
  agc.id_auth,
  agc.email
FROM vw_comisiones_agente_mes acm
INNER JOIN vw_agentes_con_mes_conexion agc 
  ON acm.asesor_id = agc.id_auth
ORDER BY acm.periodo DESC, agc.agente_nombre;

COMMENT ON VIEW vw_dashboard_comisiones_con_conexion IS 'Dashboard: Comisiones de agentes CON mes de conexiÃ³n';

-- Vista: Dashboard comisiones SIN mes de conexiÃ³n
CREATE OR REPLACE VIEW vw_dashboard_comisiones_sin_conexion AS
SELECT 
  acm.periodo,
  acm.mes_emision,
  asnc.agente_nombre,
  acm.total_polizas,
  acm.prima_total,
  acm.comision_estimada,
  acm.comision_vigente,
  asnc.usuario_id,
  asnc.id_auth,
  asnc.email
FROM vw_comisiones_agente_mes acm
INNER JOIN vw_agentes_sin_mes_conexion asnc 
  ON acm.asesor_id = asnc.id_auth
ORDER BY acm.periodo DESC, asnc.agente_nombre;

COMMENT ON VIEW vw_dashboard_comisiones_sin_conexion IS 'Dashboard: Comisiones de agentes SIN mes de conexiÃ³n';

-- Vista: ComisiÃ³n del mes actual por agente
CREATE OR REPLACE VIEW vw_agente_comision_mes_actual AS
SELECT 
  u.id_auth as agente_id,
  u.id as usuario_id,
  u.nombre as agente_nombre,
  u.email as agente_email,
  COALESCE(SUM(ppm.monto_programado), 0) as importe_programado,
  COALESCE(SUM(ppm.monto_pagado), 0) as importe_pagado,
  COALESCE(
    SUM(CASE WHEN ppm.estado = 'pendiente' THEN ppm.monto_programado ELSE 0 END), 
    0
  ) as importe_pendiente,
  COUNT(DISTINCT p.id) FILTER (WHERE p.estatus = 'EN_VIGOR') as polizas_vigentes,
  COUNT(DISTINCT ppm.id) FILTER (WHERE ppm.estado = 'vencido') as pagos_vencidos
FROM usuarios u
LEFT JOIN clientes cl ON cl.asesor_id = u.id_auth
LEFT JOIN polizas p ON p.cliente_id = cl.id AND p.anulada_at IS NULL
LEFT JOIN poliza_pagos_mensuales ppm ON ppm.poliza_id = p.id 
  AND DATE_TRUNC('month', ppm.periodo_mes) = DATE_TRUNC('month', CURRENT_DATE)
WHERE u.rol = 'agente' 
  AND u.activo = true
GROUP BY u.id_auth, u.id, u.nombre, u.email;

COMMENT ON VIEW vw_agente_comision_mes_actual IS 'Resumen de pagos y comisiones del mes actual por agente';

-- =======================
-- 9. RLS POLICIES
-- =======================

ALTER TABLE poliza_pagos_mensuales ENABLE ROW LEVEL SECURITY;

-- Policy: SELECT para agentes (solo sus pÃ³lizas) y supervisores (todas)
CREATE POLICY sel_poliza_pagos_mensuales
  ON poliza_pagos_mensuales FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM polizas p
      INNER JOIN clientes c ON p.cliente_id = c.id
      WHERE p.id = poliza_pagos_mensuales.poliza_id
        AND (c.asesor_id = auth.uid() OR is_super_role())
    )
  );

-- Policy: UPDATE para agentes (sus pÃ³lizas) y supervisores (todas)
CREATE POLICY upd_poliza_pagos_mensuales
  ON poliza_pagos_mensuales FOR UPDATE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM polizas p
      INNER JOIN clientes c ON p.cliente_id = c.id
      WHERE p.id = poliza_pagos_mensuales.poliza_id
        AND (c.asesor_id = auth.uid() OR is_super_role())
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM polizas p
      INNER JOIN clientes c ON p.cliente_id = c.id
      WHERE p.id = poliza_pagos_mensuales.poliza_id
        AND (c.asesor_id = auth.uid() OR is_super_role())
    )
  );

-- Policy: INSERT automÃ¡tico solo desde triggers (service_role)
-- No crear policy INSERT para usuarios normales

-- Permisos para vistas
GRANT SELECT ON vw_agentes_con_mes_conexion TO authenticated;
GRANT SELECT ON vw_agentes_sin_mes_conexion TO authenticated;
GRANT SELECT ON vw_comisiones_agente_mes TO authenticated;
GRANT SELECT ON vw_dashboard_comisiones_con_conexion TO authenticated;
GRANT SELECT ON vw_dashboard_comisiones_sin_conexion TO authenticated;
GRANT SELECT ON vw_agente_comision_mes_actual TO authenticated;

-- =======================
-- 10. ÃNDICES ADICIONALES RECOMENDADOS
-- =======================

-- Para bÃºsquedas frecuentes en dashboard de comisiones
CREATE INDEX IF NOT EXISTS idx_candidatos_mes_conexion 
  ON candidatos(mes_conexion) 
  WHERE mes_conexion IS NOT NULL AND eliminado = false;

CREATE INDEX IF NOT EXISTS idx_poliza_puntos_cache_poliza_base 
  ON poliza_puntos_cache(poliza_id, base_factor)
  WHERE base_factor IS NOT NULL;

-- Para joins en vistas de comisiones
CREATE INDEX IF NOT EXISTS idx_clientes_asesor_activo 
  ON clientes(asesor_id, activo) 
  WHERE asesor_id IS NOT NULL;

-- =======================
-- FIN MIGRACIÃ“N FASE 6
-- =======================


-- FILE: 20251227_fix_all_search_path_issues.sql
-- Migration: Fix search_path issues across all database functions
-- Date: 2025-12-27
-- Description: Sets search_path = public for all functions to prevent "function does not exist" errors
--              in nested function calls, triggers, and RPC contexts. This resolves issues where functions
--              couldn't find other functions or tables due to empty or unset search_path.

-- ============================================================================
-- CRITICAL FIX: Main trigger that was causing recalc_puntos_poliza failures
-- ============================================================================
CREATE OR REPLACE FUNCTION polizas_after_change_recalc()
RETURNS trigger
LANGUAGE plpgsql
SET search_path = public
AS $$
BEGIN
  PERFORM recalc_puntos_poliza(NEW.id);
  RETURN NULL;
END;
$$;

-- ============================================================================
-- Poliza management functions (RPC callable)
-- ============================================================================
CREATE OR REPLACE FUNCTION apply_poliza_update(p_request_id uuid)
RETURNS void
LANGUAGE plpgsql
SET search_path = public
AS $$
DECLARE
  v_poliza_id uuid;
  v_payload jsonb;
  v_estado text;
  r_old polizas%ROWTYPE;
  r_new polizas%ROWTYPE;
  v_old_prima numeric(14,2);
  v_new_prima numeric(14,2);
  v_periodicidad_raw text;
  v_periodicidad_txt text;
BEGIN
  IF NOT is_super_role() THEN
    RAISE EXCEPTION 'permiso denegado (se requiere supervisor)';
  END IF;

  SELECT poliza_id, payload_propuesto, estado
    INTO v_poliza_id, v_payload, v_estado
  FROM poliza_update_requests 
  WHERE id = p_request_id;

  IF v_poliza_id IS NULL THEN
    RAISE EXCEPTION 'solicitud no encontrada';
  END IF;
  IF v_estado <> 'PENDIENTE' THEN
    RAISE EXCEPTION 'solicitud no pendiente (estado=%)', v_estado;
  END IF;

  SELECT * INTO r_old FROM polizas WHERE id = v_poliza_id FOR UPDATE;

  -- Mapear periodicidad a valores vÃ¡lidos del enum
  v_periodicidad_raw := NULLIF(v_payload->>'periodicidad_pago','');
  IF v_periodicidad_raw IS NOT NULL THEN
    v_periodicidad_raw := upper(trim(v_periodicidad_raw));
    IF v_periodicidad_raw IN ('A','ANUAL','ANUALIDAD') THEN v_periodicidad_txt := 'anual';
    ELSIF v_periodicidad_raw IN ('S','SEMESTRAL','SEMESTRA') THEN v_periodicidad_txt := 'semestral';
    ELSIF v_periodicidad_raw IN ('T','TRIMESTRAL','TRIMESTRE') THEN v_periodicidad_txt := 'trimestral';
    ELSIF v_periodicidad_raw IN ('M','MENSUAL','MES') THEN v_periodicidad_txt := 'mensual';
    ELSE v_periodicidad_txt := lower(v_periodicidad_raw);
    END IF;
  END IF;

  UPDATE polizas SET
    numero_poliza         = COALESCE(NULLIF(TRIM(v_payload->>'numero_poliza'),''), numero_poliza),
    estatus               = COALESCE(NULLIF(v_payload->>'estatus','')::estatus_poliza, estatus),
    fecha_emision         = COALESCE(NULLIF(v_payload->>'fecha_emision','')::date, fecha_emision),
    fecha_renovacion      = COALESCE(NULLIF(v_payload->>'fecha_renovacion','')::date, fecha_renovacion),
    forma_pago            = COALESCE(NULLIF(v_payload->>'forma_pago','')::forma_pago, forma_pago),
    periodicidad_pago     = COALESCE((CASE WHEN v_periodicidad_txt IS NOT NULL THEN v_periodicidad_txt::periodicidad_pago END), periodicidad_pago),
    dia_pago              = COALESCE(NULLIF(v_payload->>'dia_pago','')::int, dia_pago),
    prima_input           = COALESCE(NULLIF(v_payload->>'prima_input','')::numeric, prima_input),
    prima_moneda          = COALESCE(NULLIF(v_payload->>'prima_moneda','')::moneda_poliza, prima_moneda),
    sa_input              = COALESCE(NULLIF(v_payload->>'sa_input','')::numeric, sa_input),
    sa_moneda             = COALESCE(NULLIF(v_payload->>'sa_moneda','')::moneda_poliza, sa_moneda),
    producto_parametro_id = COALESCE(NULLIF(v_payload->>'producto_parametro_id','')::uuid, producto_parametro_id),
    meses_check           = COALESCE((CASE WHEN jsonb_typeof(v_payload->'meses_check')='object' THEN v_payload->'meses_check' END), meses_check),
    updated_at            = now()
  WHERE id = v_poliza_id;

  SELECT * INTO r_new FROM polizas WHERE id = v_poliza_id;

  v_old_prima := r_old.prima_input;
  v_new_prima := r_new.prima_input;
  IF v_old_prima IS DISTINCT FROM v_new_prima THEN
    INSERT INTO historial_costos_poliza(
      id, poliza_id, prima_anual_old, prima_anual_new, porcentaje_comision_old, porcentaje_comision_new, actor_id, creado_at
    ) VALUES (
      gen_random_uuid(), v_poliza_id, v_old_prima, v_new_prima, NULL, NULL, auth.uid(), now()
    );
  END IF;

  UPDATE poliza_update_requests 
  SET estado='APROBADA', resuelto_at=now(), resuelto_por=auth.uid()
  WHERE id = p_request_id AND estado='PENDIENTE';

  PERFORM recalc_puntos_poliza(v_poliza_id);
END;
$$;

-- ============================================================================
-- Alter existing functions with search_path issues
-- ============================================================================

-- Poliza recalculation functions
ALTER FUNCTION producto_parametros_after_update_recalc() SET search_path = public;
ALTER FUNCTION recalc_polizas_by_producto_parametro(uuid) SET search_path = public;
ALTER FUNCTION recalc_puntos_poliza_all(integer) SET search_path = public;
ALTER FUNCTION recalc_puntos_poliza(uuid) SET search_path = public;

-- Poliza trigger functions
ALTER FUNCTION polizas_before_insupd_enforce_moneda() SET search_path = public;
ALTER FUNCTION polizas_normalize_amounts() SET search_path = public;
ALTER FUNCTION poliza_year_vigencia(date) SET search_path = public;

-- Campaign cache invalidation triggers
ALTER FUNCTION trigger_invalidate_cache_on_candidatos() SET search_path = public;
ALTER FUNCTION trigger_invalidate_cache_on_clientes() SET search_path = public;
ALTER FUNCTION trigger_invalidate_cache_on_custom_metrics() SET search_path = public;
ALTER FUNCTION trigger_invalidate_cache_on_planificaciones() SET search_path = public;
ALTER FUNCTION trigger_invalidate_cache_on_polizas() SET search_path = public;
ALTER FUNCTION trigger_invalidate_cache_on_prospectos() SET search_path = public;
ALTER FUNCTION trigger_invalidate_cache_on_user_segments() SET search_path = public;
ALTER FUNCTION invalidate_campaign_cache_for_user(bigint) SET search_path = public;

-- Poliza update RPC functions
ALTER FUNCTION submit_poliza_update(uuid, jsonb) SET search_path = public;
ALTER FUNCTION reject_poliza_update(uuid, text) SET search_path = public;

-- Payment related functions
ALTER FUNCTION fn_generar_pagos_programados() SET search_path = public;
ALTER FUNCTION fn_actualizar_pagos_vencidos() SET search_path = public;

-- Utility functions
ALTER FUNCTION get_current_udi(date) SET search_path = public;
ALTER FUNCTION get_fx_usd(date) SET search_path = public;
ALTER FUNCTION jwt_role() SET search_path = public;
ALTER FUNCTION normalize_prima(numeric, moneda_poliza, date) SET search_path = public;
ALTER FUNCTION is_super_role() SET search_path = public;
ALTER FUNCTION is_super_role_wrapper() SET search_path = public;

-- Campaign functions
ALTER FUNCTION calculate_campaign_datasets_for_user(bigint) SET search_path = public;
ALTER FUNCTION evaluate_all_campaigns() SET search_path = public;

-- Cliente update functions
ALTER FUNCTION apply_cliente_update(uuid) SET search_path = public;
ALTER FUNCTION reject_cliente_update(uuid, text) SET search_path = public;
ALTER FUNCTION submit_cliente_update(uuid, jsonb) SET search_path = public;
ALTER FUNCTION generar_cliente_code() SET search_path = public;

-- Producto parametros functions
ALTER FUNCTION producto_parametros_after_update_sync_moneda() SET search_path = public;
ALTER FUNCTION producto_parametros_set_keys() SET search_path = public;

-- User and segment functions
ALTER FUNCTION transfer_reassign_usuario(bigint, bigint, text) SET search_path = public;
ALTER FUNCTION assign_user_segment(bigint, text) SET search_path = public;
ALTER FUNCTION assign_user_segment_by_name(text, text) SET search_path = public;

-- Materialized view functions
ALTER FUNCTION refresh_vw_cancelaciones_indices() SET search_path = public;

-- Common trigger function
ALTER FUNCTION set_updated_at() SET search_path = public;

-- Debug function
ALTER FUNCTION apply_poliza_update_dbg(uuid) SET search_path = public;

-- ============================================================================
-- Fix normalize_prima to always use latest UDI/FX value (don't fail on future dates)
-- ============================================================================
CREATE OR REPLACE FUNCTION normalize_prima(p_monto numeric, p_moneda moneda_poliza, p_fecha date DEFAULT NULL)
RETURNS numeric
LANGUAGE plpgsql
STABLE
SET search_path = public
AS $$
DECLARE
  v numeric;
BEGIN
  IF p_monto IS NULL OR p_moneda IS NULL THEN
    RETURN NULL;
  END IF;

  IF p_moneda = 'MXN'::moneda_poliza THEN
    RETURN round(p_monto, 2);
  ELSIF p_moneda = 'USD'::moneda_poliza THEN
    -- Buscar FX mÃ¡s reciente disponible (sin restricciÃ³n de fecha)
    SELECT valor INTO v FROM fx_values ORDER BY fecha DESC LIMIT 1;
    IF v IS NULL THEN
      RAISE EXCEPTION 'No FX (USD/MXN) disponible en el sistema';
    END IF;
    RETURN round(p_monto * v, 2);
  ELSIF p_moneda = 'UDI'::moneda_poliza THEN
    -- Buscar UDI mÃ¡s reciente disponible (sin restricciÃ³n de fecha)
    SELECT valor INTO v FROM udi_values ORDER BY fecha DESC LIMIT 1;
    IF v IS NULL THEN
      RAISE EXCEPTION 'No UDI disponible en el sistema';
    END IF;
    RETURN round(p_monto * v, 2);
  ELSE
    -- Por si se agrega moneda futura; devolvemos monto sin cambio
    RETURN round(p_monto, 2);
  END IF;
END;
$$;

-- ============================================================================
-- Create trigger to auto-generate monthly payments when policy is created/updated
-- ============================================================================
DROP TRIGGER IF EXISTS trg_generar_pagos_auto ON polizas;

CREATE TRIGGER trg_generar_pagos_auto
AFTER INSERT OR UPDATE OF periodicidad_pago, prima_mxn, fecha_emision, dia_pago
ON polizas
FOR EACH ROW
EXECUTE FUNCTION fn_generar_pagos_programados();

-- ============================================================================
-- Grant RPC execution permissions (if not already granted)
-- ============================================================================
GRANT EXECUTE ON FUNCTION apply_poliza_update(uuid) TO authenticated, anon, service_role;
GRANT EXECUTE ON FUNCTION recalc_puntos_poliza(uuid) TO authenticated, anon, service_role;
GRANT EXECUTE ON FUNCTION submit_poliza_update(uuid, jsonb) TO authenticated, anon, service_role;
GRANT EXECUTE ON FUNCTION reject_poliza_update(uuid, text) TO authenticated, anon, service_role;

-- ============================================================================
-- Verification query (commented out, run manually if needed)
-- ============================================================================
-- SELECT 
--   COUNT(*) FILTER (WHERE config IS NULL) as sin_config,
--   COUNT(*) FILTER (WHERE config = 'search_path=') as con_vacio,
--   COUNT(*) FILTER (WHERE config = 'search_path=public') as con_public
-- FROM (
--   SELECT p.proname, array_to_string(p.proconfig, ', ') as config
--   FROM pg_proc p
--   JOIN pg_namespace n ON p.pronamespace = n.oid
--   WHERE n.nspname = 'public' AND p.prokind = 'f'
-- ) sub;


-- FILE: 20251227_notificaciones.sql
-- Tabla: notificaciones (in-app)
-- Almacena notificaciones internas para usuarios (pagos vencidos, etc.)

CREATE TABLE IF NOT EXISTS notificaciones (
  id BIGSERIAL PRIMARY KEY,
  usuario_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  tipo VARCHAR(50) NOT NULL CHECK (tipo IN ('pago_vencido', 'pago_proximo', 'comision_disponible', 'sistema')),
  titulo VARCHAR(255) NOT NULL,
  mensaje TEXT NOT NULL,
  leida BOOLEAN DEFAULT FALSE,
  metadata JSONB DEFAULT '{}'::jsonb, -- Datos adicionales: {poliza_id, pago_id, etc.}
  created_at TIMESTAMPTZ DEFAULT NOW(),
  leida_at TIMESTAMPTZ NULL
);

-- Ãndices
CREATE INDEX IF NOT EXISTS idx_notificaciones_usuario_leida 
  ON notificaciones(usuario_id, leida, created_at DESC);

CREATE INDEX IF NOT EXISTS idx_notificaciones_tipo 
  ON notificaciones(tipo);

CREATE INDEX IF NOT EXISTS idx_notificaciones_created 
  ON notificaciones(created_at DESC);

-- RLS Policies
ALTER TABLE notificaciones ENABLE ROW LEVEL SECURITY;

-- Los usuarios solo ven sus propias notificaciones
CREATE POLICY pol_notificaciones_select 
  ON notificaciones FOR SELECT 
  USING (usuario_id = auth.uid());

-- Los usuarios pueden marcar sus notificaciones como leÃ­das
CREATE POLICY pol_notificaciones_update 
  ON notificaciones FOR UPDATE 
  USING (usuario_id = auth.uid())
  WITH CHECK (usuario_id = auth.uid());

-- Solo el sistema (service_role) puede insertar notificaciones
-- (desde Edge Functions o triggers)
CREATE POLICY pol_notificaciones_insert 
  ON notificaciones FOR INSERT 
  WITH CHECK (true); -- Se controla a nivel de service_role key

COMMENT ON TABLE notificaciones IS 'Notificaciones in-app para usuarios (alertas de pagos, comisiones, sistema)';
COMMENT ON COLUMN notificaciones.tipo IS 'pago_vencido | pago_proximo | comision_disponible | sistema';
COMMENT ON COLUMN notificaciones.metadata IS 'Datos extras en JSON: {poliza_id, pago_id, monto, etc.}';


-- FILE: 20260105_adjust_comisiones_pagado.sql
-- Ajuste: comisiones dashboard debe reflejar pagos marcados como pagados en poliza_pagos_mensuales
-- Fecha: 2026-01-05
-- Nota: recalcula vw_comisiones_agente_mes para usar pagos pagados (ppm.estado = 'pagado')
--       y mantiene las vistas de dashboard sin cambiar sus columnas.

-- Vista base: comisiones por agente y mes usando pagos pagados
CREATE OR REPLACE VIEW vw_comisiones_agente_mes AS
SELECT 
  cl.asesor_id,
  u.id AS usuario_id,
  u.nombre AS agente_nombre,
  u.email AS agente_email,
  DATE_TRUNC('month', ppm.periodo_mes)::date AS mes_emision,
  TO_CHAR(DATE_TRUNC('month', ppm.periodo_mes), 'YYYY-MM') AS periodo,
  COUNT(DISTINCT p.id) AS total_polizas,
  SUM(ppm.monto_pagado) AS prima_total,
  SUM(ppm.monto_pagado * COALESCE(ppc.base_factor, 0) / 100) AS comision_estimada,
  SUM(
    CASE 
      WHEN ppm.estado = 'pagado' THEN ppm.monto_pagado * COALESCE(ppc.base_factor, 0) / 100
      ELSE 0
    END
  ) AS comision_vigente
FROM poliza_pagos_mensuales ppm
INNER JOIN polizas p ON ppm.poliza_id = p.id
INNER JOIN clientes cl ON p.cliente_id = cl.id
INNER JOIN usuarios u ON cl.asesor_id = u.id_auth
LEFT JOIN poliza_puntos_cache ppc ON p.id = ppc.poliza_id
WHERE p.anulada_at IS NULL
  AND u.rol = 'agente'
  AND u.activo = TRUE
  AND ppm.estado = 'pagado'
GROUP BY cl.asesor_id, u.id, u.nombre, u.email, DATE_TRUNC('month', ppm.periodo_mes);

COMMENT ON VIEW vw_comisiones_agente_mes IS 'Comisiones agregadas por agente y mes, usando pagos marcados como pagado y base_factor de cada pÃ³liza';


-- FILE: 20260105_fix_mes_conexion_empty.sql
-- Ajuste: excluir mes_conexion vacÃ­o ('') de la vista con conexiÃ³n
-- Fecha: 2026-01-05

-- Vista: Agentes/supervisores con mes de conexiÃ³n (no null y no vacÃ­o)
CREATE OR REPLACE VIEW vw_agentes_con_mes_conexion AS
SELECT 
  u.id AS usuario_id,
  u.id_auth,
  u.email,
  u.nombre AS agente_nombre,
  c.mes_conexion,
  c.candidato,
  c.efc
FROM usuarios u
INNER JOIN candidatos c ON LOWER(c.email_agente) = LOWER(u.email)
WHERE u.rol IN ('agente','supervisor')
  AND u.activo = TRUE
  AND c.eliminado = FALSE
  AND c.mes_conexion IS NOT NULL
  AND c.mes_conexion <> '';

COMMENT ON VIEW vw_agentes_con_mes_conexion IS 'Agentes y supervisores con mes de conexiÃ³n registrado en candidatos (no vacÃ­o)';

-- Vista: Agentes/supervisores sin mes de conexiÃ³n (considera nulo o vacÃ­o como sin conexiÃ³n)
CREATE OR REPLACE VIEW vw_agentes_sin_mes_conexion AS
SELECT 
  u.id AS usuario_id,
  u.id_auth,
  u.email,
  u.nombre AS agente_nombre
FROM usuarios u
WHERE u.rol IN ('agente','supervisor')
  AND u.activo = TRUE
  AND NOT EXISTS (
    SELECT 1 
    FROM candidatos c 
    WHERE LOWER(c.email_agente) = LOWER(u.email)
      AND c.eliminado = FALSE
      AND c.mes_conexion IS NOT NULL
      AND c.mes_conexion <> ''
  );

COMMENT ON VIEW vw_agentes_sin_mes_conexion IS 'Agentes y supervisores que no tienen mes de conexiÃ³n (nulo o vacÃ­o)';


-- FILE: 20260105_include_supervisores_comisiones.sql
-- Ajuste: incluir supervisores en dashboards de comisiones
-- Fecha: 2026-01-05
-- Nota: amplÃ­a rol a ('agente','supervisor') en vistas de comisiones y agentes con/sin mes de conexiÃ³n.

-- Vista: Agentes (y supervisores) con mes de conexiÃ³n
CREATE OR REPLACE VIEW vw_agentes_con_mes_conexion AS
SELECT 
  u.id AS usuario_id,
  u.id_auth,
  u.email,
  u.nombre AS agente_nombre,
  c.mes_conexion,
  c.candidato,
  c.efc
FROM usuarios u
INNER JOIN candidatos c ON LOWER(c.email_agente) = LOWER(u.email)
WHERE u.rol IN ('agente','supervisor')
  AND u.activo = TRUE
  AND c.eliminado = FALSE
  AND c.mes_conexion IS NOT NULL;

COMMENT ON VIEW vw_agentes_con_mes_conexion IS 'Agentes y supervisores con mes de conexiÃ³n registrado en candidatos';

-- Vista: Agentes (y supervisores) sin mes de conexiÃ³n
CREATE OR REPLACE VIEW vw_agentes_sin_mes_conexion AS
SELECT 
  u.id AS usuario_id,
  u.id_auth,
  u.email,
  u.nombre AS agente_nombre
FROM usuarios u
WHERE u.rol IN ('agente','supervisor')
  AND u.activo = TRUE
  AND NOT EXISTS (
    SELECT 1 
    FROM candidatos c 
    WHERE LOWER(c.email_agente) = LOWER(u.email)
      AND c.eliminado = FALSE
      AND c.mes_conexion IS NOT NULL
  );

COMMENT ON VIEW vw_agentes_sin_mes_conexion IS 'Agentes y supervisores que NO tienen mes de conexiÃ³n en candidatos';

-- Vista base: comisiones por rol agente/supervisor y mes usando pagos pagados
CREATE OR REPLACE VIEW vw_comisiones_agente_mes AS
SELECT 
  cl.asesor_id,
  u.id AS usuario_id,
  u.nombre AS agente_nombre,
  u.email AS agente_email,
  DATE_TRUNC('month', ppm.periodo_mes)::date AS mes_emision,
  TO_CHAR(DATE_TRUNC('month', ppm.periodo_mes), 'YYYY-MM') AS periodo,
  COUNT(DISTINCT p.id) AS total_polizas,
  SUM(ppm.monto_pagado) AS prima_total,
  SUM(ppm.monto_pagado * COALESCE(ppc.base_factor, 0) / 100) AS comision_estimada,
  SUM(
    CASE 
      WHEN ppm.estado = 'pagado' THEN ppm.monto_pagado * COALESCE(ppc.base_factor, 0) / 100
      ELSE 0
    END
  ) AS comision_vigente
FROM poliza_pagos_mensuales ppm
INNER JOIN polizas p ON ppm.poliza_id = p.id
INNER JOIN clientes cl ON p.cliente_id = cl.id
INNER JOIN usuarios u ON cl.asesor_id = u.id_auth
LEFT JOIN poliza_puntos_cache ppc ON p.id = ppc.poliza_id
WHERE p.anulada_at IS NULL
  AND u.rol IN ('agente','supervisor')
  AND u.activo = TRUE
  AND ppm.estado = 'pagado'
GROUP BY cl.asesor_id, u.id, u.nombre, u.email, DATE_TRUNC('month', ppm.periodo_mes);

COMMENT ON VIEW vw_comisiones_agente_mes IS 'Comisiones agregadas por agente/supervisor y mes, usando pagos marcados como pagado y base_factor de cada pÃ³liza';


-- FILE: 20260105_trigger_fill_pagado.sql
-- Trigger: auto-fill monto_pagado y fecha_pago_real al marcar como pagado
-- Fecha: 2026-01-05

CREATE OR REPLACE FUNCTION trg_fill_pagado_fields()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  IF NEW.estado = 'pagado' THEN
    IF NEW.monto_pagado IS NULL THEN
      NEW.monto_pagado := COALESCE(NEW.monto_programado, 0);
    END IF;
    IF NEW.fecha_pago_real IS NULL THEN
      NEW.fecha_pago_real := now();
    END IF;
  END IF;
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_poliza_pagos_fill_pagado ON poliza_pagos_mensuales;
CREATE TRIGGER trg_poliza_pagos_fill_pagado
  BEFORE UPDATE ON poliza_pagos_mensuales
  FOR EACH ROW
  WHEN (OLD.estado IS DISTINCT FROM NEW.estado OR NEW.monto_pagado IS NULL OR NEW.fecha_pago_real IS NULL)
  EXECUTE FUNCTION trg_fill_pagado_fields();


-- FILE: 20260121_notificaciones_updated_at.sql
-- Agregar updated_at y trigger a notificaciones para limpieza automÃ¡tica

-- Agregar columna updated_at (inicializada con created_at para registros existentes)
ALTER TABLE notificaciones 
  ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ DEFAULT NOW();

-- Actualizar updated_at de registros existentes para que coincida con created_at
UPDATE notificaciones 
  SET updated_at = created_at 
  WHERE updated_at IS NULL;

-- Crear Ã­ndice para consultas de limpieza
CREATE INDEX IF NOT EXISTS idx_notificaciones_leida_updated 
  ON notificaciones(leida, updated_at) 
  WHERE leida = true;

-- Crear trigger para actualizar updated_at automÃ¡ticamente
DROP TRIGGER IF EXISTS trg_notificaciones_updated_at ON notificaciones;

CREATE TRIGGER trg_notificaciones_updated_at
  BEFORE UPDATE ON notificaciones
  FOR EACH ROW
  EXECUTE FUNCTION set_updated_at();

COMMENT ON COLUMN notificaciones.updated_at IS 'Timestamp de Ãºltima actualizaciÃ³n (para limpieza de notificaciones leÃ­das antiguas)';



